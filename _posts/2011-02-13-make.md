---
layout: post
lmtime: 2014-01-01
category: it/technical/ContinuousIntegration
title: "make"
tags:  Tool

---
#make#



##变量##
* $(VAR)
* VAR=gcc
* 如果你要使用真实的“$”字符，那么你需要用“$$”来表示
* $(var:a=b) 变量值的替换
* $(VAR)+=add_var
* 多行变量
* 全局变量
* 命令行参数
  * override
* 局部(目标)变量
  * target: var-assignments
* 自动化变量
  * $@ 表示规则中的目标文件集。在模式规则中，如果有多个目标，那么，"$@"就是匹配于目标中模式定义的集合。 
  * $% 仅当目标是函数库文件中，表示规则中的目标成员名。例如，如果一个目标是"foo.a(bar.o)"，那么，"$%"就是"bar.o"，"$@"就是"foo.a"。如果目标不是函数库文件（Unix下是[.a]，Windows下是[.lib]），那么，其值为空。 
  * $< 依赖目标中的第一个目标名字。如果依赖目标是以模式（即"%"）定义的，那么"$<"将是符合模式的一系列的文件集。注意，其是一个一个取出来的。 
  * $?  所有比目标新的依赖目标的集合。以空格分隔。 
  * $^ 所有的依赖目标的集合。以空格分隔。如果在依赖目标中有多个重复的，那个这个变量会去除重复的依赖目标，只保留一份。 
  * $+ 这个变量很像"$^"，也是所有依赖目标的集合。只是它不去除重复的依赖目标。 
  * $`*` 这个变量表示目标模式中"%"及其之前的部分 



##命令##
* @echo
* pre;suf 前后有效应的命令(环境pwd)
* 打印信息
  * $(info xxxxxxxx)
  * $(warning xxx)
  * $(error xxxxx)
  * $(error $(abx) xxxx)
* 忽略出错命令
  * -command
  * .IGNORE target
    * 这个规则中的所有命令将会忽略错误
  * make
    * -i
      * 所有命令都会忽略错误
    * -k
      * 如果某规则中的命令出错了，那么就终止该规则的执行，但继续执行其它规则 
* 嵌套执行
* 定义命令包
  * define name
  * `<TAB>` command
  * `<TAB>` command
  * endef
* 更新文件修改信息
  * <code language="makefile"> update_modify_time=touch -d "``stat -c %y $^ | sort -n | tail -1``" $@ </code>



##文件指示##
* Name
  * Makefile
  * makefile
  * make -f/--file arg
* 引入其他makefile: include
* 文件搜索
  * 默认是当前目录
  * VPATH 环境变量(Makefile)
  * vpath
    * vpath pattern directory: 为符合模式pattern的文件指定搜索目录directories
    * vpath pattern: 清除符合模式pattern的文件的搜索目录
    * vpath: 清除所有已被设置好了的文件搜索目录



##注释##
* 行注释
* #...



##表达式##
* conditional-directive
  * conditional-directive
    * ifeq(arg1,arg2)
    * ifneq(arg1,arg2)
    * ifdef var
    * ifndef var
  * text-if-true
  * else
  * test-if-false
  * endif
* function
  * $(FUNCTION ARGUMENTS)
    * 字符串处理
      * $(subst from,to,text) 字符串替换
      * $(patsubst pattern,replacement,text) 模式字符串替换
      * $(strip string) 去掉头尾空格
      * $(findstring find,in)查找字符串
      * $(filter pattern1 patter2...,text)过滤函数，符合模式的留下
      * $(filter-out pattern1 patter2...,text)反过滤
      * $(sort list) 排序
      * $(word n,text)取单词
      * $(wordlist start,end,text) 取单词串
      * $(words text)单词个数统计
      * $(firstword text) 首个单词
    * 文件名
      * $(dir names...) 
      * $(notdir names...) 
      * $(suffix names...) 取后缀
      * $(basename names...)取前缀
      * $(addsuffix suffix,names...) 
      * $(addprefix prefix,names...) 
      * $(join list1,list2)
        * 把list2 中的单词对应地加到list1的单词后面。如果list1的单词个数要比list2的多，那么list1中的多出来的单词将保持原样。如果list2的单词个数要比list1多，那么，list2多出来的单词将被复制到list2中。
    * foreach
      * names := a b c d
      * files := $(foreach n,$(names),$(n).o)
      * $(files)的值是“a.o b.o c.o d.o”
    * $(if condition, then-part) 
    * $(if condition,then-part,else-part)
    * call
    * $(origin variable)
      * undefined
      * default
      * environment
      * file
      * command line
      * automatic
    * $(shell command...)
    * $(error message)
    * $(warning message)



##规则##
* 显式
  * Simple
    * target: prerequisties
    * `<TAB>`command
    * 反斜杠 \ 作为换行符
  * 通配符
    * "`*`": 任何字符
    * "?": 单个字符
    * [...]: 集合中的一个字符
    * 反斜杠\转义为普通字符
    * $(wildcard `*`) 展开通配符结果
  * 目标
    * 伪目标 .PHONY
    * 多目标 $@
      * 静态模式 Target=target-pattern:require-pattern
        * objects = foo.o bar.o
        * all: $(objects)
        * $(objects): %.o: %.c
        * $(CC) -c $(CFLAGS) $< -o $@ 
* 隐晦
  * 自动生成依赖性
    * gcc -MM



##tags: Tool##
