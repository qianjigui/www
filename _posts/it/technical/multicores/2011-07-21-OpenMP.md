---
layout: post
category: it/technical/multicores
title: "OpenMP"
tags:  MultiCPU

---
#OpenMP#



##基本原理##
* Fork/Join多线程模型
* 在线程级别采用*共享内存*并行计算模型
* 程序员需要自我处理好并行逻辑问题



##基础API##
* Construct构建语句(和编程语句一样，引导编译器做处理)
  * Parallel声明下面的代码块将进行并行处理
    * 
    <blockquote>
          <b>#pragma omp parallel</b> <i>`[`clause`[``[`,`]` clause`]`...`]`</i>
              <i>structured block</i>
    </blockquote>
    * clauses
      * if(scalar-expression)
      * num_threads(integer-expression)
      * private(list)
      * firstprivate(list)
      * shared(list)
      * default(none|shared)
      * copyin(list)
      * reduction(operator:list)
  * Work-Sharing以下代码将进行多线程改写
    * iterations over the threads 不依赖迭代
      * 
      <blockquote>
            <b>#pragma omp for </b><i>`[`clause`[``[`,`]` clause`]`...`]` </i>
                <i>for-loop</i>
      </blockquote>
      * clauses
        * private(list)
        * firstprivate(list)
        * lastprivate(list)
        * reduction(operator:list)
        * ordered
        * schedule(kind`[`,chunk_size`]`)
        * nowait
    * independent work units相互独立的代码单元
      * 
      <blockquote>
            <b>#pragma omp sections </b><i>`[`clause`[``[`,`]` clause`]`...`]` </i>
             {
                 `[`<b>#pragma omp section</b>`]`
                       structured block
                 `[`<b>#pragma omp section</b>`]`
                       structured block
                 ......
              }
      </blockquote>
      * clauses
        * private(list)
        * firstprivate(list)
        * lastprivate(list)
        * reduction(operator:list)
        * nowait
    * Only one thread executes the code block只有一个线程运行的代码单元
      * 
      <blockquote>
            <b>#pragma omp single </b><i>`[`clause`[``[`,`]` clause`]` ...`]` </i>
                 <i>structured block</i>
      </blockquote>
      * clauses
        * private(list)
        * firstprivate(list)
        * copyprivate(list)
        * nowait
    * Combined Parallel
  * Synchronization用于线程同步
    * barrier
      * #pragma omp barrier
      * 这此处所有线程全部执行完，同步后继续执行
    * Ordered
      * 
      <blockquote>
            <b>#pragma</b> <b>omp</b> <b>ordered</b>
                 <i>structured block</i>
      </blockquote>
      * 指定接下來被程式，在被平行化的 for 迴圈將依序的執行。 Specifies that code under a parallelized for loop should be executed like a sequential loop. 
    * critical
      * 
      <blockquote>
            <b>#pragma</b> <b>omp</b> <b>critical</b> <i>`[`(name)`]` </i>
                 <i>structured block</i>
      </blockquote>
      * block中的语句将通过锁机制来维护执行的单一性
      * 通过名字name来实现不同地方的锁机制
    * atomic
      * 
      <blockquote>
            <b>#pragma</b> <b>omp</b> <b>atomic</b>
                <i>statement</i>
      </blockquote>
      * 语句原子化执行
    * master
      * 
      <blockquote>
            <b>#pragma</b> <b>omp</b> <b>master</b>
                <i>structured block</i>
      </blockquote>
      * 只有主线程执行
* Clauses附加修饰和条款
  * shared(list)
    * 利用这个有效区域的变量
    * 利用指针来达到效果
  * private(list)
    * 在各自线程内部创建一个副本
    * 利用传值的效果
  * lastprivate(list)
    * 按逻辑先后将最后一个被赋值的数据作为本数据域的结果
  * firstprivate(list)
    * 用于初始化
    * 在各个线程中可能需要用到外面的初始数据
  * default(none|shared)
    * 给下面所有的数据指定默认区间
    * none:不指定，需要程序员逐个设置
    * shared:默认都为shared(....)
  * nowait
    * 忽略 barrier（等待）。 Overrides the barrier implicit in a directive. 
  * schedule(kind`[`,chunk_size`]`)
    * kind
      * 有 dynamic、guided、runtime、static 四種方法。
      * 各个线程的for迭代范围
    * 設定 for 迴圈的平行化方法；
  * if(scalar-logical-expression)
  * num_threads(scalar-integer-expression)
  * reduction(operator:list)
    * operator:initial ization value
      * `*`:0
      * `*`:1
      * `-`:0
      * `&`:`~`0
      * `|`:0
      * `^`:0
      * `&&`:1
      * `||`:0
    * 对于特殊类型还是得借助critical
      * 
      <blockquote>
            {% highlight html %}
            sum=0;
            #pragma omp parallel shared(n,a,sum) private(TID,sumLocal)
            {
                  TID = omp_get_thread_num();
                  sumLocal = 0;
                  #pragma omp for
                     for(i=0;i&lt;n;i++)
                         sumLocal += a`[`i`]`;
                  #pragma omp critical (update_sum)
                  {
                        sum += sumLocal;
                        printf(&quot;TID=%d: sumLocal=%d sum=%d\n&quot;,TID,sumLocal,sum);
                  }
            }
            {% endhighlight %}
      </blockquote>



##学习资源##
* [OpenMP简介与语法详细列表](http://kheresy.wordpress.com/2006/06/09/簡易的程式平行化方法－openmp（一）簡介/)
* [OpenMp编程材料集合](http://www.cnblogs.com/me115/archive/2011/01/25/1944567.html)
* [OpenMP工作原理](http://cobweb.ecn.purdue.edu/ParaMount/iwomp2008/documents/chapman-underthehood)



##tags: MultiCPU##
