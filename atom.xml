<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title>PC的程序员记录</title>
 <link href="http://www.5wpc.info/atom.xml" rel="self"/>
 <link href="http://www.5wpc.info"/>
 <updated>2014-11-27T18:12:52+08:00</updated>
 <id>http://www.5wpc.info</id>
 <author>
   <name>王鹏程(WPC)</name>
   <email>qianjigui@gmail.com</email>
 </author>

 
 <entry>
   <title>Ruby 元编程</title>
   <link href="http://www.5wpc.info/it/technical/language/ruby/2014/11/23/MetaProgramming"/>
   <updated>2014-11-23T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/technical/language/ruby/2014/11/23/MetaProgramming</id>
   <content type="html">&lt;p&gt;Ruby元编程 【意】Paolo Perrotta&lt;/p&gt;

&lt;h1&gt;Meta Programming&lt;/h1&gt;

&lt;h2&gt;对象模型&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Ruby的class关键字更像是一个作用域操作符而不是类型声明语句。它的确可以创建一个还不存在的类，不过也可以把这看成是一种副作用。对于class关键字，其核心任务是把你带到类的上下文中，让你可以在其中定义方法。&lt;/li&gt;
&lt;li&gt;与Java这样的静态语言不一样，Ruby中对象的类和它的实例变量没有关系，当给实例变量赋值时，它们就生成了。因此，对同一个类，你可以创建具有不同实例变量的对象。&lt;/li&gt;
&lt;li&gt;类自身也是对象&lt;/li&gt;
&lt;li&gt;所有常量像文件系统一样组织成树形结构。其中模块（还有类）像目录，而常量则像文件。跟文件系统一样，只要不在同一个目录下，不同文件的文件名可以相同，甚至可以像文件系统一样通过路径方式来引用一个常量。&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;对象系统&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;什么是对象？对象无非就是一组实例变量外加一个指向其类的引用。对象的方法并不存在于对象本身，而是存在于对象的类中。在类中，这些方法被称为类的实例方法。&lt;/li&gt;
&lt;li&gt;什么是类？类无非就是一个对象（Class类的一个实例）外加一组实例方法和一个对其超类的引用。Class类是Module类的子类，因此一个类也是一个模块。&lt;/li&gt;
&lt;li&gt;跟任何其他对象一样，类有自己的方法（比如new()方法），这些是Class类的实例方法。跟其他对象一样，类必须通过引用进行访问。你已经使用常量引用过它们：这就是类的名字。&lt;/li&gt;
&lt;li&gt;为了查找一个方法，Ruby首先在接收者的类中查找，然后一层层地在祖先链中查找，直到找到这个方法为止。&lt;/li&gt;
&lt;li&gt;当你在一个类（甚至可以是另外一个模块）中包含（include）一个模块时，Ruby耍了些小花招。Ruby创建了一个封装该模块的匿名类，并把这个匿名类插入到祖先链中，其在链中的位置正好包含在它的类上方&lt;/li&gt;
&lt;li&gt;这些“封装（wrapper）”类叫做包含类（include class），有时也叫做代理类（proxy class）。包含类是Ruby的一个秘密，superclass()方法会假装它们根本不存在，而且你也一般不能通过正常的Ruby代码访问它们。&lt;/li&gt;
&lt;li&gt;当开始运行Ruby程序时，Ruby解释器会创建一个名为main的对象作为当前对象。这个对象有时被称为顶级上下文（top level context），这个名字的由来是因为这时处在调用堆栈的顶层：这时要么还没有调用任何方法，要么调用的所有方法都已经返回了。&lt;/li&gt;
&lt;li&gt;私有方法服从一个简单的规则：不能明确指定一个接收者来调用一个私有方法&lt;/li&gt;
&lt;li&gt;私有方法是由两条规则一起控制的：第一条，如果调用方法的接收者不是你自己，则必须明确指明一个接收者；第二条，私有方法只能被隐含接收者调用。把这两条规则糅合在一起，你会发现只能在自身中调用一个私有方法。你可以把这个糅合后的规则称为“私有规则”。&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;对象模型小结&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;对象由一组实例变量和一个类的引用组成。&lt;/li&gt;
&lt;li&gt;对象的方法存在于对象所属的类中（从类的角度看，它们叫做实例方法）。&lt;/li&gt;
&lt;li&gt;类本身是Class类的对象。类的名字不过是一个常量而已。&lt;/li&gt;
&lt;li&gt;Class类是Module的子类。一个模块基本上是由一组方法组成的包。类除了具有模块的特性之外，还可以被实例化（通过new()方法）及被组织为层次结构（通过它的superclass()方法）。&lt;/li&gt;
&lt;li&gt;常量像文件系统一样，是按照树形结构组织的。其中模块和类的名字扮演目录的角色，其他普通的常量则扮演文件的角色。&lt;/li&gt;
&lt;li&gt;每个类都有一个祖先链，这个链从自己所属的类开始，向上直到BasicObject类结束。&lt;/li&gt;
&lt;li&gt;当调用一个方法时，Ruby首先向右一步来到接收者所属的类，然后一直向上查找祖先链，直到找到该方法，或者到达链的顶端为止。&lt;/li&gt;
&lt;li&gt;每当类包含一个模块时，该模块会被插入到祖先链中，位置在该类的正上方。&lt;/li&gt;
&lt;li&gt;当调用一个方法时，接收者会扮演self的角色。&lt;/li&gt;
&lt;li&gt;当定义一个模块（或者类）时，该模块扮演self的角色。&lt;/li&gt;
&lt;li&gt;实例变量永远都被认定为self的实例变量。&lt;/li&gt;
&lt;li&gt;任何没有明确指定接收者的方法调用，都当成是调用self的方法。&lt;/li&gt;
&lt;li&gt;注: ruby的统一化思想，self很关键。理清楚上下文，可以更好的使用。&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;2.5 关于method_missing()方法的更多内容&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;第一种方法依赖于动态方法和动态派发：&lt;/li&gt;
&lt;/ol&gt;


&lt;pre&gt;&lt;code&gt;#methods/computer/more_dynamic.rb

class Computer
    def initialize(computer_id, data_source)
        @id = computer_id
        @data_source = data_source
        data_source.methods.grep(/^get_(.*)_info$/) { Computer.define_component $1 }
    end

    def self.define_component(name)
        define_method(name) {
            info = @data_source.send &quot;get_#{name}_info&quot;, @id
            price = @data_source.send &quot;get_#{name}_price&quot;, @id
            result = &quot;#{name.capitalize}: #{info} ($#{price})&quot;
            return &quot; * #{result}&quot; if price &amp;gt;= 100
            result
        }
    end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;第二种方法使用了动态代理及白板技术：&lt;/li&gt;
&lt;/ol&gt;


&lt;pre&gt;&lt;code class=&quot;ruby&quot;&gt;# methods/computer/final.rb

class Computer
    instance_methods.each do |m|
        undef_method m unless m.to_s =~ /^__|method_missing|respond_to?/
    end
    def initialize(computer_id, data_source)
        @id = computer_id
        @data_source = data_source
    end

    def method_missing(name, *args)
        super if !respond_to?(name)
        info = @data_source.send(&quot;get_#{name}_info&quot;, args[0])
        price = @data_source.send(&quot;get_#{name}_price&quot;, args[0])
        result = &quot;#{name.to_s.capitalize}: #{info} ($#{price})&quot;
        return &quot; * #{result}&quot; if price &amp;gt;= 100
        result
    end

    def respond_to?(method)
        @data_source.respond_to?(&quot;get_#{method}_info&quot;) || super
    end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;ensure&lt;/code&gt;语句都会调用&lt;code&gt;resource&lt;/code&gt;的&lt;code&gt;dispose()&lt;/code&gt;方法来释放它。

&lt;ul&gt;
&lt;li&gt;注: 主要再学习下整个异常体系，何时是捕获。该处表现的是finally效果&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h3&gt;作用域门&lt;/h3&gt;

&lt;p&gt;准确地说，程序会在三个地方关闭前一个作用域，同时打开一个新的作用域：
* 类定义。
* 模块定义。
* 方法。&lt;/p&gt;

&lt;p&gt;只要程序进入类或模块及方法的定义，就会发生作用域切换。这三个边界分别用class、module和def关键字作为标志。每一个关键字都充当了一个作用域门（Scope Gate）。&lt;/p&gt;

&lt;p&gt;每个Ruby作用域包含一组绑定，并且不同的作用域之间被作用域门分隔开来：class、module和def。如果要让一两个绑定穿越作用域门，那么可以用方法调用来代替作用域门：用一个闭包获取当前的绑定，并把这个闭包传递给该方法。你可以使用Class.new()方法代替class，使用Module.new代替module，以及使用Module#define_method()代替def。这就形成了一个扁平作用域，它是闭包中的一个基本概念。如果在一个扁平作用域中定义了多个方法，则这些方法可以用一个作用域门进行保护，并共享绑定，这种技术称为共享作用域。&lt;/p&gt;

&lt;h3&gt;代码片段&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;可调用对象是可以执行的代码片段，而且它们有自己的作用域。可调用对象可以有以下几种方式。&lt;/li&gt;
&lt;li&gt;块（虽然它们不是真正的“对象”，但是它们是“可调用的”）：在定义它们的作用域中执行。&lt;/li&gt;
&lt;li&gt;proc：Proc类的对象，跟块一样，它们也在定义自身的作用域中执行。&lt;/li&gt;
&lt;li&gt;lambda：也是Proc类的对象，但是它跟普通的proc有细微的区别。它跟块和proc一样都是闭包，因此也在定义自身的作用域中执行。&lt;/li&gt;
&lt;li&gt;方法：绑定于对象，在所绑定对象的作用域中执行。它们也可以与这个作用域解除绑定，再重新绑定到另一个对象的作用域上。&lt;/li&gt;
&lt;li&gt;不同种类的可调用对象有细微的区别。在方法和lambda中，return语句从可调用对象中返回。在块和proc中，return语句从定义可调用对象的原始上下文中返回。另外，不同的可调用对象对传入参数数目不符有不同的反应。其中方法处理方式最严格，lambda同样严格（它与方法相比，在某些极端情况下略为宽松），而proc和块则要宽松一些。&lt;/li&gt;
&lt;li&gt;尽管有这些区别，还是可以将一种可调用对象转换为另外一种可调用对象的，实现这样功能的方法包括Proc.new()方法、Method#to_proc()方法和&amp;amp;操作符。&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;4.1 类定义揭秘&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;如果希望在类中存储一个变量，那么除了类实例变量，还可以使用以@@开头的类变量（class variable）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  class C
      @@v = 1
  end
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;类变量与类实例变量不同，它们可以被子类或类的实例所使用（在这个意义上，它们更像是Java的静态成员。）。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  class D &amp;lt; C
      def my_method; @@v; end
  end
  D.new.my_method # 1
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;不幸的是，类变量有一个很不好的怪癖。下面是一个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  @@v = 1
  class MyClass
      @@v = 2
  end
  @@v # 2
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;得到这样的结果是因为类变量并不真正属于类 ——它们属于类体系结构。由于@@v定义于main的上下文，它属于main的类Object……所以也属于Object的所有后代。MyClass继承自Object，因此它也共享了这个类变量。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;从技术上讲，尽管这种行为可以理解，但它还是很容易把你绊倒。因为可能会遇到上面所示的意外事件，现在绝大多数Ruby主义者都避免使用类变量，而尽量使用类实例变量。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;instance_eval&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;instance_eval()&lt;/code&gt;方法的标准含义是：“我想修改self。”&lt;/p&gt;

&lt;h3&gt;eigenclass&lt;/h3&gt;

&lt;p&gt;如果把eigenclass、普通类和模块放到一起，Ruby对象模型可以总结为7条规则：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;只有一种对象——要么是普通对象，要么是模块。&lt;/li&gt;
&lt;li&gt;只有一种模块——可以是普通模块、类、eigenclass或代理类。&lt;/li&gt;
&lt;li&gt;只有一个方法，它存在于一种模块中——通常是类中。&lt;/li&gt;
&lt;li&gt;每个对象（包括类）都有自己的“真正的类”——要么是普通类，要么是eigenclass。&lt;/li&gt;
&lt;li&gt;除了BasicObject类（在Ruby 1.8中是Object类）无超类外，每个类有且只有一个超类。这意味着从任何类只有一条向上直到BasicObject的祖先链。&lt;/li&gt;
&lt;li&gt;一个对象的eigenclass的超类是这个对象的类；一个类的eigenclass的超类是这个类的超类的eigenclass（试着把这个绕口令重复三遍，加快速度！然后回头看看图4.5，你会发现这句话是有道理的。）。&lt;/li&gt;
&lt;li&gt;当调用一个方法，Ruby先向“右”迈一步进入接收者真正的类，然后向“上”进入祖先链。这就是Ruby查找方法的全部内容。&lt;/li&gt;
&lt;/ol&gt;


&lt;h3&gt;4.5 小测验：模块的麻烦&lt;/h3&gt;

&lt;p&gt;当类包含模块时，它获得的是该模块的实例方法——而不是类方法。类方法存在于模块的eigenclass中，依然无法触碰。&lt;/p&gt;

&lt;h3&gt;5.7 钩子方法&lt;/h3&gt;

&lt;p&gt;这种技术是前面两种法术——类扩展和钩子方法——的结合。可以把这种技术称为类扩展混入（Class Extension Mixin）。
现在应该回顾使用这种法术的步骤：
1. 定义一个模块，姑且叫做MyMixin。
2. 在MyMixin中定义一个内部模块（通常把它叫做ClassMethods），并给它定义一些方法。这些方法最终会成为类方法。
3. 覆写MyMixin#included()方法来用ClassMethods扩展包含者（使用extend()方法）。&lt;/p&gt;

&lt;h3&gt;5.8 小测验：校验过的属性（第五步）&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;
module CheckedAttributes
    def self.included(base)
        base.extend ClassMethods
    end

    module ClassMethods
        def attr_checked(attribute, &amp;amp;validation)
            define_method &quot;#{attribute}=&quot; do |value|
                raise &#39;Invalid attribute&#39; unless validation.call(value)
                instance_variable_set(&quot;@#{attribute}&quot;, value)
            end

            define_method attribute do
                instance_variable_get &quot;@#{attribute}&quot;
            end
        end
    end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;第6章 尾声&lt;/h1&gt;

&lt;p&gt;大师烦了。“虽然你够聪明，小子，”大师说道，“但是你有足够的智慧去忘掉所学的东西么？根本没有什么元编程，只有编程而已。走吧，让我继续平静地沉思。”
通过增加代码的内部复杂性，库就可以更容易为客户端所使用。&lt;/p&gt;

&lt;h1&gt;Ruby法术&lt;/h1&gt;

&lt;h2&gt;数组参数 Argument Array&lt;/h2&gt;

&lt;p&gt;把一组参数压入到一个数组中。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
def my_method(*args)
    args.map{|arg|arg.reverse}
end
my_method(&#39;abc&#39;,&#39;xyz&#39;,&#39;123&#39;)#=&amp;gt;[&quot;cba&quot;,&quot;zyx&quot;,&quot;321&quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;环绕别名&lt;/h2&gt;

&lt;p&gt;Around Alias
从一个重新定义的方法中调用原始的、被重命名的版本。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
class String
    alias :old_reverse:reverse
    def reverse
        &quot;x#{old_reverse}x&quot;
    end
end
&quot;abc&quot;.reverse#=&amp;gt;&quot;xcbax&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;白板&lt;/h2&gt;

&lt;p&gt;Blank Slate
移除一个对象中的所有方法，以便把它们转换成幽灵方法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
class C
    def method_missing(name,*args)
        &quot;a Ghost Method&quot;
    end
end
obj=C.new
obj.to_s#=&amp;gt;&quot;#&amp;lt;C:0x357258&amp;gt;&quot;
class C
    instance_methods.each do|m|
        undef_methodm unless m.to_s=~/method_missing|respond_to?|^/
    end
end
obj.to_s#=&amp;gt;&quot;a Ghost Method&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;类扩展&lt;/h2&gt;

&lt;p&gt;Class Extension
通过向类的eigenclass中混入模块来定义类方法（是对象扩展的一个特例）。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
class C;end
module M
    def my_method
        &#39;aclass method&#39;
    end
end
class&amp;lt;&amp;lt;C
    include M
end
C.my_method#=&amp;gt;&quot;a class method&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;类扩展混入&lt;/h2&gt;

&lt;p&gt;Class Extension Mixin
使一个模块可以通过钩子方法扩展它的包含者。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
module M
    def self.included(base)
        base.extend(ClassMethods)
    end
    module ClassMethods
        def my_method
            &#39;a class method&#39;
        end
    end
end
class C
    include M
end
C.my_method#=&amp;gt;&quot;a class method&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;类实例变量&lt;/h2&gt;

&lt;p&gt;Class Instance Variable
在一个Class对象的实例变量中存储类级别的状态。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
class C
    @my_class_instance_variable=&quot;some value&quot;
    def self.class_attribute
        @my_class_instance_variable
    end
end
C.class_attribute#=&amp;gt;&quot;some value&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;类宏&lt;/h2&gt;

&lt;p&gt;Class Macro
在类定义中使用一个类方法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
class C;end
class&amp;lt;&amp;lt;C
    def my_macro(arg)
        &quot;my_macro(#{arg}) called&quot;
    end
end
class C
    my_macro:x#=&amp;gt;&quot;my_macro(x) called&quot;
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;洁净室&lt;/h2&gt;

&lt;p&gt;Clean Room
使用对象作为执行块的上下文环境。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
class CleanRoom
    def a_useful_method(x);x*2;end
end
CleanRoom.new.instance_eval{a_useful_method(3)} #=&amp;gt;6
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;代码处理器&lt;/h2&gt;

&lt;p&gt;Code Processor
处理从外部获得的字符串代码。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
File.readlines(&quot;a_file_containing_lines_of_ruby.txt&quot;).each do|line|
    puts&quot;#{line.chomp}==&amp;gt;#{eval(line)}&quot;
end
#&amp;gt;&amp;gt;1+1==&amp;gt;2
#&amp;gt;&amp;gt;3*2==&amp;gt;6
#&amp;gt;&amp;gt;Math.log10(100)==&amp;gt;2.0
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;上下文探针&lt;/h2&gt;

&lt;p&gt;Context Probe
执行块来获取对象上下文中的信息。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
class C
    def initialize
        @x=&quot;a private instance variable&quot;
    end
end
obj=C.new
obj.instance_eval{@x}#=&amp;gt;&quot;a private instance variable&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;延迟执行&lt;/h2&gt;

&lt;p&gt;Deferred Evaluation
在proc或lambda中存储一段代码及其上下文，用于以后执行。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
class C
    def store(&amp;amp;block)
        @my_code_capsule=block
    end
    def execute
        @my_code_capsule.call
    end
end
obj=C.new
obj.store{$X=1}
$X=0
obj.execute
$X#=&amp;gt;1
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;动态派发&lt;/h2&gt;

&lt;p&gt;Dynamic Dispatch
在运行时决定调用哪个方法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
method_to_call=:reverse
obj=&quot;abc&quot;
obj.send(method_to_call)#=&amp;gt;&quot;cba&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;动态方法&lt;/h2&gt;

&lt;p&gt;Dynamic Method
在运行时才决定如何定义一个方法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
class C
end
C.class_eval do
    define_method:my_method do
        &quot;a dynamic method&quot;
    end
end
obj=C.new
obj.my_method#=&amp;gt;&quot;a dynamic method&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;动态代理&lt;/h2&gt;

&lt;p&gt;Dynamic Proxy
把不能对应某个方法名的消息转发给另外一个对象。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
class MyDynamicProxy
    def initialize(target)
        @target=target
    end
    def method missing(name,*args,&amp;amp;block)
        &quot;result:#{@target.send(name,*args,&amp;amp;block)}&quot;
    end
end
obj=MyDynamicProxy.new(&quot;a string&quot;)
obj.reverse#=&amp;gt;&quot;result: gnirts a&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;扁平作用域&lt;/h2&gt;

&lt;p&gt;Flat Scope
使用闭包在两个作用域之间共享变量。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
class C
    def an_attribute
        @attr
    end
end
obj=C.new
a_variable=100
#flatscope:
obj.instance_eval do
    @attr=a_variable
end
obj.an_attribute#=&amp;gt;100
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;幽灵方法&lt;/h2&gt;

&lt;p&gt;Ghost Method
响应一个没有关联方法的消息。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
class C
    def method_missing(name,*args)
        name.to_s.reverse
    end
end
obj=C.new
obj.my_ghost_method #=&amp;gt;&quot;dohtem_tsohg_ym&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;钩子方法&lt;/h2&gt;

&lt;p&gt;Hook Method
通过覆写某个特殊方法来截获对象模型事件。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
$INHERITORS=[]
class C
    def self.inherited(subclass)
        $INHERITORS&amp;lt;&amp;lt;subclass
    end
end
class D&amp;lt;C
end
class E&amp;lt;C
end
class F&amp;lt;E
end
$INHERITORS #=&amp;gt;[D,E,F]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;内核方法&lt;/h2&gt;

&lt;p&gt;Kernel Method
在Kernel模块中定义一个方法，使之对所有对象都可用。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
module Kernel
    def a_method
        &quot;a kernel method&quot;
    end
end
a_method#=&amp;gt;&quot;a kernel method&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;惰性实例变量&lt;/h2&gt;

&lt;p&gt;Lazy Instance Variable
当第一次访问一个实例变量时才对之进行初始化。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
class C
    def attribute
        @attribute=@attribute||&quot;some value&quot;
    end
end
obj=C.new
obj.attribute#=&amp;gt;&quot;some value&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;拟态方法&lt;/h2&gt;

&lt;p&gt;Mimic Method
把一个方法伪装成另外一种语言构件。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
def BaseClass(name)
    name==&quot;string&quot; ? String : Object
end
class C&amp;lt;BaseClass &quot;string&quot; #一个看起来像类的方法
    attr_accessor :an_attribute #一个看起来像关键字的方法
end
obj=C.new
obj.an_attribute=1 #一个看起来像属性的方法
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;猴子打补丁&lt;/h2&gt;

&lt;p&gt;Monkeypatch
修改已有类的特性。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
&quot;abc&quot;.reverse #=&amp;gt;&quot;cba&quot;
class String
    def reverse
        &quot;override&quot;
    end
end
&quot;abc&quot;.reverse #=&amp;gt;&quot;override&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;有名参数&lt;/h2&gt;

&lt;p&gt;Named Arguments
把方法参数收集到一个哈希表中，以便通过名字访问。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
def my_method(args)
    args[:arg2]
end
my_method(:arg1=&amp;gt;&quot;A&quot;,:arg2=&amp;gt;&quot;B&quot;,:arg3=&amp;gt;&quot;C&quot;) #=&amp;gt;&quot;B&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;命名空间&lt;/h2&gt;

&lt;p&gt;Namespace
在一个模块中定义常量，以防止命名冲突。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
module MyNamespace
    class Array
        def to_s
            &quot;myclass&quot;
        end
    end
end
Array.new #=&amp;gt;[]
MyNamespace::Array.new#=&amp;gt;my class
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;空指针保护&lt;/h2&gt;

&lt;p&gt;Nil Guard
用“或”操作符覆写一个空引用。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;x=nil
y=x ||&quot;a value&quot; # =&amp;gt;&quot;a value&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;对象扩展&lt;/h2&gt;

&lt;p&gt;Object Extension
通过给一个对象的eigenclass混入模块来定义单件方法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;obj=Object.new
module M
    def my_method
        &#39;a singleton method&#39;
    end
end
class&amp;lt;&amp;lt;obj
    include M
end
obj.my_method#=&amp;gt;&quot;a singleton method&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;打开类&lt;/h2&gt;

&lt;p&gt;Open Class
修改已有的类。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class String
    def my_string_method
        &quot;my method&quot;
    end
end
&quot;abc&quot;.my_string_method#=&amp;gt;&quot;my method&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;模式派发&lt;/h2&gt;

&lt;p&gt;Pattern Dispatch
根据名字来选择需要调用的方法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
$x=0
class C
    def my_first_method
        $x +=1
    end
    def my_second_method
        $x +=2
    end
end
obj=C.new
obj.methods.each do |m|
    obj.send(m) if m.to_s=~/^my_/
end
$x # =&amp;gt; 3
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;沙盒&lt;/h2&gt;

&lt;p&gt;Sandbox
在一个安全的环境中执行未授信的代码。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
def sandbox(&amp;amp;code)
    proc {
        $SAFE = 2
        yield
    }.call
end
begin
    sandbox{File.delete &#39;a_file&#39;}
rescue Exception=&amp;gt;ex
    ex #=&amp;gt;#&amp;lt;SecurityError:Insecure operation &#39;delete&#39; at level 2&amp;gt;
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;作用域门&lt;/h2&gt;

&lt;p&gt;Scope Gate
用class、module或def关键字来隔离作用域。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
a=1
defined? a #=&amp;gt;&quot;local-variable&quot;
module MyModule
    b = 1
    defined? a#=&amp;gt;nil
    defined? b#=&amp;gt;&quot;local-variable&quot;
end
defined? a #=&amp;gt;&quot;local-variable&quot;
defined? b #=&amp;gt;nil
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Self Yield&lt;/h2&gt;

&lt;p&gt;把self传给当前块。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
class Person
    attr_accessor :name, :surname
    def initialize
        yield self
    end
end
joe = Person.new do |p|
    p.name = &#39;Joe&#39;
    p.surname = &#39;Smith&#39;
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;共享作用域&lt;/h2&gt;

&lt;p&gt;Shared Scope
在同一个扁平作用域的多个上下文中共享变量。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
lambda {
    shared = 10
    self.class.class_eval do
        define_method: counter do
            shared
        end
        define_method :down do
            shared -= 1
        end
    end
}.call
Counter #=&amp;gt;10
3.times {down}
Counter #=&amp;gt;7
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;单件方法&lt;/h2&gt;

&lt;p&gt;Singleton Method
在一个对象上定义一个方法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
obj = &quot;abc&quot;
class &amp;lt;&amp;lt; obj
    def my_singleton_method
        &quot;x&quot;
    end
end
obj.my_singleton_method # =&amp;gt; &quot;x&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;代码字符串&lt;/h2&gt;

&lt;p&gt;String of Code
执行一段表示Ruby代码的字符串。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
my_string_of_code=&quot;1+1&quot;
eval(my_string_of_code)#=&amp;gt;2
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;符号到Proc&lt;/h2&gt;

&lt;p&gt;Symbol To Proc
把一个符号转换为调用单个方法的代码块。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
[1, 2, 3, 4].map(&amp;amp;:even?) # =&amp;gt; [false, true, false, true]
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>Ruby 最佳实践读书笔记</title>
   <link href="http://www.5wpc.info/it/technical/language/ruby/2014/11/22/BestPractice"/>
   <updated>2014-11-22T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/technical/language/ruby/2014/11/22/BestPractice</id>
   <content type="html">&lt;h1&gt;开发模式&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;TDD&lt;/li&gt;
&lt;li&gt;BDD: spec http://www.infoq.com/cn/articles/Spec-Flow&lt;/li&gt;
&lt;li&gt;Mock,Stub&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;文本处理&lt;/h1&gt;

&lt;h2&gt;Line-Based File Processing with State Tracking&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;主要问题：分析有结构的数据文件，主要是分section&lt;/li&gt;
&lt;li&gt;利用状态机原理进行分类处理,利用beginning/end markers for a section&lt;/li&gt;
&lt;li&gt;利用栈结构进行状态保存（特别是nested sections）&lt;/li&gt;
&lt;li&gt;保存整体数据状态Context&lt;/li&gt;
&lt;li&gt;&lt;p&gt;容错处理要完善，目前建议skip&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  case section
  when [xxx,xxx]
     process
  when [xxx,xxx]
     process
  else
     process
  end
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;正则表达式&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;关键概念: 正则表达式的主要特性.http://qianjigui.iteye.com/blog/1390067

&lt;ul&gt;
&lt;li&gt;Anchors&lt;/li&gt;
&lt;li&gt;Caution, quantifier&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;File API&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Pathname Ruby 1.9&lt;/li&gt;
&lt;li&gt;FileUtils&lt;/li&gt;
&lt;li&gt;tempfile&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;tempfile&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;ruby&quot;&gt;
require &#39;tempfile&#39;
a = Tempfile
a.close  (delete @ GC a)
a.close! (delete immediately)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Advanced Line Processing&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Enumerator: foreach, each&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  f=File.open
  f.each
  f.lineno
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Atomic Saves: Don&#39;t waste old file, and use tempfile then mv to it&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Function Programming&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;http://qianjigui.iteye.com/blog/1997358&lt;/li&gt;
&lt;li&gt;主要涉及基本的lamba操作,不过对其它特性支持并不好.&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;API&lt;/h1&gt;

&lt;h2&gt;pp 相关库&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;
#!/usr/bin/env ruby
#
# Pretty-Printer for Ruby Objects
require &#39;pp&#39;
friends = [
    { first_name: &#39;Emily&#39;, last_name: &#39;Laskin&#39;},
    { first_name: &#39;Nick&#39;,  last_name: &#39;Mauro&#39;},
    { first_name: &#39;Mark&#39;,  last_name: &#39;Maxwell&#39;}
]

me = {first_name: &#39;Gregory&#39;, last_name: &#39;Brown&#39;, friends: friends}

p me
puts &#39;--------------&#39;
pp me

class Person
    def initialize(fn,ln,friends)
        @fn,@ln,@frs = fn,ln,friends
    end

    # You can rewrite pretty_print
    def pretty_print(printer)
        printer.text &amp;lt;&amp;lt;-END
            Person &amp;lt;#{object_id}&amp;gt;:
                Name: #@fn #@ln
                Friends:
        END
        @frs.each do |f|
            printer.text &amp;lt;&amp;lt;-END
                    #{f[:first_name] } #{f[:last_name]}
            END
        end
    end
end

person = Person.new(&#39;Gregory&#39;,&#39;Brown&#39;,friends)
puts &#39;=========================&#39;
pp person

=begin
Output:
{:first_name=&amp;gt;&quot;Gregory&quot;, :last_name=&amp;gt;&quot;Brown&quot;, :friends=&amp;gt;[{:first_name=&amp;gt;&quot;Emily&quot;, :last_name=&amp;gt;&quot;Laskin&quot;}, {:first_name=&amp;gt;&quot;Nick&quot;, :last_name=&amp;gt;&quot;Mauro&quot;}, {:first_name=&amp;gt;&quot;Mark&quot;, :last_name=&amp;gt;&quot;Maxwell&quot;}]}
-----------
---
{:first_name=&amp;gt;&quot;Gregory&quot;,
 :last_name=&amp;gt;&quot;Brown&quot;,
 :friends=&amp;gt;
  [{:first_name=&amp;gt;&quot;Emily&quot;, :last_name=&amp;gt;&quot;Laskin&quot;},
   {:first_name=&amp;gt;&quot;Nick&quot;, :last_name=&amp;gt;&quot;Mauro&quot;},
   {:first_name=&amp;gt;&quot;Mark&quot;, :last_name=&amp;gt;&quot;Maxwell&quot;}]}
=========================
            Person &amp;lt;540731910&amp;gt;:
                Name: Gregory Brown
                Friends:
                    Emily Laskin
                    Nick Mauro
                    Mark Maxwell
=end
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;注意直接使用open，返回值是StringIO&lt;/h2&gt;

&lt;h2&gt;Working with HTTP and FTP&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;
require &#39;open-uri&#39;

a = open(&#39;http://www.ruby-lang.org/en/LICENSE.txt&#39;)
pp a
=begin
&amp;lt;StringIO:0x002b1836406a90
 @base_uri=
  #&amp;lt;URI::HTTP:0x002b1836406f68 URL:http://www.ruby-lang.org/en/about/license.txt&amp;gt;,
 @meta=
  {&quot;content-type&quot;=&amp;gt;&quot;text/plain&quot;,
   &quot;last-modified&quot;=&amp;gt;&quot;Tue, 31 Dec 2013 12:28:20 GMT&quot;,
   &quot;server&quot;=&amp;gt;&quot;thin 1.6.1 codename Death Proof&quot;,
   &quot;content-length&quot;=&amp;gt;&quot;2504&quot;,
   &quot;connection&quot;=&amp;gt;&quot;keep-alive&quot;},
 @status=[&quot;200&quot;, &quot;OK&quot;]&amp;gt;
=end
# Here, you can use StringIO for saving data
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;时间处理，词法分析，HASH加密，数学处理，cvs,json,模板生成&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;
#Working with Dates and Times(date)
puts &#39;date&#39;
pp Date.today

#Lexical Parsing with Regular Expressions(strscan)
puts &#39;strscan&#39;
require &#39;strscan&#39;
s = StringScanner.new(&#39;This is an example string&#39;)
s.eos?               # -&amp;gt; false

p s.scan(/\w+/)      # -&amp;gt; &quot;This&quot;
p s.scan(/\w+/)      # -&amp;gt; nil
p s.scan(/\s+/)      # -&amp;gt; &quot; &quot;
p s.scan(/\s+/)      # -&amp;gt; nil
p s.scan(/\w+/)      # -&amp;gt; &quot;is&quot;
s.eos?               # -&amp;gt; false

p s.scan(/\s+/)      # -&amp;gt; &quot; &quot;
p s.scan(/\w+/)      # -&amp;gt; &quot;an&quot;
p s.scan(/\s+/)      # -&amp;gt; &quot; &quot;
p s.scan(/\w+/)      # -&amp;gt; &quot;example&quot;
p s.scan(/\s+/)      # -&amp;gt; &quot; &quot;
p s.scan(/\w+/)      # -&amp;gt; &quot;string&quot;
s.eos?               # -&amp;gt; true

p s.scan(/\s+/)      # -&amp;gt; nil
p s.scan(/\w+/)      # -&amp;gt; nil

#Cryptographic Hash Functions (digest)

puts &#39;digest&#39;

require &#39;digest/md5&#39;

pp Digest::MD5.hexdigest(File.binread(__FILE__))

require &#39;digest/sha2&#39;
pp Digest::SHA256.hexdigest(File.binread(__FILE__))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Mathematical Ruby Scripts(mathn)&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;puts &#39;mathn&#39;
require &#39;mathn&#39;
pp Math.sqrt(-1)
pp 1/2
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;cvs,json,erb&lt;/h2&gt;
</content>
 </entry>
 
 <entry>
   <title>理财基本思维</title>
   <link href="http://www.5wpc.info/it/project/financialmanage/2014/11/22/BasicThoughts"/>
   <updated>2014-11-22T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/project/financialmanage/2014/11/22/BasicThoughts</id>
   <content type="html">&lt;h1&gt;&amp;lt;我最需要的理财常识书&gt; 读书笔记&lt;/h1&gt;

&lt;h2&gt;理财不仅是一种行为，更是一种态度&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;让短期的流动资金成为你的长期投资:

&lt;ul&gt;
&lt;li&gt;我们必须接受的一个重要理财观念是：用长期平稳的心态进行理财得到的收益往往比用浮躁而焦虑的心态得到的收益更高。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;你不计较生活，生活就会来计较你——算算你的生活成本有多少:

&lt;ul&gt;
&lt;li&gt;机会成本对我们每个人来说都是非常重要的，只有充分地考虑到机会成本后，才能让我们的选择更加明智。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;对沉没成本的处理，关系你的一生:

&lt;ul&gt;
&lt;li&gt;如果你沉浮股海，发现自己买的股票背离了市场的方向，产生了亏损，就必须马上停止买进或者持有，毅然放弃，不能有任何延误，不要存在任何的侥幸心理。&lt;/li&gt;
&lt;li&gt;但在我们实际理财的过程中，必须要培养出面对沉没成本勇敢舍弃的气概来，因为，沉没成本本身就是鸡肋。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;信用卡让你离富翁梦越来越远

&lt;ul&gt;
&lt;li&gt;首先告诉自己，绝对不能用信用卡提现。&lt;/li&gt;
&lt;li&gt;绝对不能刷爆信用卡&lt;/li&gt;
&lt;li&gt;坚决不能只还最低还款额，或者到期有未还欠款，这也是使用信用卡时一定要坚持做到的。&lt;/li&gt;
&lt;li&gt;刷信用卡可以，但是多向银行交一分钱，则绝对不可以！只要你能坚守这些底线，摆脱“卡奴”形象，让信用卡变成自己的工具，甚至是变成自己的“奴隶”，是完全可以做到的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;只要会投资，今天的钱比明天的钱更值钱

&lt;ul&gt;
&lt;li&gt;相对于消费来说，钱基本上是在不停地贬值的。或者换句话说，相对于货币来说，物总是在不停升值的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;花钱也要花得有技术含量

&lt;ul&gt;
&lt;li&gt;花钱消费第一是买用途，第二考虑心理的舒适度。为了小便宜而选择有质量问题的产品，必然会影响心情。其实，从今天开始，为自己树立一个消费理念：你要买的东西是否用得着？是否真的用得着？你在说服自己“这个在家里来人的时候可以拿出来用”的时候，是否能追加一个问题：家里一年来几次客人？&lt;/li&gt;
&lt;li&gt;只要你能够记住消费的两个原则——用途和使用频率，你就会慢慢变成一个会花钱的精明人了。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;银行也可能忽悠你——理财产品陷阱大公开

&lt;ul&gt;
&lt;li&gt;我们不能一味地追求更高的收益率，还要对其承担的风险进行评估&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;想要日子过得好，就要避开理财误区

&lt;ul&gt;
&lt;li&gt;最容易闯入的理财误区——为了财而理财。&lt;/li&gt;
&lt;li&gt;准确地说，我们应该树立正确的理财观念——为幸福而理财！&lt;/li&gt;
&lt;li&gt;知道方向错误的时候，停下来就等于前进！&lt;/li&gt;
&lt;li&gt;理财永远都是在调整自己的幸福结构&lt;/li&gt;
&lt;li&gt;另一个经常被人闯入的理财误区是——容易盲从，没有主见。&lt;/li&gt;
&lt;li&gt;投资理财，一定要记住三个“自”：自主决策、自担风险、自享收益。如果听从了别人的建议，跟随别人去投资，即使吃亏也不能怪别人。&lt;/li&gt;
&lt;li&gt;股票主要追求的是高收益，同时也伴随着高风险，所以千万不能把股票当作一种存钱手段；定期存款是保障存款的安全性；活期或短期存款是保证资金的流动性；而保险则更侧重于保障。我们平时购买理财产品时，一定要分清主次，分清侧重。&lt;/li&gt;
&lt;li&gt;妄想一夜暴富，是很多人投资理财的又一个大误区。&lt;/li&gt;
&lt;li&gt;事实上，一个合理的家庭固定资产比例，60%左右是最合适的，&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h2&gt;第二章 年轻人投资什么，都不如投资自己&lt;/h2&gt;

&lt;p&gt;对于毕业不久事业还没有进入稳定轨道的年轻人来说，投资自己是最重要的理财模式。只有把钱花在自己身上，才能让自己获得各方面的提升。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;什么都会贬值，能力不会

&lt;ul&gt;
&lt;li&gt;“大半的人在二十岁或三十岁上就死了：一过这个年龄，他们只变了自己的影子；以后的生命不过是用来模仿自己，把以前真正有人味儿的时代所说的、所做的、所想的、所喜欢的，一天天地重复，而且重复的方式越来越机械，越来越脱腔走板。”&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;把工资条变成你的理财小帮手

&lt;ul&gt;
&lt;li&gt;第一份增加对身体的投资，让身体始终健康；第二份增加对社交的投资，扩大人脉；第三份用来投资学习，增强你的自信心；第四份用来旅游，扩大你的见闻；第五份用来投资未来，增加你的收益。&lt;/li&gt;
&lt;li&gt;25岁之前的年轻人，刚走上社会，还没有结婚组建家庭的压力，这个时候，最重要的是提升自己，将大部分收入用在教育、培训方面；&lt;/li&gt;
&lt;li&gt;25—30岁的年轻人，大多处于结婚阶段，压力比较大，每个月需要的支出比较多，但一定要将自己的工资主要集中在固定资产方面，房子够首付就马上出手；车的话，如果是像北京这样交通拥堵的城市，用车的时间成本和其他成本（比如天价停车费）相对较高，能不买就不买。特别奉劝那种有类似于“周末和朋友可以有个车出去游玩”这种无效利用率的幼稚想法，或者“咱同学谁谁谁都买车了，咱也买”这种盲目攀比的低级想法的年轻人，还是打消买车念头的比较好。买个车，交通拥堵，只周末开两天，而一周七天都在时刻贬值，除非是个傻子才这样做。还不如把这些钱连同剩余部分，做一个长期存款，既能减少风险，又能保证每个月的支出；&lt;/li&gt;
&lt;li&gt;对于30—35岁的人，收入有所增加，房贷每个月不变，即使有小孩也还小，压力不大，可以将多余的收入投入到股票等风险较大但收益也较大的项目上；&lt;/li&gt;
&lt;li&gt;而35—50岁的人，最大的压力来自子女教育。金钱&lt;/li&gt;
&lt;li&gt;压力比较大，不过一般这个阶段的人收入也处于较高水平，可以考虑债券，能保证基本的收益，也不至于有太大的风险；&lt;/li&gt;
&lt;li&gt;50—60岁阶段的人，一般没有了子女教育的问题，有较多的收入，面临的最大压力来自退休后的生活，这时候可以将收入用来买保险以及国债等安全系数比较高的投资产品；&lt;/li&gt;
&lt;li&gt;对于60岁以上的老年人，收入减少，只剩下退休金，最重要的就是要保证资金的安全性，最好将所有存款放在银行，而对于股票这种高风险的投资就尽量不要碰。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;想要一本万利，那就投资人脉吧

&lt;ul&gt;
&lt;li&gt;朋友关系是需要维护的，我相信，每个人即使精力再旺盛，能够维持的所谓的“铁哥们儿”也超不出10个。而我们把朋友视为一种投资，也需要选择出真正能帮助自己的那几个做长期投资，而不是泛泛地与很多人交往。&lt;/li&gt;
&lt;li&gt;也许，投资朋，能帮你；但是，投资友，他能发现你！&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h2&gt;第三章 事业是理财的基础&lt;/h2&gt;

&lt;p&gt;善待我们的事业不仅是我们赖以生存的基础，更是理财的第一基础。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;工作，也是自我累积的过程

&lt;ul&gt;
&lt;li&gt;其实每个人的工作都是琐碎的，即使那些不用朝九晚五生活的创业者，也必须面对工作中琐碎的小事。不过，正是这些琐碎的小事，让我们学会了很多东西，不断提升着我们的人力资本。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;面子是浮云，底子才是真

&lt;ul&gt;
&lt;li&gt;再小的行当，能干得风生水起也是很不容易的，关键是找准自己的强项。所谓“兴趣是幌子，面子是浮云”，能打好财富的底子，让自己积累财富才是最应该考虑的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;掌握了这些，高薪不是那么难&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;敬业是一种长线理财，可以让你变得不可替代，薪水自然能得到提高。&lt;/li&gt;
&lt;li&gt;掌握技能不仅仅是为了薪水，得到锻炼的机会比薪水更重要，只有在得到机会之后，才能充分发挥自己的才能，才可以让人看到你的优势，从而获得更高的薪水。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;讨价还价的乐趣，让你欲罢不能&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;第一个技巧，基本让步法则。

&lt;ul&gt;
&lt;li&gt;举个例子，你要买一件商品，第一口出的价格是150元，但是对方报的价格是400元，而双方都能接受的价格是300元。那你应该怎么样还价呢？简单的有三种方法：（1）150到200再到250，最后给对方300；（2）150到240再到280，最后给对方300；（3）先出150，然后170，&lt;/li&gt;
&lt;li&gt;再到200，最后是300。方法一是每次都松口50元，直到300元就再不松口了，这只会让对方觉得你还能再松口50元，他是不会同意的。最蠢的是方法三，它只会让对方期待我们更大的让步。正确的是方法二，要先松后紧，这样才能让对方感觉到我们给出的价格是逐步接近底线的，每一次让步都让对方觉得我们损失惨重。另外，在让步时也要把握节奏，让的次数要尽量少，保持两三次让步就行，让步的速度要慢，理由就是：如果让步的次数过多，让得过快，就会让对方觉得我们的心理价位还有余地。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;第二个技巧，学会角色扮演。

&lt;ul&gt;
&lt;li&gt;在商务谈判中，有一套非常复杂的角色系统：比如谁扮演黑脸，不给对方好态度，坚持自己这方的观点；谁扮演白脸，适时地强调，保持良好关系。再大一点的谈判还要有强硬派、清道夫等各种角色。当然，对大多数人来说，讨价还价虽然是一种谈判，但通常“我方”只有你一个人。这时候，这个人就要学会角色间的转换，该赔笑脸的时候，就要有一些脸部肌肉的活动；该发怒的时候，也得让对方感到震慑力。但是千万要注意，不要带任何个人色彩地进行讨价还价，你的笑脸和怒容只是为了能更省钱地买到东西，不要到最后自己真的开始发怒了。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;第三个技巧，学一点“推拿”。

&lt;ul&gt;
&lt;li&gt;为了坚持自己的立场，有时候必须要虚拟出一个“上司”。比如，讨价还价进入到了一个僵局，你可以跟对方说，你这个价格我能接受，但是我要是跟我爱人说是用这个价格买到的，她会发怒的。然后，你可以装腔作势地给爱人打个电话，回来告诉对方，这个价格没法接受。把问题推给更多的人，让对方无从下手，有时候也是讨价还价中惯用的一招。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;第四个技巧，学会“配套”。

&lt;ul&gt;
&lt;li&gt;“配套”，就是把很多东西一起捆绑起来，比如6元钱一个勺子，对方不肯卖，你就答应他出7元钱买下这个勺子，不过要搭上一个只卖1元钱的小碗。配套的原则说起来就是：绝对不作没有条件的让步。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h2&gt;第五章 房子的“钱世”与“金生”&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;租房或者买房，先看看自己处于人生哪个阶段

&lt;ul&gt;
&lt;li&gt;第一个误区，等到房价降到最低时再买。&lt;/li&gt;
&lt;li&gt;第二个误区是“无房不成家”。&lt;/li&gt;
&lt;li&gt;第三个误区，尽量压低购房开支，最好车房一起到位。&lt;/li&gt;
&lt;li&gt;第四个误区，有人觉得租房是纯支出，甚至是给房东&lt;/li&gt;
&lt;li&gt;还贷款，最终自己一无所有。

&lt;ul&gt;
&lt;li&gt;对于那些刚工作没多久，想要结婚的“刚需”买房者，如果现在有一部分的首付，那就要毫不犹豫地购置第一套房产，不过前提是要保证自己的收入能满足月供的要求。这时，购房者可以选择“以收入定面积”的方法来决定购买什么样的房产。具体可以这么办：先选定想要购房的区域，确定下来自己要买单价多少的房子。然后再确定下来自己能承担的月均还款额，一般以不超过三分之一为宜。在已经知道月均还款额和首付的情况下，可以很容易倒推计算出能贷款的额度。将贷款总额和首付加起来就是自己能买的房产的最高价格了。这时，就完全可以确定出房子的面积。按这个方法，就能到市场上“按图索骥”，找到自己想要买的房子了。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;你是买婚房，不是买“昏房”

&lt;ul&gt;
&lt;li&gt;第一，切忌过于精挑细算。&lt;/li&gt;
&lt;li&gt;第二，要根据经济状况进行选购。&lt;/li&gt;
&lt;li&gt;第三，要考虑到交通状况。&lt;/li&gt;
&lt;li&gt;第四，切忌过于看重附赠价值，而忽略房子本身。&lt;/li&gt;
&lt;li&gt;第五，考虑治安状况。&lt;/li&gt;
&lt;li&gt;第六，要考虑到以后的变化。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h2&gt;第六章 做个计划“生余族”&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;投资的几大靠谱理念

&lt;ul&gt;
&lt;li&gt;一、储蓄和投资同时进行&lt;/li&gt;
&lt;li&gt;二、负债投资也是财富&lt;/li&gt;
&lt;li&gt;三、时刻遵循价值投资，策略理财&lt;/li&gt;
&lt;li&gt;四、赚钱、赚钱，千万不能赔钱&lt;/li&gt;
&lt;li&gt;五、把鸡蛋放在多个篮子里&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;别拿误区当知识

&lt;ul&gt;
&lt;li&gt;价格越低就会觉得越好，这是一个最大的投资理财误区。&lt;/li&gt;
&lt;li&gt;投资者经常面临的第二个误区比较尴尬，那就是勇于输钱却不敢赚钱。这是在无形中发生的，而投资者往往对此一无所知。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;鸡蛋放在不同的篮子里

&lt;ul&gt;
&lt;li&gt;第一，“现金流”控制得当，避险准备到位。&lt;/li&gt;
&lt;li&gt;第二，老黄把钱投入到多个市场，利用不同市场的不同周期和特点，及时调整投资策略。&lt;/li&gt;
&lt;li&gt;第三，老黄在把所有资产放到不同的市场上时，可以做到“高不赌、低不慌”。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;“投机”和“偷鸡”差不多

&lt;ul&gt;
&lt;li&gt;千万不可以借钱进行投资。这是我们投资股票、基金、期货的最低限度。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;保险，投资的是未来的“万一”

&lt;ul&gt;
&lt;li&gt;27—35岁，由于面临着结婚、买房、生育、抚育子女的责任，家庭支出比较大，同时对于年轻父母来说这时候的责任也比较重大，所以可以选择稍低的保费支出，将万能险账户中的保障部分最大化，减少投资部分。&lt;/li&gt;
&lt;li&gt;35—48岁，孩子处于中小学阶段，支出较低且平稳，而父母此时的事业处于上升期，收入逐渐增加，经济状况转好，保费支出可以增加，以此来增加保单的价值。&lt;/li&gt;
&lt;li&gt;48—52岁，孩子上大学，正是缺钱的时候，家庭支出增加，可以减少保费及保障支出。&lt;/li&gt;
&lt;li&gt;52—60岁，孩子大学毕业，有了自己的工作，经济上不再需要父母的支持。这时，两人的事业进入收获期，往往收入也能有所提高，可以考虑增加保费，积累保单的价值，为养老作好准备。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;

</content>
 </entry>
 
 <entry>
   <title>init 功能与运行分析</title>
   <link href="http://www.5wpc.info/it/technical/os/android/init/2014/11/21/FirstProcessInit"/>
   <updated>2014-11-21T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/technical/os/android/init/2014/11/21/FirstProcessInit</id>
   <content type="html">&lt;h1&gt;Init 的主要作用&lt;/h1&gt;

&lt;p&gt;本程序是Linux完成内核加载后的第一个进程, 主要进行linux
级首个上下文的设置(linux属性体系), 基础服务的启动与状态
管理(重新启动, 状态监视), 系统属性变化后的状态重置.&lt;/p&gt;

&lt;h2&gt;涉及的框架&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;selinux

&lt;ul&gt;
&lt;li&gt;针对所有的安全隐患API进行备案与调用审计&lt;/li&gt;
&lt;li&gt;只有特定应用在特定权限下, 才能运行特定API&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;业务数据存储的整体结构

&lt;ul&gt;
&lt;li&gt;属性数据存储: 基本的文本文件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;提供的业务流程

&lt;ul&gt;
&lt;li&gt;运行结构&lt;/li&gt;
&lt;li&gt;支持的命令&lt;/li&gt;
&lt;li&gt;Service的状态维护&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;权限管理

&lt;ul&gt;
&lt;li&gt;socket 与 ctl&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;业务通信

&lt;ul&gt;
&lt;li&gt;linux下的通信机制: socket&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;rc文件的分析与处理流程

&lt;ul&gt;
&lt;li&gt;专用的文法与解析程序&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;主要业务流程&lt;/h1&gt;

&lt;h2&gt;Init启动的前置条件&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;设备上电启动&lt;/li&gt;
&lt;li&gt;uboot完成第一步引导并进行初始化(boot.img)

&lt;ol&gt;
&lt;li&gt;加载Ramdisk到内存(完成根文件系统的设置)&lt;/li&gt;
&lt;li&gt;加载内核到内存(kernel)&lt;/li&gt;
&lt;li&gt;引导到内核&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;内核完成硬件初始化工作与系统核心数据的初始化工作&lt;/li&gt;
&lt;li&gt;内核完成工作后, 启动init程序&lt;/li&gt;
&lt;/ol&gt;


&lt;h2&gt;Init主要业务&lt;/h2&gt;

&lt;h3&gt;下述为非charger状态&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;创建Android需要的根文件系统相关节点&lt;/li&gt;
&lt;li&gt;init状态初始化

&lt;ol&gt;
&lt;li&gt;klog&lt;/li&gt;
&lt;li&gt;property&lt;/li&gt;
&lt;li&gt;内核启动过程相关状态保护

&lt;ol&gt;
&lt;li&gt;获取hardware名称&lt;/li&gt;
&lt;li&gt;设置基础系统相关的属性

&lt;ol&gt;
&lt;li&gt;ro.serialno&lt;/li&gt;
&lt;li&gt;ro.bootmode&lt;/li&gt;
&lt;li&gt;ro.baseband&lt;/li&gt;
&lt;li&gt;ro.bootloader&lt;/li&gt;
&lt;li&gt;ro.hardware&lt;/li&gt;
&lt;li&gt;ro.revision&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;selinux&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;(!charger)基本属性加载: PROP_PATH_RAMDISK_DEFAULT = /default.prop&lt;/li&gt;
&lt;li&gt;加载Config

&lt;ol&gt;
&lt;li&gt;以init.rc为入口, 分析init内部指令&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Action 顺序加载(统一存放在action_queue)(O: 一个前置条件下的一组指令on xxx, A:具体的一个Action)

&lt;ol&gt;
&lt;li&gt;O:early-init&lt;/li&gt;
&lt;li&gt;A:wait_for_coldboot_done&lt;/li&gt;
&lt;li&gt;A:mix_hwrng_into_linux_rng&lt;/li&gt;
&lt;li&gt;A:keychord_init&lt;/li&gt;
&lt;li&gt;A:console_init&lt;/li&gt;
&lt;li&gt;O:init&lt;/li&gt;
&lt;li&gt;!charger:

&lt;ol&gt;
&lt;li&gt;O:early-fs&lt;/li&gt;
&lt;li&gt;O:fs&lt;/li&gt;
&lt;li&gt;O:post-fs&lt;/li&gt;
&lt;li&gt;O:post-fs-data&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;A:mix_hwrng_into_linux_rng&lt;/li&gt;
&lt;li&gt;&lt;p&gt;A:property_service_init&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;加载属性数据&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;`c&quot;&gt; #define PROP_PATH_RAMDISK_DEFAULT  &quot;/default.prop&quot;
 #define PROP_PATH_SYSTEM_BUILD     &quot;/system/build.prop&quot;
 #define PROP_PATH_SYSTEM_DEFAULT   &quot;/system/default.prop&quot;
 #define PROP_PATH_LOCAL_OVERRIDE   &quot;/data/local.prop&quot;
 #define PROP_PATH_FACTORY          &quot;/factory/factory.prop&quot;
 load_properties_from_file(PROP_PATH_SYSTEM_BUILD);     // /system/build.prop
 load_properties_from_file(PROP_PATH_SYSTEM_DEFAULT);   // /system/default.prop
 load_override_properties(); //PROP_PATH_LOCAL_OVERRIDE // /data/local.prop
 load_persistent_properties();                          // /data/property/*
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt; A:signal_init&lt;/p&gt;&lt;/li&gt;
&lt;li&gt; A:check_startup&lt;/li&gt;
&lt;li&gt; !charger:

&lt;ol&gt;
&lt;li&gt;O:early-boot&lt;/li&gt;
&lt;li&gt;O:boot&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt; A:queue_property_triggers (properies条件触发的相关Action)&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h2&gt;Init 程序的内部数据组织结构&lt;/h2&gt;

&lt;h3&gt;数据要求&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;//bionic/libc/include/sys/system_properties.h
//Property key max length = 32 - 1(\0) = 31
#define PROP_NAME_MAX   32
//Property value max length = 92 - 1(\0) = 91
#define PROP_VALUE_MAX  92
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;整体关系&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;
action ---1---N---&amp;gt; commands

service_list
    |
    `---+---&amp;gt; service1 ---&amp;gt; onrestart-action
        |(linked list: slist )
        +---&amp;gt; service2
        :
        :
        :


action_list
    |
    `---+---&amp;gt; action1
        |(linked list: alist )
        +---&amp;gt; action2
        :
        :
        :

action_queue
    |
    `---+---&amp;gt; action1
        |(linked list: qlist )
        +---&amp;gt; action2
        :
        :
        :

import_list
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;加载顺序&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;一个文件加载完成后, 再次循环加载import 的文件(统一存储在service_list,action_list)

&lt;ul&gt;
&lt;li&gt;共用&lt;code&gt;service_list, action_list&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;按顺序组织相关action

&lt;ul&gt;
&lt;li&gt;存储在&lt;code&gt;action_queue&lt;/code&gt;中&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h2&gt;属性服务的结构&lt;/h2&gt;

&lt;h3&gt;init自身启动时设置有效区间&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;property: name=value&lt;/li&gt;
&lt;li&gt;如果不存在则直接添加(add(name,value))&lt;/li&gt;
&lt;li&gt;如果存在

&lt;ul&gt;
&lt;li&gt;ro.xxx.xx 不允许修改(return -1)&lt;/li&gt;
&lt;li&gt;其它则直接Update(update(name,value))&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;net.xxx == name

&lt;ul&gt;
&lt;li&gt;update(&#39;net.change&#39;,name)(name!=&#39;net.change&#39;)&lt;/li&gt;
&lt;li&gt;return 0 (name==&#39;net.change&#39;)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;persist.xxx == name

&lt;ul&gt;
&lt;li&gt;save value to persistent_data_area&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;触发 property 改变时的action进行调用&lt;/li&gt;
&lt;/ol&gt;


&lt;h3&gt;通过系统接口进行property设置&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;通过socket的通道进行通信&lt;/li&gt;
&lt;li&gt;针对ctl等控制类的数据,会检查完权限后, 进行服务的start/stop/restart 操作&lt;/li&gt;
&lt;li&gt;针对其它property, 会有一个列表, 检查是否有权限进行设置&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;Android系统级对于property的设置&lt;/h3&gt;

&lt;p&gt;与系统流程相关的主要property:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Android系统启动完成后,通知系统

&lt;ul&gt;
&lt;li&gt;sys.boot_completed=1&lt;/li&gt;
&lt;li&gt;dev.bootcomplete=1&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;系统重启与关机

&lt;ul&gt;
&lt;li&gt;ro.runtime.firstboot=time&lt;/li&gt;
&lt;li&gt;ShutdownThread.REBOOT_SAFEMODE_PROPERTY&lt;/li&gt;
&lt;li&gt;sys.powerctl=shutdown/reboot,reason&lt;/li&gt;
&lt;li&gt;SHUTDOWN_ACTION_PROPERTY=reason&lt;/li&gt;
&lt;li&gt;REBOOT_SAFEMODE_PROPERTY&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;系统环境

&lt;ul&gt;
&lt;li&gt;user.language&lt;/li&gt;
&lt;li&gt;user.region&lt;/li&gt;
&lt;li&gt;persist.sys.language&lt;/li&gt;
&lt;li&gt;persist.sys.country&lt;/li&gt;
&lt;li&gt;persist.sys.localevar&lt;/li&gt;
&lt;li&gt;persist.sys.dalvik.vm.lib&lt;/li&gt;
&lt;li&gt;selinux.reload_policy&lt;/li&gt;
&lt;li&gt;persist.selinux.enforcing&lt;/li&gt;
&lt;li&gt;TIMEZONE_PROPERTY&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;系统调试与开发

&lt;ul&gt;
&lt;li&gt;ctl.start bugreport&lt;/li&gt;
&lt;li&gt;StrictMode.VISUAL_PROPERTY&lt;/li&gt;
&lt;li&gt;persist.sys.profiler_ms&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;系统设备

&lt;ul&gt;
&lt;li&gt;SYSTEM_PROP_DISABLE_CAMERA&lt;/li&gt;
&lt;li&gt;USB&lt;/li&gt;
&lt;li&gt;网络

&lt;ul&gt;
&lt;li&gt;net.hostname&lt;/li&gt;
&lt;li&gt;net.dns&lt;/li&gt;
&lt;li&gt;PROP_QTAGUID_ENABLED : 用于内核级网络流量统计&lt;/li&gt;
&lt;li&gt;GSM&lt;/li&gt;
&lt;li&gt;UICC&lt;/li&gt;
&lt;li&gt;SIM CARD&lt;/li&gt;
&lt;li&gt;net.ppp.reset-by-timeout&lt;/li&gt;
&lt;li&gt;CDMA&lt;/li&gt;
&lt;li&gt;SMS&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Android 中的属性服务调用位置:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;./base/cmds/am/src/com/android/commands/am/Am.java:            SystemProperties.set(&quot;dalvik.vm.extra-opts&quot;, props);
./base/services/java/com/android/server/DevicePolicyManagerService.java:                SystemProperties.set(SYSTEM_PROP_DISABLE_CAMERA, value);
./base/services/java/com/android/server/am/ProcessList.java:            SystemProperties.set(&quot;sys.sysctl.extra_free_kbytes&quot;, Integer.toString(reserve));
./base/services/java/com/android/server/am/ActivityManagerService.java:                SystemProperties.set(&quot;sys.boot_completed&quot;, &quot;1&quot;);
./base/services/java/com/android/server/am/ActivityManagerService.java:                SystemProperties.set(&quot;dev.bootcomplete&quot;, &quot;1&quot;);
./base/services/java/com/android/server/am/ActivityManagerService.java:        SystemProperties.set(&quot;ctl.start&quot;, &quot;bugreport&quot;);
./base/services/java/com/android/server/am/ActivityManagerService.java:        SystemProperties.set(Settings.Global.DEVELOPMENT_FORCE_RTL, forceRtl ? &quot;1&quot;:&quot;0&quot;);
./base/services/java/com/android/server/am/ActivityManagerService.java:            SystemProperties.set(&quot;user.language&quot;, l.getLanguage());
./base/services/java/com/android/server/am/ActivityManagerService.java:            SystemProperties.set(&quot;user.region&quot;, l.getCountry());
./base/services/java/com/android/server/am/ActivityManagerService.java:            SystemProperties.set(&quot;persist.sys.language&quot;, l.getLanguage());
./base/services/java/com/android/server/am/ActivityManagerService.java:            SystemProperties.set(&quot;persist.sys.country&quot;, l.getCountry());
./base/services/java/com/android/server/am/ActivityManagerService.java:            SystemProperties.set(&quot;persist.sys.localevar&quot;, l.getVariant());
./base/services/java/com/android/server/wm/WindowManagerService.java:        SystemProperties.set(StrictMode.VISUAL_PROPERTY, value);
./base/services/java/com/android/server/wm/WindowManagerService.java:                SystemProperties.set(ShutdownThread.REBOOT_SAFEMODE_PROPERTY, &quot;&quot;);
./base/services/java/com/android/server/BootReceiver.java:            SystemProperties.set(&quot;ro.runtime.firstboot&quot;, now);
./base/services/java/com/android/server/usb/UsbDeviceManager.java:                    SystemProperties.set(&quot;sys.usb.config&quot;, mDefaultFunctions);
./base/services/java/com/android/server/usb/UsbDeviceManager.java:                    SystemProperties.set(&quot;persist.service.adb.enable&quot;, &quot;&quot;);
./base/services/java/com/android/server/usb/UsbDeviceManager.java:            SystemProperties.set(&quot;sys.usb.config&quot;, config);
./base/services/java/com/android/server/usb/UsbDeviceManager.java:                    SystemProperties.set(&quot;persist.sys.usb.config&quot;, functions);
./base/services/java/com/android/server/usb/UsbDeviceManager.java:                        SystemProperties.set(&quot;persist.sys.usb.config&quot;, mDefaultFunctions);
./base/services/java/com/android/server/SystemServer.java:        SystemProperties.set(&quot;persist.sys.dalvik.vm.lib&quot;,
./base/services/java/com/android/server/power/PowerManagerService.java:        SystemProperties.set(&quot;sys.powerctl&quot;, &quot;shutdown&quot;);
./base/services/java/com/android/server/power/PowerManagerService.java:        SystemProperties.set(&quot;sys.powerctl&quot;, &quot;reboot,&quot; + reason);
./base/services/java/com/android/server/power/ShutdownThread.java:            SystemProperties.set(SHUTDOWN_ACTION_PROPERTY, reason);
./base/services/java/com/android/server/power/ShutdownThread.java:            SystemProperties.set(REBOOT_SAFEMODE_PROPERTY, &quot;1&quot;);
./base/services/java/com/android/server/ConnectivityService.java:                SystemProperties.set(&quot;net.hostname&quot;, name);
./base/services/java/com/android/server/ConnectivityService.java:                SystemProperties.set(key, value); //net.dns
./base/services/java/com/android/server/ConnectivityService.java:                SystemProperties.set(key, &quot;&quot;);    //net.dns
./base/services/java/com/android/server/NetworkManagementService.java:        SystemProperties.set(PROP_QTAGUID_ENABLED, mBandwidthControlEnabled ? &quot;1&quot; : &quot;0&quot;);
./base/services/java/com/android/server/SamplingProfilerService.java:            SystemProperties.set(&quot;persist.sys.profiler_ms&quot;, samplingProfilerMs.toString());
./base/services/java/com/android/server/updates/SELinuxPolicyInstallReceiver.java:        SystemProperties.set(&quot;selinux.reload_policy&quot;, &quot;1&quot;);
./base/services/java/com/android/server/updates/SELinuxPolicyInstallReceiver.java:            SystemProperties.set(&quot;persist.selinux.enforcing&quot;, mode);
./base/services/java/com/android/server/AlarmManagerService.java:                    SystemProperties.set(TIMEZONE_PROPERTY, zone.getID());
./opt/telephony/src/java/com/android/internal/telephony/gsm/GSMPhone.java:        SystemProperties.set(TelephonyProperties.CURRENT_ACTIVE_PHONE,
./opt/telephony/src/java/com/android/internal/telephony/gsm/GsmServiceStateTracker.java:                SystemProperties.set(&quot;gsm.nitz.time&quot;, String.valueOf(c.getTimeInMillis()));
./opt/telephony/src/java/com/android/internal/telephony/uicc/RuimRecords.java:            SystemProperties.set(PROPERTY_ICC_OPERATOR_ALPHA, mSpn);
./opt/telephony/src/java/com/android/internal/telephony/uicc/RuimRecords.java:            SystemProperties.set(PROPERTY_ICC_OPERATOR_NUMERIC, operator);
./opt/telephony/src/java/com/android/internal/telephony/uicc/RuimRecords.java:            SystemProperties.set(PROPERTY_ICC_OPERATOR_ISO_COUNTRY,
./opt/telephony/src/java/com/android/internal/telephony/uicc/SIMRecords.java:        SystemProperties.set(PROPERTY_ICC_OPERATOR_NUMERIC, null);
./opt/telephony/src/java/com/android/internal/telephony/uicc/SIMRecords.java:        SystemProperties.set(PROPERTY_ICC_OPERATOR_ALPHA, null);
./opt/telephony/src/java/com/android/internal/telephony/uicc/SIMRecords.java:        SystemProperties.set(PROPERTY_ICC_OPERATOR_ISO_COUNTRY, null);
./opt/telephony/src/java/com/android/internal/telephony/uicc/SIMRecords.java:            SystemProperties.set(PROPERTY_ICC_OPERATOR_NUMERIC, operator);
./opt/telephony/src/java/com/android/internal/telephony/uicc/SIMRecords.java:            SystemProperties.set(PROPERTY_ICC_OPERATOR_ISO_COUNTRY,
./opt/telephony/src/java/com/android/internal/telephony/uicc/SIMRecords.java:                    SystemProperties.set(PROPERTY_ICC_OPERATOR_ALPHA, mSpn);
./opt/telephony/src/java/com/android/internal/telephony/uicc/SIMRecords.java:                    SystemProperties.set(PROPERTY_ICC_OPERATOR_ALPHA, mSpn);
./opt/telephony/src/java/com/android/internal/telephony/uicc/SIMRecords.java:                    SystemProperties.set(PROPERTY_ICC_OPERATOR_ALPHA, mSpn);
./opt/telephony/src/java/com/android/internal/telephony/uicc/IccCardProxy.java:            SystemProperties.set(PROPERTY_SIM_STATE, mExternalState.toString());
./opt/telephony/src/java/com/android/internal/telephony/dataconnection/DcTracker.java:        SystemProperties.set(&quot;net.ppp.reset-by-timeout&quot;, String.valueOf(reset+1));
./opt/telephony/src/java/com/android/internal/telephony/dataconnection/DcTracker.java:                    SystemProperties.set(PUPPET_MASTER_RADIO_STRESS_TEST, &quot;true&quot;);
./opt/telephony/src/java/com/android/internal/telephony/dataconnection/DcTracker.java:                    SystemProperties.set(PUPPET_MASTER_RADIO_STRESS_TEST, &quot;false&quot;);
./opt/telephony/src/java/com/android/internal/telephony/dataconnection/DcTracker.java:            SystemProperties.set(PUPPET_MASTER_RADIO_STRESS_TEST, &quot;false&quot;);
./opt/telephony/src/java/com/android/internal/telephony/dataconnection/DcTrackerBase.java:                SystemProperties.set(RADIO_RESET_PROPERTY, &quot;true&quot;);
./opt/telephony/src/java/com/android/internal/telephony/cdma/SmsMessage.java:        SystemProperties.set(TelephonyProperties.PROPERTY_CDMA_MSG_ID, nextMsgId);
./opt/telephony/src/java/com/android/internal/telephony/cdma/CDMAPhone.java:        SystemProperties.set(TelephonyProperties.CURRENT_ACTIVE_PHONE,
./opt/telephony/src/java/com/android/internal/telephony/cdma/CdmaServiceStateTracker.java:                SystemProperties.set(&quot;gsm.nitz.time&quot;, String.valueOf(c.getTimeInMillis()));
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>学车</title>
   <link href="http://www.5wpc.info/it/project/car/2014/11/08/StudyCar"/>
   <updated>2014-11-08T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/project/car/2014/11/08/StudyCar</id>
   <content type="html">&lt;h1&gt;学车&lt;/h1&gt;

&lt;h2&gt;报名&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;准备材料

&lt;ul&gt;
&lt;li&gt;暂住证

&lt;ul&gt;
&lt;li&gt;杭州办理方法

&lt;ul&gt;
&lt;li&gt;暂住协议原件复印件，身份证原件复印件，1寸照片2张&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;身份证&lt;/li&gt;
&lt;li&gt;复印 正反面 1份&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;通过指定驾校预约报名&lt;/li&gt;
&lt;li&gt;报名当天

&lt;ul&gt;
&lt;li&gt;驾校集合，排队出表2张，申请表与体检表&lt;/li&gt;
&lt;li&gt;向管理机构(交管部门)

&lt;ul&gt;
&lt;li&gt;交体检费30元

&lt;ul&gt;
&lt;li&gt;排队体检&lt;/li&gt;
&lt;li&gt;医生鉴定结果&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;1000元

&lt;ul&gt;
&lt;li&gt;排队申请档案&lt;/li&gt;
&lt;li&gt;排队报名领取教材光盘&lt;/li&gt;
&lt;li&gt;排队交费&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;预约理论学习&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;理论学习与考试&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;理论学习完成后&lt;/li&gt;
&lt;li&gt;找时间进行理论结业考试

&lt;ul&gt;
&lt;li&gt;河坊街33号，排队进入考场，需要检查身份证，合格后会收理论课上课卡&lt;/li&gt;
&lt;li&gt;建议学习与使用 驾考宝典，先将顺序练习做会做完，再看书第一部分，再做模拟题。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;理论结业考试通过后

&lt;ul&gt;
&lt;li&gt;预约科目1考试&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;场内准备&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;科目2&lt;/li&gt;
&lt;li&gt;预约模拟1&lt;/li&gt;
&lt;li&gt;场地练习

&lt;ul&gt;
&lt;li&gt;20141108上午09:00-14:00

&lt;ul&gt;
&lt;li&gt;模拟方向盘练习

&lt;ul&gt;
&lt;li&gt;半圈&lt;/li&gt;
&lt;li&gt;1圈&lt;/li&gt;
&lt;li&gt;1圈半&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;前进与后退练习

&lt;ul&gt;
&lt;li&gt;熟悉离合器与刹车&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;绕圈练习

&lt;ul&gt;
&lt;li&gt;配合方向盘&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;主要步骤&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;经验 http://baike.baidu.com/link?url=5UMaiRqhJck3KxuPKa0gx_F90dJYNpn5No88zIgBP1K-0ixKBDP8FRBTLR_sSQLdBYTDRAKF0KxLuVor2nQeL_&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>Android AOSP ROM开发</title>
   <link href="http://www.5wpc.info/it/technical/os/android/2014/10/31/AOSP"/>
   <updated>2014-10-31T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/technical/os/android/2014/10/31/AOSP</id>
   <content type="html">&lt;h1&gt;Maguro Android 4.2.2&lt;/h1&gt;

&lt;h2&gt;download&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;mkdir aosp
cd aosp
repo init -u http://sssss -b android-4.2.2_r1.2
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;非AOSP部分代码合入&lt;/h3&gt;

&lt;p&gt;请根据版本与设备型号从&lt;a href=&quot;https://developers.google.com/android/nexus/drivers#magurojdq39&quot;&gt;google官方&lt;/a&gt;下载补丁.&lt;/p&gt;

&lt;p&gt;如果没有合入这部分补丁, 就会导致系统无法启动等问题,
这是由于AOSP中没有包含一些非开源的代码部分.&lt;/p&gt;

&lt;p&gt;例如maguro版本中, 就会出现如下问题:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;*** *** *** *** *** *** *** *** *** *** *** *** *** *** *** ***
Build fingerprint: &#39;unknown&#39;
Revision: &#39;9&#39;
pid: 1210, tid: 1212, name: SurfaceFlinger  &amp;gt;&amp;gt;&amp;gt; /system/bin/surfaceflinger &amp;lt;&amp;lt;&amp;lt;
signal 11 (SIGSEGV), code 1 (SEGV_MAPERR), fault addr deadbaad
    r0 00000027  r1 deadbaad  r2 40177258  r3 00000000
    r4 00000000  r5 40536d04  r6 00000000  r7 40ec09b0
    r8 00000002  r9 00003038  sl 00003142  fp 00003038
    ip 400d4ff4  sp 40536d00  lr 4014a0d9  pc 40146772  cpsr 60000030
    d0  5f4441425f4c4744  d1  646f697265702049
    d2  2064616f6c206f53  d3  62697461706d6f50
    d4  000000020000009e  d5  000000020000000d
    d6  0000000000000001  d7  426c8f5c00000000
    d8  0000000000000000  d9  0000000000000000
    d10 0000000000000000  d11 0000000000000000
    d12 0000000000000000  d13 0000000000000000
    d14 0000000000000000  d15 0000000000000000
    d16 4170202e598a1e04  d17 41cdcd6500000000
    d18 3d9262fffe000000  d19 3fe0000000000000
    d20 3fe0000000009318  d21 0000000000000000
    d22 0000000000000000  d23 0000000000000000
    d24 0000000000000000  d25 0000000000000000
    d26 0000000000000000  d27 0000000000000000
    d28 0000000000000000  d29 0000000000000000
    d30 0000000000000000  d31 0000000000000000
    scr 20000010

backtrace:
    #00  pc 0001a772  /system/lib/libc.so
    #01  pc 00018070  /system/lib/libc.so (abort+4)
    #02  pc 000008f1  /system/lib/libstdc++.so (operator new(unsigned int)+8)
    #03  pc 0002474d  /system/lib/libsurfaceflinger.so (android::SurfaceFlinger::selectConfigForAttribute(void*, int const*, int, int, void**)+38)
    #04  pc 000248a7  /system/lib/libsurfaceflinger.so (android::SurfaceFlinger::selectEGLConfig(void*, int)+162)
    #05  pc 00028819  /system/lib/libsurfaceflinger.so (android::SurfaceFlinger::readyToRun()+92)
    #06  pc 0001123d  /system/lib/libutils.so (android::Thread::_threadLoop(void*)+72)
    #07  pc 00010dcd  /system/lib/libutils.so
    #08  pc 0000e3d8  /system/lib/libc.so (__thread_entry+72)
    #09  pc 0000dac4  /system/lib/libc.so (pthread_create+160)

stack:
         40536cc0  c0000000  
         40536cc4  00000050  
         40536cc8  00000000  
         40536ccc  00000000  
         40536cd0  0000005b  
         40536cd4  34d8dbbd  
         40536cd8  40174254  /system/lib/libc.so
         40536cdc  401741b4  /system/lib/libc.so
         40536ce0  00000000  
         40536ce4  4014a0d9  /system/lib/libc.so (_fwalk+32)
         40536ce8  00000001  
         40536cec  40536d04  
         40536cf0  00000000  
         40536cf4  40ec09b0  [heap]
         40536cf8  df0027ad  
         40536cfc  00000000  
    #00  40536d00  00000000  
         40536d04  fffffbdf  
         40536d08  00000000  
         40536d0c  00000000  
         40536d10  40ec09b0  [heap]
         40536d14  00000002  
         40536d18  00003038  
         40536d1c  40536dc4  
         40536d20  00000000  
         40536d24  40144074  /system/lib/libc.so (__pthread_clone)
    #01  40536d28  00000000  
         40536d2c  400d38f5  /system/lib/libstdc++.so (operator new(unsigned int)+12)
    #02  40536d30  00000000  
         40536d34  4011b751  /system/lib/libsurfaceflinger.so (android::SurfaceFlinger::selectConfigForAttribute(void*, int const*, int, int, void**)+42)
    #03  40536d38  40536d68  
         40536d3c  40536dc4  
         40536d40  00000000  
         40536d44  ffffffff  
         40536d48  00000000  
         40536d4c  401ca41f  /system/lib/libutils.so (android::SortedVectorImpl::add(void const*)+30)
         40536d50  40536dc4  
         40536d54  40536dc4  
         40536d58  00003038  
         40536d5c  00000000  
         40536d60  40536d84  
         40536d64  00000002  
         40536d68  00003147  
         40536d6c  00003142  
         40536d70  00003024  
         40536d74  4011b8ab  /system/lib/libsurfaceflinger.so (android::SurfaceFlinger::selectEGLConfig(void*, int)+166)
    #04  40536d78  40536d84  
         40536d7c  00000000  
         40536d80  c0000030  
         40536d84  00000008  
         40536d88  00000000  
         40536d8c  40536dc4  
         40536d90  00003033  
         40536d94  40536dc4  
         40536d98  00003142  
         40536d9c  40536dc4  
         40536da0  00003147  
         40536da4  40536dc4  
         40536da8  00003024  
         40536dac  40536dc4  
         40536db0  00003023  
         40536db4  40536dc4  
         ........  ........
    #05  40536e00  40039480  /dev/__properties__ (deleted)
         40536e04  00000017  
         40536e08  0000000d  
         40536e0c  40159119  /system/lib/libc.so (__system_property_find+56)
         40536e10  40ec0318  [heap]
         40536e14  40536e50  
         40536e18  40536e50  
         40536e1c  401ce834  /system/lib/libutils.so
         40536e20  fffffff8  
         40536e24  401c8d35  /system/lib/libutils.so
         40536e28  00100000  
         40536e2c  40159179  /system/lib/libc.so (__system_property_get+8)
         40536e30  40536e50  
         40536e34  4019e455  /system/lib/libcutils.so (property_get+36)
         40536e38  40177228  
         40536e3c  401c8c05  /system/lib/libutils.so
         ........  ........
    #06  40536ea0  40ec032c  [heap]
         40536ea4  4013d813  /system/lib/libc.so (dlfree+34)
         40536ea8  40ec032c  [heap]
         40536eac  40ec0530  [heap]
         40536eb0  40ec032c  [heap]
         40536eb4  40ec0618  [heap]
         40536eb8  401c91f5  /system/lib/libutils.so (android::Thread::_threadLoop(void*))
         40536ebc  40ec032c  [heap]
         40536ec0  00000000  
         40536ec4  401c8dcf  /system/lib/libutils.so
    #07  40536ec8  00000000  
         40536ecc  40ec0630  [heap]
         40536ed0  40536ffc  
         40536ed4  40536f00  
         40536ed8  40ec0630  [heap]
         40536edc  401c8d35  /system/lib/libutils.so
         40536ee0  40ec0600  [heap]
         40536ee4  4013a3dc  /system/lib/libc.so (__thread_entry+76)
    #08  40536ee8  40ec0600  [heap]
         40536eec  40536f00  
         40536ef0  be836ae0  [stack]
         40536ef4  40ec0630  [heap]
         40536ef8  00000078  
         40536efc  40139ac8  /system/lib/libc.so (pthread_create+164)
    #09  40536f00  40536f00  
         40536f04  40ec0630  [heap]
         40536f08  0000000c  
         40536f0c  00000000  
         40536f10  00000000  
         40536f14  00000000  
         40536f18  00000000  
         40536f1c  40ec0610  [heap]
         40536f20  00000000  
         40536f24  00000000  
         40536f28  00000000  
         40536f2c  00000000  
         40536f30  00000000  
         40536f34  00000000  
         40536f38  00000000  
         40536f3c  00000000  

memory near r2:
    40177238 00000000 00000000 00000000 00000000  
    40177248 00000000 00000000 00000000 00000000  
    40177258 00000001 00000000 00000000 00000000  
    40177268 00000000 00000000 00000000 00000000  
    40177278 00000000 00000000 00000000 00000000  
    40177288 00000000 00000000 00000000 00000000  
    40177298 00000000 00000000 08f4742a 00000000  
    401772a8 00000000 00000000 00000000 00000000  
    401772b8 00000000 00000000 00000000 00000000  
    401772c8 00000000 00000000 00000000 00000000  
    401772d8 00000000 00000000 00000000 00000000  
    401772e8 00000000 00000000 00000000 00000000  
    401772f8 00000000 00000000 00000000 00004000  
    40177308 00000000 00000000 00000000 00004000  
    40177318 00000000 00000000 00000000 00004000  
    40177328 00000000 00000000 00000000 00004000  

memory near r5:
    40536ce4 4014a0d9 00000001 40536d04 00000000  
    40536cf4 40ec09b0 df0027ad 00000000 00000000  
    40536d04 fffffbdf 00000000 00000000 40ec09b0  
    40536d14 00000002 00003038 40536dc4 00000000  
    40536d24 40144074 00000000 400d38f5 00000000  
    40536d34 4011b751 40536d68 40536dc4 00000000  
    40536d44 ffffffff 00000000 401ca41f 40536dc4  
    40536d54 40536dc4 00003038 00000000 40536d84  
    40536d64 00000002 00003147 00003142 00003024  
    40536d74 4011b8ab 40536d84 00000000 c0000030  
    40536d84 00000008 00000000 40536dc4 00003033  
    40536d94 40536dc4 00003142 40536dc4 00003147  
    40536da4 40536dc4 00003024 40536dc4 00003023  
    40536db4 40536dc4 00003022 00003038 00003038  
    40536dc4 40128ff8 40ec09b0 00000007 00000000  
    40536dd4 00000008 40129654 40ec0318 40122d78  

memory near r7:
    40ec0990 00003038 00003038 00000038 0000005a  
    40ec09a0 00000001 00000040 00000000 00000000  
    40ec09b0 00003022 00000008 00003023 00000008  
    40ec09c0 00003024 00000008 00003033 00000004  
    40ec09d0 00003142 00000001 00003147 00000001  
    40ec09e0 00003038 00003038 00000000 00000000  
    40ec09f0 00000000 00000c81 00000000 00000000  
    40ec0a00 00000000 00000000 00000000 00000000  
    40ec0a10 00000000 00000000 00000000 00000000  
    40ec0a20 00000000 00000000 00000000 00000000  
    40ec0a30 00000000 00000000 00000000 00000000  
    40ec0a40 00000000 00000000 00000000 00000000  
    40ec0a50 00000000 00000000 00000000 00000000  
    40ec0a60 00000000 00000000 00000000 00000000  
    40ec0a70 00000000 00000000 00000000 00000000  
    40ec0a80 00000000 00000000 00000000 00000000  

memory near r9:
    00003018 ffffffff ffffffff ffffffff ffffffff  
    00003028 ffffffff ffffffff ffffffff ffffffff  
    00003038 ffffffff ffffffff ffffffff ffffffff  
    00003048 ffffffff ffffffff ffffffff ffffffff  
    00003058 ffffffff ffffffff ffffffff ffffffff  
    00003068 ffffffff ffffffff ffffffff ffffffff  
    00003078 ffffffff ffffffff ffffffff ffffffff  
    00003088 ffffffff ffffffff ffffffff ffffffff  
    00003098 ffffffff ffffffff ffffffff ffffffff  
    000030a8 ffffffff ffffffff ffffffff ffffffff  
    000030b8 ffffffff ffffffff ffffffff ffffffff  
    000030c8 ffffffff ffffffff ffffffff ffffffff  
    000030d8 ffffffff ffffffff ffffffff ffffffff  
    000030e8 ffffffff ffffffff ffffffff ffffffff  
    000030f8 ffffffff ffffffff ffffffff ffffffff  
    00003108 ffffffff ffffffff ffffffff ffffffff  

memory near sl:
    00003120 ffffffff ffffffff ffffffff ffffffff  
    00003130 ffffffff ffffffff ffffffff ffffffff  
    00003140 ffffffff ffffffff ffffffff ffffffff  
    00003150 ffffffff ffffffff ffffffff ffffffff  
    00003160 ffffffff ffffffff ffffffff ffffffff  
    00003170 ffffffff ffffffff ffffffff ffffffff  
    00003180 ffffffff ffffffff ffffffff ffffffff  
    00003190 ffffffff ffffffff ffffffff ffffffff  
    000031a0 ffffffff ffffffff ffffffff ffffffff  
    000031b0 ffffffff ffffffff ffffffff ffffffff  
    000031c0 ffffffff ffffffff ffffffff ffffffff  
    000031d0 ffffffff ffffffff ffffffff ffffffff  
    000031e0 ffffffff ffffffff ffffffff ffffffff  
    000031f0 ffffffff ffffffff ffffffff ffffffff  
    00003200 ffffffff ffffffff ffffffff ffffffff  
    00003210 ffffffff ffffffff ffffffff ffffffff  

memory near fp:
    00003018 ffffffff ffffffff ffffffff ffffffff  
    00003028 ffffffff ffffffff ffffffff ffffffff  
    00003038 ffffffff ffffffff ffffffff ffffffff  
    00003048 ffffffff ffffffff ffffffff ffffffff  
    00003058 ffffffff ffffffff ffffffff ffffffff  
    00003068 ffffffff ffffffff ffffffff ffffffff  
    00003078 ffffffff ffffffff ffffffff ffffffff  
    00003088 ffffffff ffffffff ffffffff ffffffff  
    00003098 ffffffff ffffffff ffffffff ffffffff  
    000030a8 ffffffff ffffffff ffffffff ffffffff  
    000030b8 ffffffff ffffffff ffffffff ffffffff  
    000030c8 ffffffff ffffffff ffffffff ffffffff  
    000030d8 ffffffff ffffffff ffffffff ffffffff  
    000030e8 ffffffff ffffffff ffffffff ffffffff  
    000030f8 ffffffff ffffffff ffffffff ffffffff  
    00003108 ffffffff ffffffff ffffffff ffffffff  

memory near ip:
    400d4fd4 00000000 00000000 00000000 4014d761  
    400d4fe4 4014d651 40144110 40144130 40138ef5  
    400d4ff4 4014406c 40138f09 4014d605 400d5000  
    400d5004 00000000 00000000 00000000 00000000  
    400d5014 00000000 00000000 00000000 00000000  
    400d5024 00000000 00000000 00000000 00000000  
    400d5034 00000000 00000000 00000000 00000000  
    400d5044 00000000 00000000 00000000 00000000  
    400d5054 00000000 00000000 00000000 00000000  
    400d5064 00000000 00000000 00000000 00000000  
    400d5074 00000000 00000000 00000000 00000000  
    400d5084 00000000 00000000 00000000 00000000  
    400d5094 00000000 00000000 00000000 00000000  
    400d50a4 00000000 00000000 00000000 00000000  
    400d50b4 00000000 00000000 00000000 00000000  
    400d50c4 00000000 00000000 00000000 00000000  

memory near sp:
    40536ce0 00000000 4014a0d9 00000001 40536d04  
    40536cf0 00000000 40ec09b0 df0027ad 00000000  
    40536d00 00000000 fffffbdf 00000000 00000000  
    40536d10 40ec09b0 00000002 00003038 40536dc4  
    40536d20 00000000 40144074 00000000 400d38f5  
    40536d30 00000000 4011b751 40536d68 40536dc4  
    40536d40 00000000 ffffffff 00000000 401ca41f  
    40536d50 40536dc4 40536dc4 00003038 00000000  
    40536d60 40536d84 00000002 00003147 00003142  
    40536d70 00003024 4011b8ab 40536d84 00000000  
    40536d80 c0000030 00000008 00000000 40536dc4  
    40536d90 00003033 40536dc4 00003142 40536dc4  
    40536da0 00003147 40536dc4 00003024 40536dc4  
    40536db0 00003023 40536dc4 00003022 00003038  
    40536dc0 00003038 40128ff8 40ec09b0 00000007  
    40536dd0 00000000 00000008 40129654 40ec0318  

code around pc:
    40146750 e000b164 6823461c d1fb2b00 68e3e026  
    40146760 4a17b123 447a2401 47986014 20274911  
    40146770 70082400 eb86f7fc f7fd2106 a902ecea  
    40146780 f04f2006 460a5380 94029304 f7fd9403  
    40146790 4629e8d0 20024622 e8d8f7fd eb72f7fc  
    401467a0 f7fd2106 2001ecd6 e892f7fc 2a006962  
    401467b0 e7d4d1dc deadbaad 0002d826 00030b0a  
    401467c0 00030aee 2400b510 aa04b088 46699002  
    401467d0 94014620 94039400 e830f7fd bfb842a0  
    401467e0 db054620 b1139b07 1c489906 98069006  
    401467f0 bd10b008 4604b510 e9c6f7fc d10542a0  
    40146800 447b4b04 6018681b bd102000 30fff04f  
    40146810 bf00bd10 0002d75a 460db538 481eb928  
    40146820 f7fc4478 2800edc4 b9fdd130 2102481b  
    40146830 f0014478 2800faae db274604 f7fc4629  
    40146840 2800ec4e 2101db0b f7fc4620 2800ec48  

code around lr:
    4014a0b8 41f0e92d 4c0b2600 447c4680 68a56824  
    4014a0c8 e0076867 300cf9b5 dd022b00 47c04628  
    4014a0d8 35544306 d5f53f01 2c006824 4630d1ef  
    4014a0e8 81f0e8bd 00029ec2 43f0e92d fb01461f  
    4014a0f8 f8dff602 b0878058 44f8460c 8000f8d8  
    4014a108 9001a901 f8d84615 20013000 96059602  
    4014a118 90049103 4638b113 fa35f7ff a9034638  
    4014a128 fe9bf7ff 2000f8d8 b1124681 f7ff4638  
    4014a138 f1b9fa37 d0050f00 46219d05 f01a1b70  
    4014a148 4605ed46 b0074628 83f0e8bd 00029e3a  
    4014a158 1e4b6841 2b006043 f000da01 6803bbab  
    4014a168 2b01f813 46106003 00004770 4604b570  
    4014a178 447e4e0d 68336836 f7ffb10b 6861fa04  
    4014a188 60601e48 bfa22800 f8106820 60205b01  
    4014a198 4620da03 fb8ef000 68324605 4620b112  
    4014a1a8 f9fef7ff bd704628 00029dc2 447b4b07  

memory map around fault addr deadbaad:
    be816000-be837000 [stack]
    (no map for address)
    ffff0000-ffff1000 [vectors]
--------- tail end of log /dev/log/main
10-31 06:40:49.320  1210  1212 E ti_hwc  : Composer HAL failed to load compatible Graphics HAL
10-31 06:40:49.320  1210  1212 E SurfaceFlinger: composer device failed to initialize (Invalid argument)
10-31 06:40:49.320  1210  1212 W SurfaceFlinger: getting VSYNC period from fb HAL: 16909029
10-31 06:40:49.320  1210  1212 E libEGL  : validate_display:251 error 3008 (EGL_BAD_DISPLAY)
10-31 06:40:49.320  1210  1212 F libc    : Fatal signal 11 (SIGSEGV) at 0xdeadbaad (code=1), thread 1212 (SurfaceFlinger)
--- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---
pid: 1210, tid: 1210, name: surfaceflinger
    r0 40ec04f8  r1 00000080  r2 00000000  r3 00000000
    r4 40ec04f8  r5 40ec04f4  r6 00000000  r7 000000f0
    r8 40ec0318  r9 00000000  sl 00000000  fp be836bcc
    ip 00000000  sp be836af8  lr 4013a420  pc 40144104  cpsr 60000010
    d0  466563616672756c  d1  0000000040ebe869
    d2  40ebdcd040ebdc6e  d3  40ebdcf040ebdc67
    d4  40ebd38040ebd370  d5  40ebd3a040ebd390
    d6  40ebd80040ebd3b0  d7  40ebdc6040ebdc50
    d8  0000000000000000  d9  0000000000000000
    d10 0000000000000000  d11 0000000000000000
    d12 0000000000000000  d13 0000000000000000
    d14 0000000000000000  d15 0000000000000000
    d16 41a1e8e85578d4fe  d17 3f50624dd2f1a9fc
    d18 41ac66d5e0000000  d19 0000000000000000
    d20 0000000000000000  d21 0000000000000000
    d22 0000000000000000  d23 0000000000000000
    d24 0000000000000000  d25 0000000000000000
    d26 0000000000000000  d27 0000000000000000
    d28 0000000000000000  d29 0000000000000000
    d30 0000000000000000  d31 0000000000000000
    scr 00000010

backtrace:
    #00  pc 00018104  /system/lib/libc.so (__futex_syscall3+8)
    #01  pc 0000e41c  /system/lib/libc.so (__pthread_cond_timedwait_relative+48)
    #02  pc 0000e478  /system/lib/libc.so (__pthread_cond_timedwait+60)
    #03  pc 00024633  /system/lib/libsurfaceflinger.so
    #04  pc 0002674d  /system/lib/libsurfaceflinger.so (android::SurfaceFlinger::onFirstRef()+52)
    #05  pc 0000ef2d  /system/lib/libutils.so (android::RefBase::incStrong(void const*) const+38)
    #06  pc 000007d7  /system/bin/surfaceflinger
    #07  pc 00000845  /system/bin/surfaceflinger
    #08  pc 0001271f  /system/lib/libc.so (__libc_init+38)
    #09  pc 00000724  /system/bin/surfaceflinger

stack:
         be836ab8  00000000  
         be836abc  40139154  /system/lib/libc.so (pthread_attr_destroy+16)
         be836ac0  40536f00  
         be836ac4  401c8cf3  /system/lib/libutils.so (androidCreateRawThreadEtc+138)
         be836ac8  c0000000  
         be836acc  00000010  
         be836ad0  40ec05d0  [heap]
         be836ad4  00000000  
         be836ad8  0000001b  
         be836adc  40ec0630  [heap]
         be836ae0  42424242  
         be836ae4  42424242  
         be836ae8  42424242  
         be836aec  42424242  
         be836af0  42424242  
         be836af4  42424242  
    #00  be836af8  40ec04f8  [heap]
         be836afc  00000000  
    #01  be836b00  00000000  
         be836b04  40ec04f4  [heap]
         be836b08  40ec04f8  [heap]
         be836b0c  00000001  
         be836b10  40ec02a8  [heap]
         be836b14  4013a47c  /system/lib/libc.so (__pthread_cond_timedwait+64)
    #02  be836b18  401c9135  /system/lib/libutils.so (android::Thread::run(char const*, int, unsigned int))
         be836b1c  00000001  
         be836b20  40ec02a8  [heap]
         be836b24  40ec04f4  [heap]
         be836b28  40ec04f8  [heap]
         be836b2c  4011b637  /system/lib/libsurfaceflinger.so
    #03  be836b30  40ec04f4  [heap]
         be836b34  40ec04f4  [heap]
         be836b38  40ec0334  [heap]
         be836b3c  40ec0318  [heap]
         be836b40  401c9135  /system/lib/libutils.so (android::Thread::run(char const*, int, unsigned int))
         be836b44  4011d751  /system/lib/libsurfaceflinger.so (android::SurfaceFlinger::onFirstRef()+56)
    #04  be836b48  40ec0318  [heap]
         be836b4c  40ec0318  [heap]
         be836b50  00000000  
         be836b54  40ec0530  [heap]
         be836b58  402f4ab5  /system/lib/libbinder.so
         be836b5c  401c6f2f  /system/lib/libutils.so (android::RefBase::incStrong(void const*) const+40)
    #05  be836b60  be836b70  [stack]
         be836b64  400737db  /system/bin/surfaceflinger
    #06  be836b68  40ec02a8  [heap]
         be836b6c  40ec02f0  [heap]
         be836b70  40ec031c  [heap]
         be836b74  00000000  
         be836b78  40073841  /system/bin/surfaceflinger
         be836b7c  be836bd4  [stack]
         be836b80  00000001  
         be836b84  be836bdc  [stack]
         be836b88  00000000  
         be836b8c  40073849  /system/bin/surfaceflinger
    #07  be836b90  00000001  
         be836b94  be836bd4  [stack]
         be836b98  be836bdc  [stack]
         be836b9c  4013e721  /system/lib/libc.so (__libc_init+40)
    #08  be836ba0  be836bb8  [stack]
         be836ba4  00000000  
         be836ba8  00000000  
         be836bac  00000000  
         be836bb0  00000000  
         be836bb4  40073728  /system/bin/surfaceflinger
    #09  be836bb8  40074e7c  /system/bin/surfaceflinger
         be836bbc  40074e84  /system/bin/surfaceflinger
         be836bc0  40074e8c  /system/bin/surfaceflinger
         be836bc4  be836bd0  [stack]
         be836bc8  00000000  
         be836bcc  400dfbbb  /system/bin/linker
         be836bd0  00000001  
         be836bd4  be836cc8  [stack]
         be836bd8  00000000  
         be836bdc  be836ce3  [stack]
         be836be0  be836d20  [stack]
         be836be4  be836d48  [stack]
         be836be8  be836d5b  [stack]
         be836bec  be836d70  [stack]
         be836bf0  be836d8b  [stack]
         be836bf4  be836d9e  [stack]
--- --- --- --- --- --- --- --- --- --- --- --- --- --- --- 
---
pid: 1210, tid: 1213, name: VSyncThread
    r0 40ec08cc  r1 00000080  r2 00000000  r3 00000000
    r4 40ec08cc  r5 40ec08c8  r6 00000000  r7 000000f0
    r8 401c8d35  r9 00100000  sl 40ec0910  fp 00000000
    ip 00000000  sp 40d8be30  lr 4013a420  pc 40144104  cpsr 60000010
    d0  726854636e795365  d1  646f697265702061
    d2  2064616f6c206f64  d3  62697461706d6f00
    d4  000000020000009e  d5  000000020000000d
    d6  0000000000000001  d7  426c8f5c00000000
    d8  0000000000000000  d9  0000000000000000
    d10 0000000000000000  d11 0000000000000000
    d12 0000000000000000  d13 0000000000000000
    d14 0000000000000000  d15 0000000000000000
    d16 4170202e598a1e04  d17 41cdcd6500000000
    d18 3d9262fffe000000  d19 3fe0000000000000
    d20 3fe0000000009318  d21 0000000000000000
    d22 0000000000000000  d23 0000000000000000
    d24 0000000000000000  d25 0000000000000000
    d26 0000000000000000  d27 0000000000000000
    d28 0000000000000000  d29 0000000000000000
    d30 0000000000000000  d31 0000000000000000
    scr 20000010

backtrace:
    #00  pc 00018104  /system/lib/libc.so (__futex_syscall3+8)
    #01  pc 0000e41c  /system/lib/libc.so (__pthread_cond_timedwait_relative+48)
    #02  pc 0000e478  /system/lib/libc.so (__pthread_cond_timedwait+60)
    #03  pc 00022131  /system/lib/libsurfaceflinger.so (android::HWComposer::VSyncThread::threadLoop()+32)
    #04  pc 00011267  /system/lib/libutils.so (android::Thread::_threadLoop(void*)+114)
    #05  pc 00010dcd  /system/lib/libutils.so
    #06  pc 0000e3d8  /system/lib/libc.so (__thread_entry+72)
    #07  pc 0000dac4  /system/lib/libc.so (pthread_create+160)

stack:
         40d8bdf0  00000000  
         40d8bdf4  00000000  
         40d8bdf8  00000000  
         40d8bdfc  00000000  
         40d8be00  00000000  
         40d8be04  00000000  
         40d8be08  00000000  
         40d8be0c  00000000  
         40d8be10  00000000  
         40d8be14  00000000  
         40d8be18  00000000  
         40d8be1c  00000000  
         40d8be20  00000000  
         40d8be24  00000000  
         40d8be28  00000000  
         40d8be2c  00000000  
    #00  40d8be30  40ec08cc  [heap]
         40d8be34  00000000  
    #01  40d8be38  00000000  
         40d8be3c  40ec08c8  [heap]
         40d8be40  40ec08cc  [heap]
         40d8be44  40ec08c8  [heap]
         40d8be48  40ec08cc  [heap]
         40d8be4c  4013a47c  /system/lib/libc.so (__pthread_cond_timedwait+64)
    #02  40d8be50  401c4ead  /system/lib/libutils.so (android::BlobCache::getFdCount() const)
         40d8be54  40ec08a0  [heap]
         40d8be58  40ec08c8  [heap]
         40d8be5c  40ec08a0  [heap]
         40d8be60  40ec08c8  [heap]
         40d8be64  40119135  /system/lib/libsurfaceflinger.so (android::HWComposer::VSyncThread::threadLoop()+36)
    #03  40d8be68  00000000  
         40d8be6c  00000000  
         40d8be70  40177228  
         40d8be74  00000000  
         40d8be78  00000000  
         40d8be7c  00000000  
         40d8be80  00000000  
         40d8be84  00000000  
         40d8be88  00000000  
         40d8be8c  40ec08a0  [heap]
         40d8be90  40d8bea0  
         40d8be94  40128a6c  /system/lib/libsurfaceflinger.so
         40d8be98  40128a6c  /system/lib/libsurfaceflinger.so
         40d8be9c  401c9269  /system/lib/libutils.so (android::Thread::_threadLoop(void*)+116)
    #04  40d8bea0  40ec08a0  [heap]
         40d8bea4  4013d813  /system/lib/libc.so (dlfree+34)
         40d8bea8  40ec08a0  [heap]
         40d8beac  40ec08f8  [heap]
         40d8beb0  40ec08a0  [heap]
         40d8beb4  40ec0620  [heap]
         40d8beb8  401c91f5  /system/lib/libutils.so (android::Thread::_threadLoop(void*))
         40d8bebc  40ec08a0  [heap]
         40d8bec0  00000000  
         40d8bec4  401c8dcf  /system/lib/libutils.so
    #05  40d8bec8  00000000  
         40d8becc  40ec0928  [heap]
         40d8bed0  40d8bffc  
         40d8bed4  40d8bf00  
         40d8bed8  40ec0928  [heap]
         40d8bedc  401c8d35  /system/lib/libutils.so
         40d8bee0  40ec0910  [heap]
         40d8bee4  4013a3dc  /system/lib/libc.so (__thread_entry+76)
    #06  40d8bee8  40ec0910  [heap]
         40d8beec  40d8bf00  
         40d8bef0  40536cf0  
         40d8bef4  40ec0928  [heap]
         40d8bef8  00000078  
         40d8befc  40139ac8  /system/lib/libc.so (pthread_create+164)
    #07  40d8bf00  40d8bf00  
         40d8bf04  40ec0928  [heap]
         40d8bf08  00000000  
         40d8bf0c  00000000  
         40d8bf10  00000000  
         40d8bf14  00000000  
         40d8bf18  00000000  
         40d8bf1c  00000000  
         40d8bf20  00000000  
         40d8bf24  00000000  
         40d8bf28  00000000  
         40d8bf2c  00000000  
         40d8bf30  00000000  
         40d8bf34  00000000  
         40d8bf38  00000000  
         40d8bf3c  00000000  
--------- log /dev/log/main
10-31 06:40:49.304  1210  1210 I SurfaceFlinger: SurfaceFlinger is starting
10-31 06:40:49.304  1210  1212 I SurfaceFlinger: SurfaceFlinger&#39;s main thread ready to run. Initializing graphics H/W...
10-31 06:40:49.304  1210  1212 E libEGL  : eglGetDisplay:121 error 300c (EGL_BAD_PARAMETER)
10-31 06:40:49.304  1210  1212 E libEGL  : eglInitialize:137 error 3008 (EGL_BAD_DISPLAY)
10-31 06:40:49.312  1210  1212 I gralloc : using (fd=14)
id           = omapfb
xres         = 720 px
yres         = 1280 px
xres_virtual = 720 px
yres_virtual = 2560 px
bpp          = 32
r            = 16:8
g            =  8:8
b            =  0:8
10-31 06:40:49.312  1210  1212 I gralloc : width        = 58 mm (315.310333 dpi)
height       = 102 mm (318.745087 dpi)
refresh rate = 59.14 Hz
10-31 06:40:49.320  1210  1212 E ti_hwc  : Composer HAL failed to load compatible Graphics HAL
10-31 06:40:49.320  1210  1212 E SurfaceFlinger: composer device failed to initialize (Invalid argument)
10-31 06:40:49.320  1210  1212 W SurfaceFlinger: getting VSYNC period from fb HAL: 16909029
10-31 06:40:49.320  1210  1212 E libEGL  : validate_display:251 error 3008 (EGL_BAD_DISPLAY)
10-31 06:40:49.320  1210  1212 F libc    : Fatal signal 11 (SIGSEGV) at 0xdeadbaad (code=1), thread 1212 (SurfaceFlinger)
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>测试驱动开发</title>
   <link href="http://www.5wpc.info/it/technical/softwareengineering/2014/10/30/TDD"/>
   <updated>2014-10-30T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/technical/softwareengineering/2014/10/30/TDD</id>
   <content type="html">&lt;p&gt;本文主要是&lt;a href=&quot;http://book.douban.com/subject/5326182/&quot; title=&quot;测试驱动开发的艺术&quot;&gt;测试驱动开发的艺术&lt;/a&gt;的读书笔记.&lt;/p&gt;

&lt;h1&gt;综述&lt;/h1&gt;

&lt;h2&gt;正确地做事&lt;/h2&gt;

&lt;p&gt;开发的主要流程:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;测试&lt;/li&gt;
&lt;li&gt;编码&lt;/li&gt;
&lt;li&gt;重构&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;上述过程结合增量式开发模式, 以更好地保证应用需求变化.&lt;/p&gt;

&lt;h2&gt;主要工具&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;单元测试框架 xUnit&lt;/li&gt;
&lt;li&gt;结合持续集成及构建&lt;/li&gt;
&lt;li&gt;引入静态与动态代码质量分析工具:

&lt;ul&gt;
&lt;li&gt;PMD&lt;/li&gt;
&lt;li&gt;checkstyle&lt;/li&gt;
&lt;li&gt;findbug&lt;/li&gt;
&lt;li&gt;lint&lt;/li&gt;
&lt;li&gt;代码覆盖率分析&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;TDD 的概念与模式&lt;/h1&gt;

&lt;h2&gt;如何编写及通过测试&lt;/h2&gt;

&lt;h3&gt;编写测试&lt;/h3&gt;

&lt;h4&gt;测试选择技巧&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;深入细节与整体考虑

&lt;ul&gt;
&lt;li&gt;细节优先(深度优先): 便于发现关键技术点&lt;/li&gt;
&lt;li&gt;整体优先(宽度优先): 便于验证整体架构&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;探索未知与轻车熟路

&lt;ul&gt;
&lt;li&gt;优先编写不确定因素少的测试&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;最大限度地获取价值与摘取现成果实

&lt;ul&gt;
&lt;li&gt;优先测试基本功能再处理边界问题&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;走通基本功能路径与行处理出错情况

&lt;ul&gt;
&lt;li&gt;先保证基本路径&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h4&gt;实现技巧&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;伪实现&lt;/li&gt;
&lt;li&gt;三角法&lt;/li&gt;
&lt;li&gt;简单地实现&lt;/li&gt;
&lt;/ul&gt;


&lt;h4&gt;测试驱动的基本准则&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;绝不路过重构&lt;/li&gt;
&lt;li&gt;尽快变绿&lt;/li&gt;
&lt;li&gt;犯错后减慢速度&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;重要的测试概念&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;夹具(fixtures)是测试的上下文

&lt;ul&gt;
&lt;li&gt;测试过程中的状态维护体&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;用测试替身(mock)替换依赖

&lt;ul&gt;
&lt;li&gt;测试基本形式就是方法调用: 构造需要的参数, 调用, 再检查返回的结果; 替身在这里主要用于构造参数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;基于状态与基于交互的测试不同

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;基于状态的测试利用对象内部状态来验证运行结果的正确性&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  @Test
  public void listShouldNotBeEmptyAfterAddingSomethingToIt() throws Exception {
      List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;String&amp;gt;();
      assertTrue(list.isEmpty());
      list.add(&quot;Something&quot;);
      assertFalse(list.isEmpty());
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;基于交互的测试主要关注整个调用的过程&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;由于涉及完整的交互, 我们就需要单独构建与其交互的对象实例, 这时就需要使用动态模拟对象库(dynamic mock objects library): EasyMock, jMock&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;测试替身&lt;/h2&gt;

&lt;p&gt;用于是用于模拟真实的对象,&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;测试桩: 给定接口最简单的实现, 主要是硬编码数据&lt;/li&gt;
&lt;li&gt;伪实现&lt;/li&gt;
&lt;li&gt;模拟对象: 可以完成对象构建, 状态模拟与过程录制&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;import static org.easymock.classextension.EasyMock.*;
import static org.juni.Assert.*;
import org.junit.*;

public class OrderProcessorEasymockTest{
    @Test
    public void testOrderProcessorWithEasyMock() throws Exception {
        //为测试准备普通对象和数据
        float initialBalance = 100.0f;
        float listPrice = 30.0f;
        float discount = 10.0f;
        float expectedBalance = 
            initialBalance - (listPrice*(1-discount/100));
        Customer customer = new Customer(initialBalance);
        Product product = new Product(&quot;TDD in action&quot;, listPrice);

        //模拟对象 创建过程
        //通过模拟对象创建动态模拟过程中的相关假对象
        PricingService mock = createMock(PricingService.class);
        //BDD模式,调用输入与期望输出, 后期统一对状态进行测试
        expect(mock.getDiscountPercentage(customer, product).addReturn(discount));

        replay(mock);//进入播放模式

        //待测对象 中间利用模拟对象完成部分交互
        //测试OrderProcessor
        OrderProcessor processor = new OrderProcessor();
        processor.setPricingService(mock);//注入依赖
        processor.process(new Order(customer, product));//正常调用过程

        assertEquals(expectedBalance, customer.getBalance(), 0.001f);
        verify(mock);//验证输入输出

    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;提高设计的可测试性的准则&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;多使用组合而不是继承&lt;/li&gt;
&lt;li&gt;不要使用static 关键字以及单例模式&lt;/li&gt;
&lt;li&gt;隔离依赖&lt;/li&gt;
&lt;li&gt;注入依赖&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;测试的主要模式&lt;/h2&gt;

&lt;h3&gt;单元测试&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;断言模式: 状态的基本测试&lt;/li&gt;
&lt;li&gt;防卫模式: 在获取到测试用数据后先验证数据本身&lt;/li&gt;
&lt;li&gt;差值断言&lt;/li&gt;
&lt;li&gt;自定义断言&lt;/li&gt;
&lt;li&gt;交互断言&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;夹具&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;参数化创建方法

&lt;ul&gt;
&lt;li&gt;基本对象不要硬编码&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;对象生产

&lt;ul&gt;
&lt;li&gt;工厂模式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;自动清理

&lt;ul&gt;
&lt;li&gt;测试前清理测试现场&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;测试过程&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;参数化&lt;/li&gt;
&lt;li&gt;自分流&lt;/li&gt;
&lt;li&gt;测试内部数据共享: 利用闭包/内部类进行数据分享&lt;/li&gt;
&lt;li&gt;待测试对象的状态: 通过反射进行完整扫描&lt;/li&gt;
&lt;li&gt;添加专用处理类&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;测试驱动数据访问&lt;/h1&gt;

&lt;h2&gt;文件系统访问&lt;/h2&gt;

&lt;p&gt;我们需要尽量避免访问文件系统, 使用java.io.Writer及java.io.Reader.
毕竟大部分时间我们感兴趣的是文件内容, 不是文件本身, 使用streams完全可以胜任.&lt;/p&gt;

&lt;h3&gt;提高文件访问的可测试性的实践&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;用接口隔离文件访问&lt;/li&gt;
&lt;li&gt;使用流(stream)而非文件&lt;/li&gt;
&lt;li&gt;使用自定义的文件对象

&lt;ul&gt;
&lt;li&gt;将文件内容和文件信息(元数据)关联起来&lt;/li&gt;
&lt;li&gt;使用内存性的文件系统, 性能更快&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;使用专用的临时文件夹

&lt;ul&gt;
&lt;li&gt;将所有的测试数据放在一个文件夹, 便于统一地处理(创建与清理)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;测试前清理而非测试后&lt;/li&gt;
&lt;/ol&gt;

</content>
 </entry>
 
 <entry>
   <title>Java Crack 技术</title>
   <link href="http://www.5wpc.info/it/technical/language/java/2014/10/29/javaCrack"/>
   <updated>2014-10-29T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/technical/language/java/2014/10/29/javaCrack</id>
   <content type="html">&lt;h1&gt;主要工具与方法&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;JAD&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;防护&lt;/h1&gt;

&lt;h2&gt;&lt;a href=&quot;http://proguard.sourceforge.net/&quot;&gt;proguard&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;该工具可以针对java class文件做如下处理:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;压缩

&lt;ul&gt;
&lt;li&gt;检测推算并删除: 无用的类, 字段, 方法, 属性与修饰&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;优化

&lt;ul&gt;
&lt;li&gt;用于优化字节码, 删除无用指令&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;混淆

&lt;ul&gt;
&lt;li&gt;将类, 方法, 字段进行重命名&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;预校验

&lt;ul&gt;
&lt;li&gt;保证编译完成的字节码可用于Java6及以上版本&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;二进制程序结构&lt;/h1&gt;

&lt;p&gt;程序的整个反编译过程由二进制程序出发, 通过二进制程序中的数据来进行程序的还原.&lt;/p&gt;

&lt;p&gt;http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>C Crack</title>
   <link href="http://www.5wpc.info/it/technical/language/c/2014/10/29/cCrack"/>
   <updated>2014-10-29T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/technical/language/c/2014/10/29/cCrack</id>
   <content type="html">&lt;h1&gt;ELF 文件标准格式&lt;/h1&gt;

&lt;p&gt;http://en.wikipedia.org/wiki/Executable_and_Linkable_Format&lt;/p&gt;

&lt;p&gt;http://www.dwarfstd.org/doc/Debugging%20using%20DWARF.pdf&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Android Crack 技术</title>
   <link href="http://www.5wpc.info/it/technical/os/android/2014/10/29/appCrack"/>
   <updated>2014-10-29T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/technical/os/android/2014/10/29/appCrack</id>
   <content type="html">&lt;h1&gt;主要工具与方法&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;在线调试(JDWP)

&lt;ul&gt;
&lt;li&gt;AndBug&lt;/li&gt;
&lt;li&gt;SmaliHack + Eclipse Debug&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;离线逆向工程

&lt;ul&gt;
&lt;li&gt;Smali Hack&lt;/li&gt;
&lt;li&gt;多进程合并&lt;/li&gt;
&lt;li&gt;aapt 状态分析&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;防护&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;proguard&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>软件破解技术</title>
   <link href="http://www.5wpc.info/it/technical/design/2014/10/29/Crack"/>
   <updated>2014-10-29T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/technical/design/2014/10/29/Crack</id>
   <content type="html">&lt;h1&gt;通用处理手法&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;动态跟踪与分析代码逻辑: AndBug, OllyDbg&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;主要防护思路&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;程序加壳: 主程序自身直接通过标准加密方法进行加密后保存, 整个程序的启动再通过专有的加载器完成所有工作, 在运行时将需要的程序数据进行解密与运行. 整个程序的安全程度由加壳程序决定.&lt;/li&gt;
&lt;li&gt;程序代码混淆: 增加程序反编译后的阅读难度&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>缓存技术Cache</title>
   <link href="http://www.5wpc.info/it/technical/algorithm/2014/10/08/Cache"/>
   <updated>2014-10-08T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/technical/algorithm/2014/10/08/Cache</id>
   <content type="html">&lt;h1&gt;缓存技术Cache&lt;/h1&gt;

&lt;h2&gt;tags: Web&lt;/h2&gt;

&lt;h2&gt;十个常见的缓存使用误区及建议&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;http://www.infoq.com/cn/news/2014/09/ten-cache-misunderstanding&lt;/li&gt;
&lt;li&gt;主要误区

&lt;ul&gt;
&lt;li&gt;依赖默认的序列化方式

&lt;ul&gt;
&lt;li&gt;CPU性能不佳&lt;/li&gt;
&lt;li&gt;采用最合理、有效的序列化和反序列化方式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;在单一缓存中存储大对象数据

&lt;ul&gt;
&lt;li&gt;大量占用CPU&lt;/li&gt;
&lt;li&gt;建议大家把大对象数据分成为较小的子对象，然后再各自进行缓存&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;在不同线程间使用缓存共享对象

&lt;ul&gt;
&lt;li&gt;在竞态条件(Race conditions)条件下，当写线程对缓存进行写入操作时，如果这是读线程刚好也要访问同一缓冲对象，就有可能读取脏数据，所以在实际开发中要根据实际情况采取外部锁机制，以保证缓存数据的正确读写。&lt;/li&gt;
&lt;li&gt;Dirty Data&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;认为存储数据操作后，数据即刻就能存储到缓存中

&lt;ul&gt;
&lt;li&gt;刚进行写入缓存操作的数据并不一定能够马上写入缓存，这是因为当缓存空间不足时，刚写入的缓存有可能被刷新掉。所以在编写程序时，应该首先对获得缓存的值作空值检测。&lt;/li&gt;
&lt;li&gt;NULL data&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;使用嵌套对象存储整个集合

&lt;ul&gt;
&lt;li&gt;如果将整个集合对象数据进行嵌套缓存的话，获得其中某个具体元素的性能将会严重受到影响，这是因为整个集合存储意味着对整个嵌套对象进行序列化。&lt;/li&gt;
&lt;li&gt;建议单独对每个元素进行缓存，这样就可以做到对每个对象分别更新和读取，以减少序列化的影响。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;对父子对象采取统一与单独混用的存储方式

&lt;ul&gt;
&lt;li&gt;有时候一个对象可能拥有两个或更多的父对象，同一对象存储在不同地方，这样就会造成缓存的浪费。&lt;/li&gt;
&lt;li&gt;为了不让同一对象存储于不同地方，这就需要根据统一对象本身的键进行缓存，这样父对象就能够根据需要访问子对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;对配置信息进行缓存

&lt;ul&gt;
&lt;li&gt;缓存数据的访问是有代价的，所以要尽可能把影响减到最低&lt;/li&gt;
&lt;li&gt;建议使用本地静态变量代替缓存对配置数据进行存储。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;对实时对象进行缓存

&lt;ul&gt;
&lt;li&gt;如果对实时对象（例如：流、文件、注册信息或者网络情况）的引用进行缓存的话，当缓存数据被删除后，之前缓存的实时对象不被删除，这样会造成系统资源泄漏&lt;/li&gt;
&lt;li&gt;不要对实时对象进行存储&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;使用多个键存储同一对象

&lt;ul&gt;
&lt;li&gt;尽管使用多个键存储同一对象就使得使用一个键和索引号来进行访问时带来便利，但是当缓存是基于远程缓存的话，任何关于对象改变都是不可见的，这样会导致缓存数据同步问题的发生&lt;/li&gt;
&lt;li&gt;不建议使用多个键存储同一对象&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;在连续存储中进行更新或删除后不及时更新相应缓存对象

&lt;ul&gt;
&lt;li&gt;由于在一个远程缓存中，数据以拷贝方式存储，所以当更新对象时，缓存不会被同步更新。所以更新对象时，缓存必须被明确地进行更新。然而在基于内存的缓存中，当删除一个对象时，在缓存中不会被同步删除&lt;/li&gt;
&lt;li&gt;建议通过程序确保缓存对象被正确删除&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>美股开户扫盲一贴通</title>
   <link href="http://www.5wpc.info/it/project/financialmanage/2014/09/30/StockUSA"/>
   <updated>2014-09-30T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/project/financialmanage/2014/09/30/StockUSA</id>
   <content type="html">&lt;p&gt;美股开户扫盲一贴通
球友们分享了不少关于『美股开户』的经验，为了方便大家查阅，这里做个集中目录：
若有疑问，请直接与@IB美国盈透证券  @SogoTrade 联系&lt;/p&gt;

&lt;h1&gt;美股开户之口水介绍篇&lt;/h1&gt;

&lt;p&gt;http://xueqiu.com/3815464690/23859133&lt;/p&gt;

&lt;p&gt;中国人真的可以买美股，可以开美股账户！而且不用你去美国或者香港开…&lt;/p&gt;

&lt;p&gt;开完户、汇完款你就能买了！&lt;/p&gt;

&lt;p&gt;一、选券商&lt;/p&gt;

&lt;p&gt;首先决定去哪里开！我真的是废话连篇是吗？其实美股券商很多，保障上我觉得都ok，至于佣金商大家可以根据自己的资金量、交易习惯和交易频率选择一个适合自己的。我这里用多少了解的举例，要是哪里错了你们这些官方账号赶紧跳出来撒：）——汇报个好消息：他们开户都免费！&lt;/p&gt;

&lt;p&gt;如果是新手可以选@Firstrade第一理财 或者@SogoTrade ，原因很简单因为没有最低资金量限制，也没有每月的最低消费限制，手续费是按照一笔固定钱数收费（美股没有一手概念，也就是你可以一股一股的买，但是无论你这笔交易额多大或者买了多少股，都是固定收这一个数）——具体多少他们网站都有，另外美股没有印花税、过户费啥啥的，所以这基本就是总的交易成本。【我说基本是因为要是你买ADR一年这个ADR的托管银行可能收你很少很少的钱，比例我忘了，主要是就没关心过~@Ricky 你知道不？】&lt;/p&gt;

&lt;p&gt;如果资金多又喜欢买单价比较贵的股票且交易频繁的可以考虑@IB盈透证券 ，原因是他手续费是每股半美分，具体点就是买1000股任何股票都是5美元。但是有开户资金量最低1万美元的限制和每月不足10美元佣金按照10美元扣费的最低消费限制。&lt;/p&gt;

&lt;p&gt;二、怎么开&lt;/p&gt;

&lt;p&gt;涉及到开户申请表，所以最好先联系下券商：&lt;/p&gt;

&lt;p&gt;1、SogoTrade 你可以填个资料，然后等着它给你打电话介绍：&lt;/p&gt;

&lt;p&gt;http://www.fortune688.com/LandingPages/v3/FormPage.aspx?subid=106 …&lt;/p&gt;

&lt;p&gt;这个开户说明是中文的，也可以直接参考看一下：
http://www.fortune688.com/SubPages/edu/Lesson3_step1.aspx …&lt;/p&gt;

&lt;p&gt;2、第一理财我记得官网上有提供一个回拨电话，就是你留个号码它也会联系你的&lt;/p&gt;

&lt;p&gt;3、盈透是全部在网上填写申请资料，如果你英语不好先找个朋友帮你把家里地址翻译一下，当然也可以雪球连续盈透官方帮你撒~&lt;/p&gt;

&lt;p&gt;里面涉及个人提交的两个资料：1、身份证\护照，我感觉护照更方便些；2、地址证明，这个东西比起找什么居委会开你可以拿你家最近三个月水电煤气费的通知单，要是您是租的房子可以拿信用卡对账单——反正就是这个单子上面有个地址和您老名字就行了！&lt;/p&gt;

&lt;p&gt;然后是邮寄，快递、DHL、EMS 都可以，一般国内一周能到美国，券商1~2个工作日审核完也就会给你发邮件了。上次有个朋友不知道得到啥内幕消息，给我打电话说“我现在把所有资料都给你，你能不能立即给我开个美股账户，我要买股票”！汗死——这种情况您还是告诉我得到啥内幕消息比较实在…毕竟加上汇款、入金起码您老也得2周才能交易！&lt;/p&gt;

&lt;p&gt;邮寄费同事说100块钱，大家可以开的时候找自己身边朋友组团哈，放三五个人的估计超重不了&lt;del&gt;有的没的留着一个备用相信容易号召：）ps.美股券商账户没有一个人只能开在一家的限制（A股叫做指定），他家开后悔了再去别人家没啥转户销户的麻烦，把里面股票卖了、资金转了就成：）融资账户只能开在一家券商&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;三、汇钱喽&lt;/p&gt;

&lt;p&gt;首先你得把钱换成美元，一个身份证一年可以换5万美元，钱多的找亲戚借身份证去！&lt;/p&gt;

&lt;p&gt;国内个人不允许汇款给境外机构，更不能说你汇款是为了投资美股。这个也不难讨巧，其实你开户券商也会告诉点技巧，首先他们名字是字母，你千万别主动把收款方是券商说出来；汇款用途可以写购物、旅游、培训，但就是是不能写投资。——要是你还是不幸…那就等着钱退回来后再换家银行试试：）&lt;/p&gt;

&lt;p&gt;规避的办法是开户开始先那么汇着，啥时候出差去香港或者其他国家自己用自己名字开个海外账号，这样境内个人——境外个人——境外机构就没人管了！前几天一个朋友跟我说如果从建行到BOA（bank ofAmerica）的汇款每天都有2000美金免手续费的优惠，每天啊亲~~当然从BOA到券商托管行那个环节还是有手续费的撒——（我都觉得我墨迹，都是炒美股的高富帅了，谁家还斤斤计较这点费用呢…不过这里扯得多是因为这部分平时解释耗时最多）&lt;/p&gt;

&lt;p&gt;四、钱回来&lt;/p&gt;

&lt;p&gt;回款流程跟汇款正好逆向，跟券商填个申请单，然后两个工作日就能到账了！注意一点，美股是T+3结算，也就是如果你今天卖掉股票，那么最快这钱要5个工作日后才能回来。&lt;/p&gt;

&lt;p&gt;券商出款盈透是每个月第一次免费，之后10美元一次；SogoTrade国际电汇费是50美元。取款回国内是没有金额的限制的，但是在国内想花钱把这个变成人民币还有个全年不能兑换超过等值5万美元人民币的限制——也就是你汇回来100万美金想买房，还得借用下亲戚身份证：）&lt;/p&gt;

&lt;h1&gt;开户时如何选择美股券商？&lt;/h1&gt;

&lt;p&gt;http://xueqiu.com/4314386461/20389622&lt;/p&gt;

&lt;p&gt;【开户时如何选择美股券商？】
投资美股的第一件事就是要选择一家适合自己投资风格的可靠券商美国的券商，那么选择美股券商时要考虑哪些因素呢？&lt;/p&gt;

&lt;p&gt;一. 券商的规模实力&lt;/p&gt;

&lt;p&gt;美国的证券经纪不是国有垄断行业，大大小小的股票经纪公司数不胜数。投资者应该首选那些规模大实力强的知名券商，这样投资安全相对会有保障。目前，美股市场规模排名靠前的网络交易商主要有：嘉信理财、TD Ameritrade、E*Trade、富达理财、InteractiveBrokers(IB)等。对于过网络交易商，不能单纯通过券商网站对公司的规模实力得出结论，要查阅第三方或监管机构的网站。例如，美股券商一般都会加入金融行业监管公会(Financial Industry Regulatory Authority, 简称FINRA)，可以在FINRA的网站核查券商是否属于其会员。&lt;/p&gt;

&lt;p&gt;二. 可交易的品种&lt;/p&gt;

&lt;p&gt;中国投资者关心的交易品种一般包括美股、ETF、期权、外汇、港股、期货和债券等。美股券商可以交易的品种各有不同，需要事先了解选择的券商是否能满足自己的需求。&lt;/p&gt;

&lt;p&gt;美股是最基本的交易品种，所有的券商都能支持。港股由于地缘的关系，也是中国投资者关注的焦点。IB、E*Trade、嘉信理财等券商可同时提供港股交易。&lt;/p&gt;

&lt;p&gt;期权是玩转美股的必杀技，几乎所有券商都提供期权交易。但有些券商会限制可做的期权组合，如史考特证券就不允许投资者进行裸卖空，这种限制能避免投资新手犯错误，但对有经验的投资者而言，这种限制不太方便，因为有些时候裸卖空认沽期权能帮助投资者降低成本。&lt;/p&gt;

&lt;p&gt;ETF基金也是常见品种，在美国市场有很多挂钩指数、黄金、石油、板块、市场等ETF基金，为普通投资者打开了资产配置的方便渠道。大多数券商都能买卖ETF基金，但也有极个别的券商如SogoTrade就不提供ETF交易。&lt;/p&gt;

&lt;p&gt;三. 交易费用&lt;/p&gt;

&lt;p&gt;美国券商的交易手续费收费方式各异，对于频繁交易的投资者而言，选择不同的券商每个月的交易手续费差异可达数百美元之多，所以应该仔细对比选择。大多数网络交易商对美股交易按每笔收费，例如TD Ameritrade按每笔交易固定收$9.99，不论交易的股数多少。有些券商，除了每笔交易收取固定费用外，如果每笔交易股数超过限制，则需另外加收费用，如嘉信理财每笔股票交易收费$12.95，如果超过1000股，则超过部分再加$0.015/股。还有些券商是按交易股数收费，IB则按交易股数收费，每股收半美分($0.005)。&lt;/p&gt;

&lt;p&gt;为了吸引客户，有些券商赠送新开户的投资者免费交易机会，如SogoTrade对新开户客户提供第一个月100次免费交易，而Zecco则提供每月10次的免费交易。&lt;/p&gt;

&lt;p&gt;期权投资是对高级投资者是必须的投资手段，这方面大多数券商都是按每笔收一个固定费用，然后再按交易的合约数量加收费用，如史考特证券期权按每笔$7+$1.25/份合约收费。面向专业投资者的券商，如IB，则按期权交易数量，每份合约收$0.7。对比而言，IB的交易费用优势较大。&lt;/p&gt;

&lt;p&gt;如果你是有经验的投资者，则融资利率也是应该重点考虑的因素，有些券商的融资利率为3%，有些则高达9%。如果融资规模大，造成的成本差异相当巨大。&lt;/p&gt;

&lt;p&gt;四. 中文服务&lt;/p&gt;

&lt;p&gt;语言障碍可能是很多中国投资者进军美股市场的最大障碍，很多美国券商都已经认识到中国的投资需求，有些只是提供中文网页和汉化的交易软件，做得深入的则会提供中文客服热线，在香港开设分公司直接服务中国投资人。在中文化服务方面史考特证券(Scottrade)做得非常到位，深受中国投资者和海外华人的喜爱。&lt;/p&gt;

&lt;p&gt;五. 资金安全&lt;/p&gt;

&lt;p&gt;投资者将钱放在大洋彼岸，资金安全是必须要考虑的。好在大多数知名券商都参加了证券投资者保护公司(SIPC)的保险，SIPC对每个投资者的账号提供最高50万美元的保障，其中包含最高10万美元的现金保障。另外一些券商还购买了商业保险公司的保险为投资者账号提供额外保险，例如IB透过SIPC和英国劳埃德公司为其客户账号提供高达3000万美元的保障。&lt;/p&gt;

&lt;p&gt;以上是选择美股券商需要考虑的五大因素，此外还有一些细节如交易速度、交易点差、投资者教育等也需要投资者留意。选择合适的券商，需要根据自己的投资需求和投资风格，综合考虑这些因素，经过仔细对比选择，才能找到适合自己的券商。&lt;/p&gt;

&lt;h1&gt;盈透证券手把手教你美股网上开户&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;http://xueqiu.com/4586203773/26325431&lt;/li&gt;
&lt;li&gt;开户地址：http://xueqiu.com/r/maYrmm&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Step 1 开户&lt;/p&gt;

&lt;p&gt;输入https://www.ibkr.com.cn/mkt/?src=snowball4，建立账户，选择账户类型。如只希望交易某个国家股票如只美股或只港股，请选择简洁式申请，之后可以在账户管理配置全球交易权限。如希望直接开通多产品账户，交易全球市场美股、港股、日本股、欧洲股及全球期货、期权、债券及外汇等多资产产品请选择专业式申请。&lt;/p&gt;

&lt;p&gt;建户：选取用户名和密码，验证信箱信息，建立账户。&lt;/p&gt;

&lt;p&gt;详情：输入相关个人信息、交易产品及交易资格。最高级别的是投资组合保证金账户，最少维持11万美元；常规保证金账户最低入金要求为1万美元。(记得选择销售经理跟进）&lt;/p&gt;

&lt;p&gt;注资：填写入金意向通知书，注意填写入金通知书并不代表要求您马上入金，获得IB系统反馈的美元或港币等盈透银行账户信息。&lt;/p&gt;

&lt;p&gt;审批：上传身份证明及地址证明。&lt;/p&gt;

&lt;p&gt;设置：配置交易许可，订阅市场数据（美国打包实时数据仅10美元/月，月度佣金超过30美元则豁免）&lt;/p&gt;

&lt;p&gt;协议：网上电子签署提供的协议和披露&lt;/p&gt;

&lt;p&gt;完成：一旦账户批准，并注入资金即可交易。&lt;/p&gt;

&lt;p&gt;所需文件：一份身份证明+一份地址证明各一份，共两个不同的证件。大陆身份证（正反面）、护照、驾照、港澳通行证均可作为身份证明。水电煤单、银行账单、户口本、房产证、手机座机话费单、信用卡账单及租房合同等可作为身份证明。注：如使用大陆身份证作为身份证明还需另外一份文件作为地址证明。一个文件只能做一个用途。&lt;/p&gt;

&lt;p&gt;Step 2 注资&lt;/p&gt;

&lt;p&gt;盈透接受来自全球同名银行账户的汇款，包括中国大陆。并且接受19种币种注资。客户可以选择到香港等开设境外开设银行账户，方便转账。汇款时请在附言注明IB账户号码及姓名拼音，并且同时在盈透账户管理做相应的入金通知书。&lt;/p&gt;

&lt;p&gt;如已在其他券商持有美股头寸，可以将头寸直接转入IB。美股头寸可选择FOP（免费头寸转账），如欲将资金及美股头寸一并全部转入IB，可选择ACATS（自动客户账户转账服务）。亚洲头寸如港股请选择亚洲头寸转账。&lt;/p&gt;

&lt;p&gt;Step 3 交易&lt;/p&gt;

&lt;p&gt;盈透提供3种不同的交易平台，功能最强大的专业Java爪哇版TWS，推荐给专业的全职交易员使用。网络版的网页交易者让您穿透防火墙，在公司也可以用浏览器看盘下单。超级傻瓜版的移动端MobileTWS推荐给个人交易者使用，无需学习即可上手，下载页面http://www.mobileTWS.com，只要有3G及Wifi等网络或热点，随时随地都可以得到看盘、下单、看新闻一站式体验。&lt;/p&gt;

&lt;p&gt;注：为了进一步保障客户账户安全，盈透将会给成功开户并注入资金的客户邮寄安全卡。如交易时不希望用到安全卡，可自行在账户管理进行半激活，即交易时无需安全卡，但登录账户管理转账等时需启用安全卡。收到安全卡前，仍然可以交易。&lt;/p&gt;

&lt;p&gt;Step 4 学习&lt;/p&gt;

&lt;p&gt;由于盈透的交易系统非常先进功能强大，您花自己的时间去学习使用以节省自己的交易成本是很有必要的。可以直接在主页&gt;教育&gt; 网研会&gt;收看网研会录音&gt;多语言--中文查看，或者在土豆网搜索关键词“TWS”学习盈透官方发布的高清版TWS系列使用视频教程。&lt;/p&gt;

&lt;p&gt;一般都可在网上自助完成网上填表开户并上传资料后一至两个工作日即获批准。如有问题咨询，欢迎拨打客服中心电话+8621 6086 8586，如需专业服务可转接香港销售部。&lt;/p&gt;

&lt;p&gt;如有任何疑问请发邮件给戴爱娜小姐adai(a)ibkr.com或致电（021）6086 8586转接，直线 +（852）2156 7921。&lt;/p&gt;

&lt;h1&gt;Firstrade第一理财证券公司简介及开户指南&lt;/h1&gt;

&lt;p&gt;https://www.firstrade.com/content/zh-cn/international …&lt;/p&gt;

&lt;h1&gt;SogoTrade开户申请表&lt;/h1&gt;

&lt;p&gt;http://www.fortune688.com/LandingPages/v3/FormPage.aspx?subid=106 …&lt;/p&gt;

&lt;h1&gt;境外汇款方式与注意事项&lt;/h1&gt;

&lt;p&gt;http://xueqiu.com/4314386461/20389687&lt;/p&gt;

&lt;p&gt;目前资金汇出主要有3种方式：&lt;/p&gt;

&lt;p&gt;1、银行电汇：银行汇款柜台要收取不到2%的手续费及不到1%的钞汇转换差价费用，国外中间行收取15美元左右的手续费。外管局最近的新规定，每个银行营业部对每人每天的累计汇出境外汇款不得超过50000美元，但数量大可以借用别人的份额。单笔50000美元以下的现汇或10000美元以下的现钞，不需要出示证明，只需个人身份证。&lt;/p&gt;

&lt;p&gt;注意：外管局原则上并不允许境内个人通过汇款方式在境外投资（目前只有天津在进行试点），因此有些银行会限制国内个人对国外的“资本帐户”汇款，是正常的。不过同一银行的不同地区分行规定并不一定相同，很多分行都不会做太多限制。投资者多跑几家银行一般都能解决。如果在比较偏远的地区，投资者也可以去异地银行办理汇款。&lt;/p&gt;

&lt;p&gt;2、银邮业务：“一汇通” 银邮国际电子汇款是中国邮政与世界知名银行共同推出的新一代跨境美元入账汇款业务。
大城市的邮局很多都开通了这个业务，某些监管不严格的城市，如厦门，杭州等，随便汇多少都行，无上限 ，合法途径汇出没有任何障碍。这也是解决银行汇款限制最好的策略。&lt;/p&gt;

&lt;p&gt;3、国际信用卡：汇款没有手续费，每次和每月都不超过5000美元，但申请信用卡手续复杂。
境外汇入汇款大多数情况下是不做任何限制的，但在某些地区的极少数银行，可能会有一定限制。如某个招商银行可能限制国外“资本帐户”对国内个人汇款，或者某个中国银行收到超过2000美金的现汇，就要提供收入证明等，比较烦。这种情况下就需要去其他的银行操作。&lt;/p&gt;

&lt;p&gt;总的来说，北京、上海、杭州等数百家城市一般都不特别限制汇入汇出（有例外，但最终都好解决），单笔汇入越多越好，因为20万美元和1000美元的汇入费用都是10-40美元。&lt;/p&gt;

&lt;p&gt;如果对存取款有疑问的最好问一下当地的银行和邮局，或打电话咨询，事实上，现在国家对外汇的管理已经非常放开，不会过问太多这类汇款上的问题，如果遇到特殊情况，我们一般可以咨询他们的主管部门解决。&lt;/p&gt;

&lt;p&gt;友情提醒：投资美股市场须遵守国家外汇管理局的相关规定&lt;/p&gt;

&lt;h1&gt;美股开户账户类型---现金账户与保证金账户之比较&lt;/h1&gt;

&lt;p&gt;http://xueqiu.com/4314386461/20389642&lt;/p&gt;

&lt;p&gt;填写美股开户资料时遇到的第一个问题常常是要开什么账户类型。美国券商一般会提供两种类型的账户选择：&lt;/p&gt;

&lt;p&gt;现金账户(Cash Account)&lt;/p&gt;

&lt;p&gt;现金账户是最简单的账户，不允许透支，不允许卖空股票，有些券商甚至不允许现金账户买卖期权或仅允许风险低的期权组合(如Covered Call)。&lt;/p&gt;

&lt;p&gt;现金账户实行T+3，不能作日内交易（Day Trader），在5个交易日内买卖同一只股票的次数不能超过3次，否则会被冻结账户90天。&lt;/p&gt;

&lt;p&gt;现金账户开户最低资金要求较低，有些券商可以低至$500。&lt;/p&gt;

&lt;p&gt;现金账户适合投资新手或不想进行复杂交易的投资者。&lt;/p&gt;

&lt;p&gt;保证金账户/融资融券账户(Margin Account)&lt;/p&gt;

&lt;p&gt;保证金账户顾名思义可以向券商融资炒股，一般融资规模为投资者自有资产的一倍。即假设投资者有1万美元的资产（现金+股票+期权+基金+债券等），则可以向券商融资1万美元进行交易。&lt;/p&gt;

&lt;p&gt;除了能融资外，保证金账户还能自由地开展期权交易。另外，如果你的资金达到$25,000以上，想不受限制地做T+0交易，即成为Day Trader，你也必须开设保证金账户。所以即使你不打算透支炒股，也尽可能开设保证金账户。&lt;/p&gt;

&lt;p&gt;保证金账户最低开户资金要求较高，通常要在$2000以上。&lt;/p&gt;

&lt;p&gt;保证金账户适合资金量比较大，想做期权和T+0交易的投资者。&lt;/p&gt;

&lt;h1&gt;怎样开始投资美股——美股开户和汇款经验分享&lt;/h1&gt;

&lt;p&gt;http://xueqiu.com/6629424952/22767815&lt;/p&gt;

&lt;p&gt;2012 年我最重要的经历之一是开设了 A 股和美股账户，在股票投资上我是绝对的新手，没什么好分享的，不过倒是可以分享一下我美股开户和汇款经验给比我更新的新手。&lt;/p&gt;

&lt;p&gt;A 股就不说了，如果有疑问券商会帮你搞定，我是选了对我来说最方便的招商证券，因为工资卡是招商银行的。疑问比较多的可能是美股。&lt;a href=&quot;http://xueqiu.com/&quot;&gt;雪球网&lt;/a&gt;开放注册大概三个月左右了，最近也多了很多到里面询问如何开户和汇款的。&lt;/p&gt;

&lt;p&gt;首先要选择券商，结合自己的经历推荐三个：IB（盈透 InteractiveBrokers）、Scottrade 和 Firstrade。选择券商最重要的是考虑交易手续费和支持服务。&lt;/p&gt;

&lt;p&gt;我一开始用的是 Scottrade，中文支持很好，有繁体中文界面，有一些中文讲解视频（如&lt;a href=&quot;http://www.youtube.com/watch?v=UVEs0_szd50&quot;&gt;解說訂單類型&lt;/a&gt;），有中文的免费电话（回拨，网页上提交后马上有电话打过来）有问题都能及时咨询。交易手续费用不管多少一律是 7 美元。&lt;/p&gt;

&lt;p&gt;IB 是为专业投资者服务的券商，手续费很便宜，不过有初始注资一万美元以上的要求，还有每月最低消费 10 美元的要求。有一天大家在工作群里讨论券商，我去 IB 的网页上看了看，发现对年轻投资者有优惠。未满 27 岁资金只要求 3000 美元，未满 26 岁月最低消费只要 3 美元。我这个月满 24 岁，对三年内账户资金达到一万美元还是比较有信心的（大不了之后再注资），手续费最低消费优惠还能享受两年，算一下如果我的交易频度大于两个月一次，转过去就是划算的。&lt;/p&gt;

&lt;p&gt;IB 的账户申请很方便，不会像 Scottrade 或 Firstrade 需要寄送纸质资料——如果不急，可以寄平信，如果你要寄 EMS，需要两三百人民币和最快一周左右时间。IB 完全是在线填表，然后上传身份证明和地址证明扫描图片就可以了，白天填完表上传完证明文件，第二天经过美国一个工作日后就发现账户已经开通了，非常便捷。&lt;/p&gt;

&lt;p&gt;IB 有中文简体繁体界面，不过大家都说 IB 的操作界面比较烂。这个得以后我开始在 IB 交易了才知道。&lt;/p&gt;

&lt;p&gt;美股是允许一个人在多个券商开多个账户的（同一券商也可开不同账户），券商之间也方便相互转帐户里面的股票和资金。之前选择 Scottrade 的另一个好处是，根据&lt;a href=&quot;http://www.bargaineering.com/articles/beware-broker-transfer-out-fees.html%20%E2%80%A6&quot;&gt;这个网页&lt;/a&gt;，Scottrade 转出股票和资金不收费，而在此列出的其他券商都需要收费（Firstrade 是 50 美元）。不过我已经申请了资产转移，还没到 IB 帐上，要到时候才能真正知道是否收取了费用。&lt;/p&gt;

&lt;p&gt;2013-01-09 更新：前天有网友提&lt;a href=&quot;http://www.scottrade.com/online-brokerage/trading-fees-commissions.html#tab7%20%E2%80%A6&quot;&gt;现在 Scottrade 转出要收费了，75 刀&lt;/a&gt;。今天查 IB 账户已经到账了，果然是扣了 75 刀。如此看来对资金量小的新手来说，更推荐 Firstrade。&lt;/p&gt;

&lt;p&gt;我被同事告知，IB 的一个“坏处”是交易费用太便宜了，让你忍不住多交易；而通常的经验是，交易越多，损失就会越多（不止是手续费，还包括损失掉的赚钱机会）。不过以我自己的亲身体验，觉得新手开户后手痒忍不住多交易是很正常的。&lt;/p&gt;

&lt;p&gt;Firstrade 在这一点就为新手考虑到了。Firstrade 开户后首次注资超过 2000 即可享受 90 天内 250 次免费交易——平均一天好几次，这个频度绝对够用的。条件是这 2000 美元要在 Firstrade 账户内保留一年，如果一年内你有取款操作，这些交易手续费还是会追加扣除的。&lt;/p&gt;

&lt;p&gt;Firstrade 和 Scottrade 差不多，不过比 Scottrade 规模要小。每次交易手续费是 $6.95，因为老板是华人，中文支持做得还不错，在雪球有常驻账号 @Firstrade第一理财 ，有问题在雪球 @ 他就可以。和 Scottrade 一样也有免费电话回拨。这家券商周围的人用得比较多，也是雪球里活跃的投资者@许志宏 力荐的券商。&lt;/p&gt;

&lt;p&gt;貌似在 Firstrade 的期权交易权限比较容易开启，相比 Scottrade 更容易。我现在还不玩这些衍生品，未深入了解。从注册开户经历来看，我估计 IB 也会很容易。&lt;/p&gt;

&lt;p&gt;总的来说有钱人、年轻人，可以考虑选择 IB，新手可以考虑 Firstrade（90天内 250 次免费交易）和 Scottrade（两家都中文服务优秀，手续费差别不大，Scottrade 规模大些）。&lt;/p&gt;

&lt;p&gt;关于汇款，我用过建行和华夏银行的。建行有汇款模版，照着填下来即可。建行比较快，汇过两次都是上午汇出，晚上大概过了 12 个小时查 Scottrade 就已经到账了。我原本选择建行是因为建行对美国银行汇款免手续费。但是实际去汇了才发现，建行是对 Bank of American 免费，而 Scottrade 的收款账号是 U.S. Bank 的，一个美利坚银行，一个合众国银行，完全不一样。&lt;/p&gt;

&lt;p&gt;收费是千分之一加 80 元电报费，千分之一最低按 20 收取，就是最低收费 100 元。华夏银行也是千分之一最低二十，不过免了 80 元的电报费，所以能省不少钱，只是到账时间会多一两天，不急的话推荐选华夏银行。&lt;/p&gt;

&lt;p&gt;有两点注意事项所有银行都一样：&lt;/p&gt;

&lt;p&gt;第一是汇款用途，国内不允许个人向境外投资账户直接汇款注资，不过只要写成培训费就可以了。据说招行很难汇出，不过在招行可以考虑办内地香港两地一卡通账户，工行也有类似服务，我都没办过，具体不太了解，可能以后办了再写写。&lt;/p&gt;

&lt;p&gt;另外一点是境外的汇款结算手续费，选择己方支付的话你可能还得跑银行补缴手续费，选择共同承担即可，这样到账时你会发现少了一点，我用建行两次汇款一千和两千美元，都是被扣 10 美元，用华夏银行汇款一千美元，被扣 15 美元。不过算下来还是华夏银行最划算。如果不着急，用华夏银行一次汇款 3000 美元以上是最划算的。&lt;/p&gt;

&lt;p&gt;要注意 Firstrade 首次注资 2000 美元的要求，你就不能汇款 2000 美元整并选择共同承担汇款费用，要不然到时 Firstrade 里的资金会少于 2000 美元而享受不到那个优惠，我有一个同事就是这样子悲剧了。&lt;/p&gt;

&lt;p&gt;目前暂时就只能分享这些，希望过两年能分享我的美股赚钱经验哈。有什么问题的话可以到雪球网 @美股学堂 。雪球@小秘书 曾经发过一个&lt;a href=&quot;http://xueqiu.com/4226803442/21990358&quot;&gt;美股扫盲一贴通&lt;/a&gt;值得参考。如果还想了解更多关于美股投资的知识，可以来参加 i美股的&lt;a href=&quot;http://news.imeigu.com/a/1356578689174.html&quot;&gt;《i美股学堂》——美股常识讲座(1月19日北京)&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;我很幸运因为加入雪球网，一开始树立的价值投资的理念就是正确的。但总觉得有点小小的遗憾啊。年轻人有时间，输的起（只要不是借钱去输就行），多搞点投机甚至像同事 @Ricky 那样一入行搞的就是 Day Trade 也未尝不可。年纪轻轻就搞价值投资，有点像是说反正你到老年时候运动可能主要是高尔夫，那不如从年轻开始就只打高尔夫得了。年轻人，觉得多丰富自己的经历才是正经事。而且年轻人的投资收益率最大的其实是&lt;a href=&quot;http://xueqiu.com/9255413612/22550684&quot;&gt;对自己人力资源的投资&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;Updated on 2013-09-05&lt;/p&gt;

&lt;p&gt;这个文章写完放在这好几个月都还不断有人在看，我很欣慰。来更新一下。&lt;/p&gt;

&lt;p&gt;现在 Scottrade 开户更方便了，也完全不需要寄送纸质材料，只要传真或者扫描并发送 email 身份证明文件，之后在网站填写电子版 WBEN8 即可。和 IB 一样方便了。&lt;/p&gt;

&lt;p&gt;如果想注册 IB，不嫌麻烦的话，可以先告诉我你的姓名和 email 地址，然后我发送邀请链接给你。不行就算了，因为 IB 达成推荐奖励的条件非常苛刻，我几乎不指望。&lt;/p&gt;

&lt;p&gt;Updated on 2013-11-30&lt;/p&gt;

&lt;p&gt;就不帮大家推荐 IB 注册了，因为达成推荐奖励的条件非常苛刻，有兴趣的可以自己直接进入 IB 主页注册，有任何问题请 @IB盈透证券&lt;/p&gt;

&lt;h1&gt;美股开户常见问题——三经纪商聊美股开户和交易&lt;/h1&gt;

&lt;p&gt;http://xueqiu.com/talks/item/20121098&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>移动86页PPT数据之感</title>
   <link href="http://www.5wpc.info/it/career/business/2014/09/25/WirelessInternet2014DataReview"/>
   <updated>2014-09-25T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/career/business/2014/09/25/WirelessInternet2014DataReview</id>
   <content type="html">&lt;h1&gt;移动86页PPT数据之感&lt;/h1&gt;

&lt;h2&gt;美媒86页ppt预测未来：堪称最全的移动互联网PPT数据库&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;http://mp.weixin.qq.com/s?__biz=MjM5NDUzMDYyMw==&amp;amp;mid=200203007&amp;amp;idx=1&amp;amp;sn=2cde71d21a61fca2ad1281c2560dc596&amp;amp;scene=3&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;数据总结与整理的启示&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;看腾讯科技

&lt;ul&gt;
&lt;li&gt;要专业,还是要在一个圈子里&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;多多参与圈子的讨论&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;大数据时代的价值&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;利用数据优化现有产品&lt;/li&gt;
&lt;li&gt;通过新产品去创造更有意义的数据&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;移动设备的价值&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;平板的增多,很有可能是PC人们的复用&lt;/li&gt;
&lt;li&gt;更表明有很多事情是可以有更好的处理方式的,移动平台给这些事情带来了希望&lt;/li&gt;
&lt;li&gt;我们是可以创造平台,也可以在新平台到来的时候,把握时机进入&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;Android的影响&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;在中国大量的Android是没有携带google服务的&lt;/li&gt;
&lt;li&gt;由于价格的原因,打入了低端市场&lt;/li&gt;
&lt;li&gt;平台如何收费

&lt;ul&gt;
&lt;li&gt;占位费与流量费&lt;/li&gt;
&lt;li&gt;广告费&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;应用如何收费

&lt;ul&gt;
&lt;li&gt;本身价值

&lt;ul&gt;
&lt;li&gt;使用收费&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;附带价值

&lt;ul&gt;
&lt;li&gt;服务收费&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;成为平台&lt;/li&gt;
&lt;li&gt;&lt;Free&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;个人认为&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;深入圈子&lt;/li&gt;
&lt;li&gt;明确自己在其中的价值&lt;/li&gt;
&lt;li&gt;想做点事情,顺势而为&lt;/li&gt;
&lt;li&gt;物联网下,让人沉浸在Smart中&lt;/li&gt;
&lt;li&gt;在这里工作,我们的目标是集聚能量,提升自己,但也要把握时机,去做一件自己的事情&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>CodeQuality</title>
   <link href="http://www.5wpc.info/it/technical/softwareengineering/2014/09/22/CodeQuality"/>
   <updated>2014-09-22T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/technical/softwareengineering/2014/09/22/CodeQuality</id>
   <content type="html">&lt;h1&gt;CodeQuality&lt;/h1&gt;

&lt;h2&gt;代码质量的主要关注点&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;可靠性

&lt;ul&gt;
&lt;li&gt;输入问题&lt;/li&gt;
&lt;li&gt;输出问题

&lt;ul&gt;
&lt;li&gt;不完整&lt;/li&gt;
&lt;li&gt;缺失&lt;/li&gt;
&lt;li&gt;错误时刻的正确结果&lt;/li&gt;
&lt;li&gt;错误的格式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;逻辑问题

&lt;ul&gt;
&lt;li&gt;偏差为一的错误与循环迭代&lt;/li&gt;
&lt;li&gt;被忽视的极端情况&lt;/li&gt;
&lt;li&gt;被遗漏的情况,条件测试或步骤&lt;/li&gt;
&lt;li&gt;被遗漏的方法&lt;/li&gt;
&lt;li&gt;多余的功能&lt;/li&gt;
&lt;li&gt;对需求的误解&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;计算问题

&lt;ul&gt;
&lt;li&gt;不正确的算法或计算&lt;/li&gt;
&lt;li&gt;表达式中错误的操作数&lt;/li&gt;
&lt;li&gt;表达式中不正确的运算符&lt;/li&gt;
&lt;li&gt;运算符优先级问题&lt;/li&gt;
&lt;li&gt;溢出,下溢和符号转换错误&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;并行性与时序问题&lt;/li&gt;
&lt;li&gt;接口问题

&lt;ul&gt;
&lt;li&gt;不正确的例程或参数&lt;/li&gt;
&lt;li&gt;没有测试返回值&lt;/li&gt;
&lt;li&gt;未做错误探查或恢复&lt;/li&gt;
&lt;li&gt;资源泄漏&lt;/li&gt;
&lt;li&gt;面向对象功能的误用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;数据处理问题

&lt;ul&gt;
&lt;li&gt;不正确的数据初始化&lt;/li&gt;
&lt;li&gt;引用错误的数据变量&lt;/li&gt;
&lt;li&gt;越界引用&lt;/li&gt;
&lt;li&gt;不正确的下标使用&lt;/li&gt;
&lt;li&gt;不正确的比例或数据单位&lt;/li&gt;
&lt;li&gt;错误的数据打包与解包

&lt;ul&gt;
&lt;li&gt;序列化与反序列化&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;不一致的数据&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;容错

&lt;ul&gt;
&lt;li&gt;管理策略&lt;/li&gt;
&lt;li&gt;空间冗余&lt;/li&gt;
&lt;li&gt;时间冗余&lt;/li&gt;
&lt;li&gt;可复原性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;安全性

&lt;ul&gt;
&lt;li&gt;脆弱代码&lt;/li&gt;
&lt;li&gt;缓冲区溢出&lt;/li&gt;
&lt;li&gt;竞态条件&lt;/li&gt;
&lt;li&gt;问题API

&lt;ul&gt;
&lt;li&gt;容易出现缓冲区溢出的函数&lt;/li&gt;
&lt;li&gt;格式字符串漏洞&lt;/li&gt;
&lt;li&gt;路径和命令行解释器元字符漏洞&lt;/li&gt;
&lt;li&gt;临时文件&lt;/li&gt;
&lt;li&gt;不适合做加密用途的函数&lt;/li&gt;
&lt;li&gt;可篡改数据&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;不可信输入&lt;/li&gt;
&lt;li&gt;结果验证&lt;/li&gt;
&lt;li&gt;数据与特权泄漏

&lt;ul&gt;
&lt;li&gt;数据&lt;/li&gt;
&lt;li&gt;特权&lt;/li&gt;
&lt;li&gt;分离特权代码

&lt;ul&gt;
&lt;li&gt;MPI&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;木马&lt;/li&gt;
&lt;li&gt;第三方工具&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;时间性能

&lt;ul&gt;
&lt;li&gt;测试技术

&lt;ul&gt;
&lt;li&gt;负载描述&lt;/li&gt;
&lt;li&gt;受限于

&lt;ul&gt;
&lt;li&gt;IO任务&lt;/li&gt;
&lt;li&gt;内核的任务&lt;/li&gt;
&lt;li&gt;CPU的任务与剖析工具&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;算法复杂性&lt;/li&gt;
&lt;li&gt;独立的代码&lt;/li&gt;
&lt;li&gt;与操作系统交互&lt;/li&gt;
&lt;li&gt;与外设交互&lt;/li&gt;
&lt;li&gt;非故意交互&lt;/li&gt;
&lt;li&gt;缓存&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;空间性能

&lt;ul&gt;
&lt;li&gt;数据&lt;/li&gt;
&lt;li&gt;内存组织&lt;/li&gt;
&lt;li&gt;内存层级结构

&lt;ul&gt;
&lt;li&gt;主存及其高速缓存&lt;/li&gt;
&lt;li&gt;磁盘缓存和后备存储器&lt;/li&gt;
&lt;li&gt;交换区和基于文件的磁盘存储&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;进程/操作系统接口

&lt;ul&gt;
&lt;li&gt;内存分配&lt;/li&gt;
&lt;li&gt;内存映射&lt;/li&gt;
&lt;li&gt;数据映射&lt;/li&gt;
&lt;li&gt;代码映射&lt;/li&gt;
&lt;li&gt;访问硬件资源&lt;/li&gt;
&lt;li&gt;进程间通信&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;堆内存管理

&lt;ul&gt;
&lt;li&gt;堆碎片&lt;/li&gt;
&lt;li&gt;堆剖析分析&lt;/li&gt;
&lt;li&gt;内存泄漏&lt;/li&gt;
&lt;li&gt;垃圾回收&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;栈内存管理

&lt;ul&gt;
&lt;li&gt;栈帧&lt;/li&gt;
&lt;li&gt;栈空间&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;代码

&lt;ul&gt;
&lt;li&gt;设计&lt;/li&gt;
&lt;li&gt;编码&lt;/li&gt;
&lt;li&gt;构建&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;可移植性

&lt;ul&gt;
&lt;li&gt;操作系统间&lt;/li&gt;
&lt;li&gt;硬件与处理器架构

&lt;ul&gt;
&lt;li&gt;数据类型的属性&lt;/li&gt;
&lt;li&gt;数据存储&lt;/li&gt;
&lt;li&gt;特定于机器的代码&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;编译器与语言扩展

&lt;ul&gt;
&lt;li&gt;编译器错误&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;图形用户界面GUI&lt;/li&gt;
&lt;li&gt;国际化与本地化

&lt;ul&gt;
&lt;li&gt;字符集&lt;/li&gt;
&lt;li&gt;区域&lt;/li&gt;
&lt;li&gt;消息&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;可维护性

&lt;ul&gt;
&lt;li&gt;测量可维护性

&lt;ul&gt;
&lt;li&gt;相关指数&lt;/li&gt;
&lt;li&gt;OO的度量&lt;/li&gt;
&lt;li&gt;包相关性度量&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;可分析性

&lt;ul&gt;
&lt;li&gt;一致性&lt;/li&gt;
&lt;li&gt;表达式格式化&lt;/li&gt;
&lt;li&gt;语句格式化&lt;/li&gt;
&lt;li&gt;命名惯例&lt;/li&gt;
&lt;li&gt;语句级注释&lt;/li&gt;
&lt;li&gt;版本注释&lt;/li&gt;
&lt;li&gt;视觉结构: 块与缩进&lt;/li&gt;
&lt;li&gt;表达式,函数以及方法的长度&lt;/li&gt;
&lt;li&gt;控制结构&lt;/li&gt;
&lt;li&gt;布尔表达式&lt;/li&gt;
&lt;li&gt;可辨认性与内聚性&lt;/li&gt;
&lt;li&gt;依赖和耦合&lt;/li&gt;
&lt;li&gt;代码块注释&lt;/li&gt;
&lt;li&gt;数据声明注释&lt;/li&gt;
&lt;li&gt;恰当的标识符名字&lt;/li&gt;
&lt;li&gt;依赖的位置&lt;/li&gt;
&lt;li&gt;不确定性&lt;/li&gt;
&lt;li&gt;可复查性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;可变化&lt;/li&gt;
&lt;li&gt;稳定性

&lt;ul&gt;
&lt;li&gt;封装与数据隐藏&lt;/li&gt;
&lt;li&gt;数据抽象&lt;/li&gt;
&lt;li&gt;类型检查&lt;/li&gt;
&lt;li&gt;编译时断言&lt;/li&gt;
&lt;li&gt;运行时检查和查看时断言&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;可测试性

&lt;ul&gt;
&lt;li&gt;单元测试&lt;/li&gt;
&lt;li&gt;集成测试&lt;/li&gt;
&lt;li&gt;系统测试&lt;/li&gt;
&lt;li&gt;测试覆盖度分析&lt;/li&gt;
&lt;li&gt;偶发性测试&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;开发环境的影响

&lt;ul&gt;
&lt;li&gt;增量构建&lt;/li&gt;
&lt;li&gt;调整构建性能&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;浮点运算

&lt;ul&gt;
&lt;li&gt;浮点数表示

&lt;ul&gt;
&lt;li&gt;量度误差&lt;/li&gt;
&lt;li&gt;舍入&lt;/li&gt;
&lt;li&gt;内存格式&lt;/li&gt;
&lt;li&gt;规格化和隐含的一位&lt;/li&gt;
&lt;li&gt;阶码偏移&lt;/li&gt;
&lt;li&gt;负数&lt;/li&gt;
&lt;li&gt;反向规格化数&lt;/li&gt;
&lt;li&gt;特殊值&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;舍入&lt;/li&gt;
&lt;li&gt;溢出&lt;/li&gt;
&lt;li&gt;下溢&lt;/li&gt;
&lt;li&gt;消去&lt;/li&gt;
&lt;li&gt;合并&lt;/li&gt;
&lt;li&gt;无效运算&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;代码质量的参考资料&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;代码质量 http://book.douban.com/subject/2342995/&lt;/li&gt;
&lt;li&gt;相关支持工具

&lt;ul&gt;
&lt;li&gt;静态代码分析工具

&lt;ul&gt;
&lt;li&gt;checkstyle&lt;/li&gt;
&lt;li&gt;findbug&lt;/li&gt;
&lt;li&gt;PMD&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;自动重构工具&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>TheDesignOfDesign</title>
   <link href="http://www.5wpc.info/it/technical/design/2014/09/21/TheDesignOfDesign"/>
   <updated>2014-09-21T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/technical/design/2014/09/21/TheDesignOfDesign</id>
   <content type="html">&lt;h1&gt;TheDesignOfDesign&lt;/h1&gt;

&lt;h2&gt;tags: DesignPattern&lt;/h2&gt;

&lt;h2&gt;设计面面观&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;用户模型--错误胜过含糊&lt;/li&gt;
&lt;li&gt;约束是我们的朋友&lt;/li&gt;
&lt;li&gt;技术设计中的美学与风格

&lt;ul&gt;
&lt;li&gt;何谓逻辑美

&lt;ul&gt;
&lt;li&gt;简约&lt;/li&gt;
&lt;li&gt;结构清晰&lt;/li&gt;
&lt;li&gt;一致性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;什么才是好的计算机架构

&lt;ul&gt;
&lt;li&gt;导出原则&lt;/li&gt;
&lt;li&gt;正交性&lt;/li&gt;
&lt;li&gt;适宜性&lt;/li&gt;
&lt;li&gt;普遍性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;技术设计中的风格&lt;/li&gt;
&lt;li&gt;如何获取良好的风格

&lt;ul&gt;
&lt;li&gt;有目的的去学习其他设计者的风格&lt;/li&gt;
&lt;li&gt;做出有意识的判断&lt;/li&gt;
&lt;li&gt;练习&lt;/li&gt;
&lt;li&gt;修正&lt;/li&gt;
&lt;li&gt;仔细选择设计者&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;设计原本&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Frederick P. Brooks, Jr.&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;设计的模型&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;理性模型

&lt;ul&gt;
&lt;li&gt;What

&lt;ul&gt;
&lt;li&gt;组成

&lt;ul&gt;
&lt;li&gt;目标&lt;/li&gt;
&lt;li&gt;必要条件&lt;/li&gt;
&lt;li&gt;效用/有用性 函数&lt;/li&gt;
&lt;li&gt;约束&lt;/li&gt;
&lt;li&gt;资源分配,预算,关键预算&lt;/li&gt;
&lt;li&gt;设计树&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;好处

&lt;ul&gt;
&lt;li&gt;将设计工作工程化&lt;/li&gt;
&lt;li&gt;分阶段处理&lt;/li&gt;
&lt;li&gt;为一般人员指明了每个步骤&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;主要缺陷

&lt;ul&gt;
&lt;li&gt;无法在初始阶段知道目标&lt;/li&gt;
&lt;li&gt;决策树一边设计一边探索&lt;/li&gt;
&lt;li&gt;设计树上的节点实际上不是设计决策,而是设计暂定方案&lt;/li&gt;
&lt;li&gt;有用性函数无法以增量方式求值&lt;/li&gt;
&lt;li&gt;必要条件及其权重在持续变化&lt;/li&gt;
&lt;li&gt;约束在持续变化&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;共同演化模型&lt;/li&gt;
&lt;li&gt;Raymond的集市模型&lt;/li&gt;
&lt;li&gt;Boehm的螺旋模型&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;协作与远程协作&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;协作设计

&lt;ul&gt;
&lt;li&gt;团队设计是现代标准

&lt;ul&gt;
&lt;li&gt;技术复杂性&lt;/li&gt;
&lt;li&gt;快速推向市场&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;协作的成本

&lt;ul&gt;
&lt;li&gt;分割成本&lt;/li&gt;
&lt;li&gt;学习与教授成本&lt;/li&gt;
&lt;li&gt;设计中的沟通成本&lt;/li&gt;
&lt;li&gt;变更控制&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;关键挑战是概念完整性

&lt;ul&gt;
&lt;li&gt;如何获取概念完整性

&lt;ul&gt;
&lt;li&gt;系统架构需要统一&lt;/li&gt;
&lt;li&gt;需要一名用户界面设计师&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;协作的利弊

&lt;ul&gt;
&lt;li&gt;利益

&lt;ul&gt;
&lt;li&gt;确定利益相关人的需求和愿望&lt;/li&gt;
&lt;li&gt;建立目标&lt;/li&gt;
&lt;li&gt;概念探索

&lt;ul&gt;
&lt;li&gt;头脑风暴&lt;/li&gt;
&lt;li&gt;形成竞争机制&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;设计复查&lt;/li&gt;
&lt;li&gt;利用图形展示&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;无用的地方

&lt;ul&gt;
&lt;li&gt;对于设计协作的幻想式概念&lt;/li&gt;
&lt;li&gt;并非协作设计的方式&lt;/li&gt;
&lt;li&gt;在哪里进行设计 控制&lt;/li&gt;
&lt;li&gt;概念设计尤其不应该协作&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>GoPackageBuiltin</title>
   <link href="http://www.5wpc.info/it/technical/language/go/2014/09/19/GoPackageBuiltin"/>
   <updated>2014-09-19T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/technical/language/go/2014/09/19/GoPackageBuiltin</id>
   <content type="html">&lt;h1&gt;GoPackageBuiltin&lt;/h1&gt;

&lt;h2&gt;Constants&lt;/h2&gt;

&lt;h2&gt;Variables&lt;/h2&gt;

&lt;h2&gt;func&lt;/h2&gt;

&lt;h2&gt;type&lt;/h2&gt;
</content>
 </entry>
 
 <entry>
   <title>FileOrientedProgramming</title>
   <link href="http://www.5wpc.info/it/technical/design/2014/09/19/FileOrientedProgramming"/>
   <updated>2014-09-19T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/technical/design/2014/09/19/FileOrientedProgramming</id>
   <content type="html">&lt;h1&gt;FileOrientedProgramming&lt;/h1&gt;

&lt;h2&gt;涉及API&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;path

&lt;ul&gt;
&lt;li&gt;filepath&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;io&lt;/li&gt;
&lt;li&gt;filesystem API

&lt;ul&gt;
&lt;li&gt;http://en.wikipedia.org/wiki/File_system_API&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;Linux API&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;http://book.douban.com/subject/1241402/&lt;/li&gt;
&lt;li&gt;整体层次

&lt;ul&gt;
&lt;li&gt;RAID&lt;/li&gt;
&lt;li&gt;LVM&lt;/li&gt;
&lt;li&gt;Linux VFS&lt;/li&gt;
&lt;li&gt;FileSystem

&lt;ul&gt;
&lt;li&gt;ext2&lt;/li&gt;
&lt;li&gt;JFS&lt;/li&gt;
&lt;li&gt;ReiserFS&lt;/li&gt;
&lt;li&gt;XFS&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;主要功能

&lt;ul&gt;
&lt;li&gt;创建与删除文件

&lt;ul&gt;
&lt;li&gt;分配和取消存储媒体上的空间&lt;/li&gt;
&lt;li&gt;资源的管理&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Read/Write&lt;/li&gt;
&lt;li&gt;Search&lt;/li&gt;
&lt;li&gt;Close&lt;/li&gt;
&lt;li&gt;mkdir&lt;/li&gt;
&lt;li&gt;ls dir&lt;/li&gt;
&lt;li&gt;rm file from dir&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;为性能而生的缓冲区&lt;/li&gt;
&lt;li&gt;文件系统中的对象与API

&lt;ul&gt;
&lt;li&gt;文件

&lt;ul&gt;
&lt;li&gt;struct fown_stuct&lt;/li&gt;
&lt;li&gt;struct file&lt;/li&gt;
&lt;li&gt;API

&lt;ul&gt;
&lt;li&gt;llseek&lt;/li&gt;
&lt;li&gt;read&lt;/li&gt;
&lt;li&gt;write&lt;/li&gt;
&lt;li&gt;readdir&lt;/li&gt;
&lt;li&gt;poll&lt;/li&gt;
&lt;li&gt;ioctl&lt;/li&gt;
&lt;li&gt;mmap&lt;/li&gt;
&lt;li&gt;open&lt;/li&gt;
&lt;li&gt;flush&lt;/li&gt;
&lt;li&gt;release&lt;/li&gt;
&lt;li&gt;fsync&lt;/li&gt;
&lt;li&gt;fasync&lt;/li&gt;
&lt;li&gt;check_media_change&lt;/li&gt;
&lt;li&gt;revalidate&lt;/li&gt;
&lt;li&gt;lock&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;信息节点

&lt;ul&gt;
&lt;li&gt;struct inode&lt;/li&gt;
&lt;li&gt;API

&lt;ul&gt;
&lt;li&gt;default_file_ops&lt;/li&gt;
&lt;li&gt;create&lt;/li&gt;
&lt;li&gt;lookup&lt;/li&gt;
&lt;li&gt;link&lt;/li&gt;
&lt;li&gt;unlink&lt;/li&gt;
&lt;li&gt;symlink&lt;/li&gt;
&lt;li&gt;mkdir&lt;/li&gt;
&lt;li&gt;rmdir&lt;/li&gt;
&lt;li&gt;mknod&lt;/li&gt;
&lt;li&gt;rename&lt;/li&gt;
&lt;li&gt;readlink&lt;/li&gt;
&lt;li&gt;follow_link&lt;/li&gt;
&lt;li&gt;get_block&lt;/li&gt;
&lt;li&gt;readpage&lt;/li&gt;
&lt;li&gt;writepage&lt;/li&gt;
&lt;li&gt;flushpage&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;文件系统

&lt;ul&gt;
&lt;li&gt;struct file_system_type&lt;/li&gt;
&lt;li&gt;API

&lt;ul&gt;
&lt;li&gt;register_filesystem&lt;/li&gt;
&lt;li&gt;unregister_filesystem&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;名称/dentry

&lt;ul&gt;
&lt;li&gt;struct qstr&lt;/li&gt;
&lt;li&gt;struct dentry&lt;/li&gt;
&lt;li&gt;API

&lt;ul&gt;
&lt;li&gt;d_revalidate&lt;/li&gt;
&lt;li&gt;d_hash&lt;/li&gt;
&lt;li&gt;d_compare&lt;/li&gt;
&lt;li&gt;d_delete&lt;/li&gt;
&lt;li&gt;d_release&lt;/li&gt;
&lt;li&gt;d_iput&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;主要的性能问题

&lt;ul&gt;
&lt;li&gt;目标

&lt;ul&gt;
&lt;li&gt;减少基本设备上的IO数量&lt;/li&gt;
&lt;li&gt;将小型IO组合成大型IO&lt;/li&gt;
&lt;li&gt;优化搜索模式, 减少等待磁盘搜索所花的时间&lt;/li&gt;
&lt;li&gt;缓存尽可能多的数据, 以减少物理IO&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;事务体系

&lt;ul&gt;
&lt;li&gt;记录事务的开始&lt;/li&gt;
&lt;li&gt;在更改数据之前记录将要更改的数据&lt;/li&gt;
&lt;li&gt;从存储库中访问数据库记录&lt;/li&gt;
&lt;li&gt;对数据的不同操作&lt;/li&gt;
&lt;li&gt;在更改数据之后记录已经做了更改的数据&lt;/li&gt;
&lt;li&gt;记录事务的结束&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;tags: DesignPattern IO&lt;/h2&gt;

&lt;h2&gt;FileSystem&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;http://en.wikipedia.org/wiki/File_system&lt;/li&gt;
&lt;li&gt;文件系统涉及的主要方面

&lt;ul&gt;
&lt;li&gt;存储空间管理&lt;/li&gt;
&lt;li&gt;文件名称管理&lt;/li&gt;
&lt;li&gt;目录管理&lt;/li&gt;
&lt;li&gt;META元数据管理&lt;/li&gt;
&lt;li&gt;文件数据&lt;/li&gt;
&lt;li&gt;UI&lt;/li&gt;
&lt;li&gt;基础工具&lt;/li&gt;
&lt;li&gt;权限管理

&lt;ul&gt;
&lt;li&gt;permission&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;数据完整可信

&lt;ul&gt;
&lt;li&gt;数据持久化与一致性&lt;/li&gt;
&lt;li&gt;operation log&lt;/li&gt;
&lt;li&gt;错误修复&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;多文件系统共存

&lt;ul&gt;
&lt;li&gt;支持硬盘分区&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;FS API&lt;/li&gt;
&lt;li&gt;设计限制/规格

&lt;ul&gt;
&lt;li&gt;例如:最大文件大小,maxfilenamelength&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;主要的类型

&lt;ul&gt;
&lt;li&gt;Disk

&lt;ul&gt;
&lt;li&gt;有日志文件系统,版本文件系统&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;光盘&lt;/li&gt;
&lt;li&gt;Flash&lt;/li&gt;
&lt;li&gt;磁带&lt;/li&gt;
&lt;li&gt;数据库&lt;/li&gt;
&lt;li&gt;事务文件系统&lt;/li&gt;
&lt;li&gt;网络文件系统

&lt;ul&gt;
&lt;li&gt;SMB&lt;/li&gt;
&lt;li&gt;NFS&lt;/li&gt;
&lt;li&gt;AFS&lt;/li&gt;
&lt;li&gt;FTP&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;共享磁盘文件系统&lt;/li&gt;
&lt;li&gt;特殊文件系统&lt;/li&gt;
&lt;li&gt;设备文件系统&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;泛化价值&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;由于系统体系结构的抽象

&lt;ul&gt;
&lt;li&gt;利用面对文件的编程扩展到面向IPC/信息通信与存储的基本方式上&lt;/li&gt;
&lt;li&gt;所有针对通信/信息存储的方式均与文件API类似(数据库系统除外)&lt;/li&gt;
&lt;li&gt;主要关注点

&lt;ul&gt;
&lt;li&gt;一般API接口&lt;/li&gt;
&lt;li&gt;性能提升方法

&lt;ul&gt;
&lt;li&gt;NIO&lt;/li&gt;
&lt;li&gt;同步与异步&lt;/li&gt;
&lt;li&gt;缓存&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>Go 语言 Package 学习计划</title>
   <link href="http://www.5wpc.info/it/technical/language/go/2014/09/09/packages"/>
   <updated>2014-09-09T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/technical/language/go/2014/09/09/packages</id>
   <content type="html">&lt;p&gt;基于目前已经完成的项目, 将已经涉及使用的库进行再学习.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;built-in&lt;/li&gt;
&lt;li&gt;testing&lt;/li&gt;
&lt;li&gt;log&lt;/li&gt;
&lt;li&gt;fmt&lt;/li&gt;
&lt;li&gt;sort&lt;/li&gt;
&lt;li&gt;strings&lt;/li&gt;
&lt;li&gt;filepath&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>Go 语言介绍 第一部分</title>
   <link href="http://www.5wpc.info/it/technical/language/go/2014/09/08/introduction_to_golang"/>
   <updated>2014-09-08T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/technical/language/go/2014/09/08/introduction_to_golang</id>
   <content type="html">&lt;p&gt;本文是对&lt;a href=&quot;http://www.zhubert.com/blog/2014/01/12/introduction-to-go-golang-part-1/&quot;&gt;introduction-to-go-golang-part-1&lt;/a&gt;的翻译&lt;/p&gt;

&lt;p&gt;作者作为一个长期从事Web后端开发的工程师, 对Go语言有系统开发人员的具体认识.
Go语言的设计重点是: 解决软件工程中遇见的问题, 从工程上提升软件质量与开发效率&lt;/p&gt;

&lt;p&gt;总体上说, Go语言有如下特点让作者称赞.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;专注于解决开发效率问题:

&lt;ul&gt;
&lt;li&gt;减少编译时间&lt;/li&gt;
&lt;li&gt;去掉显示关联, 降低模块间耦合&lt;/li&gt;
&lt;li&gt;利用静态语言特性, 提高性能&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;专注于解决现代编程中见到的问题:

&lt;ul&gt;
&lt;li&gt;并行编程: CSP模型&lt;/li&gt;
&lt;li&gt;强大的基础库支持&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;简化语言内在复杂性

&lt;ul&gt;
&lt;li&gt;语法关键字少: 只有25个&lt;/li&gt;
&lt;li&gt;添加了GC&lt;/li&gt;
&lt;li&gt;利用组合取代继承&lt;/li&gt;
&lt;li&gt;通过CSP模型简化目前常用的信号量锁等机制&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Go语言介绍 第一部分&lt;/h1&gt;

&lt;p&gt;If you read this blog for any amount of time you’ll know that I really like technology, specifically web development technologies. I’ve written about my experiences with Ruby on Rails, Batman, and a few curiosities along the way.&lt;/p&gt;

&lt;p&gt;如果你经常阅读本网站的blog, 你会发现作者是一个技术爱好者, 特别是WEB开发技术.
作者在blog中谈论过自己在进行RoR, Batman等很多有意思的技术文章.&lt;/p&gt;

&lt;p&gt;But my last post was something different, it was about Go. In a lot of ways it was the culmination of a journey, without trying to sound too weird, it was also the start of one.&lt;/p&gt;

&lt;p&gt;但是作者最近的一些涉及Go语言的文章表现了一些风格的变化.
这是一段不同的技术旅程, 是一个看起来奇怪的开始.&lt;/p&gt;

&lt;p&gt;Normally I don’t write about something until I feel like I have a decent grasp on it. So even though I started looking at Go over a year ago, I didn’t write anything about those experiences. At the beginning I was tempted to write about how Go was missing certain things…but that would’ve been premature. Now having used it for a bit longer, I understand it a lot better, though I still consider myself a novice and will likely be embarrassed about these posts in a few months (the perils of learning).&lt;/p&gt;

&lt;p&gt;一般情况下, 作者在没有对一个事物有足够的认识前, 不会在文章中过多地讨论一些东西.
因此, 作者已经学习与了解go语言一年多了, 但并没有写文章对于这段开发经验进行讨论.
在开始的时候, 作者想讨论下Go语言在很多设计上的关键不足与问题, 但越发深入地使用后, 才发现原先的很多认识很片面.
在更加深入地学习与使用go语言后, 作者的理解更深刻, 也发现了以前对于Go语言的讨论存在问题.&lt;/p&gt;

&lt;p&gt;So now that I’ve taken a few more steps, I’m ready to write about getting started, so that other people coming from a similar background could skip the confusion and go straight to the good stuff….enjoying Go for the awesome language that it is today. So let’s get started!&lt;/p&gt;

&lt;p&gt;因此, 作者准备写一系列的文章对Go语言进行讨论, 从入手使用到深入运用的各个阶段.
通过文章描述, 希望可以让具有类似开发经验的人们, 可以避开一些go语言的理解困惑, 把握go语言的优点与方便.
通过文章阅读, 可以充分体会这门语言的美丽与精妙.
让我们开始吧!&lt;/p&gt;

&lt;h2&gt;Go的不同之处&lt;/h2&gt;

&lt;p&gt;Go is not what you think it is. It is not Java, It is not Ruby. It is not trying to be a language theorist’s dream. Go is not about type hierarchies. It is not about object-oriented programming or functional programming. Honestly, it has little to recommend it if you’re looking for something fashionable with all the buzzwords attached.&lt;/p&gt;

&lt;p&gt;Go 语言并不是大家所想象的那样, 它不是Java不是Ruby.
它并不想成为编程语言研究者的梦想.
它不支持面对对象中的继承, 也不是一门面对对象/函数式语言.
老实说, GO语言并不是一门大家希望寻找的有趣又时髦的语言.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        Go’s purpose is therefore not to do research into programming language design; it is to improve the working environment for its designers and their coworkers. Go is more about software engineering than programming language research. Or to rephrase, it is about language design in the service of software engineering.
            Rob Pike Go at Google

    Go 语言并不是一门用于编程语言研究的语言, 而是一门便于开发与设计者用于改善现有工作环境中问题的编程语言.
    Go 语言的主要定位是软件工程而不是编程语言研究.
    换句话说, 就是Go语言是一门用于服务软件工程的语言.

            Rob Pike Go at Google
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But Go is awesome, and you can get a lot done with it…you just have to learn it first. It’s tempting to approach new languages from the mindset of another language, but that will be most unhelpful here. It’s the easiest course to take…map a keyword from one language to the keyword of another, like a big Rosetta stone, but you will get frustrated pretty quickly. So before you do that, let’s look at where Go came from.&lt;/p&gt;

&lt;p&gt;但是Go语言是可以用于做很多事情的一门很棒的语言.
你需要做的就是开始学习Go.
不过一般的开发者都会用以前其它语言的经验来臆断Go语言,
就像一块很大的罗塞塔石碑, 简单地将其它语言的keyword放在Go上面.
这样的话, 学习都很容易产生困惑.
因此在你准备这样做之前, 请先整体了解下Go的设计理念.&lt;/p&gt;

&lt;h2&gt;Go的起源&lt;/h2&gt;

&lt;p&gt;Being from a Physics background, I think it helps to start with first principles, so all the derivations make sense. Stated another way, Go was designed to solve a particular problem and the more we understand that, the more various design decisions will make sense.&lt;/p&gt;

&lt;p&gt;每个东西的产生都有其原因和环境.
从这个角度看, Go语言的设计是用于解决一定范围的问题.
如果我们对这些问题了解的越多, 我们就越发能体会到其中设计的原因.&lt;/p&gt;

&lt;p&gt;The creation myth of Go is something like this: Rob Pike, Ken Thompson, and Robert Griesemer were waiting for a particularly long C++ build to take place when they decided to theorize a new language. What started on a whiteboard in 2007, shortly thereafter turned into a specification, which then was open sourced in 2009 with two compiler implementations. The article Go at Google: Language Design in the Service of Software Engineering provides an excellent overview of these things.&lt;/p&gt;

&lt;p&gt;Go语言的产生背景大致是这样的:
Rob Pike, Ken Thompson, 和 Robert Griesemer 在研究了C++语言的发展变化后, 他们决定构建一个新语言. 2007年, 他们将一些想法整理成了Go语言的主要特性, 在2009年, 他们对外开源了2个Go语言的编译器.&lt;/p&gt;

&lt;p&gt;From this origin, we can discern a few problems that were explicitly set out to be solved by Go.&lt;/p&gt;

&lt;p&gt;从这个原因, 我们将看到Go语言准备解决的具体问题.&lt;/p&gt;

&lt;h2&gt;问题一: 开发效率问题&lt;/h2&gt;

&lt;p&gt;The bane of compiled languages and the siren’s song of intepreted languages, slow builds are enough to drive anyone crazy. Once the build is slow enough, developer productivity goes out the window, as even simple changes can take forever to materialize. But optimizing for developer happiness (in the form of a fast dev cycle) generally has meant slow performance for the million or billion times that the code gets run in production. It’s a painful tradeoff.&lt;/p&gt;

&lt;p&gt;如同毒一样的编译型语言与如同海妖之歌的解释型语言, 在编译构建阶段, 都是可以慢地让人发疯.
在编译很慢的时候, 开发人员可以到窗外转一圈, 一些简单地修改都需要大量的编译时间.
如果简单地对编译时间进行优化, 又会导致程序在使用过程中性能下降.
编译速度与运行速度是需要做一个平衡的.&lt;/p&gt;

&lt;p&gt;Go enters the picture as a great compromise in this regard. The compiled code is super fast (see previous post) and the build times are negligible. Massive projects still have subsecond build times. How does it do it?&lt;/p&gt;

&lt;p&gt;Go语言就是准备解决这个问题. 一方面, 其产生的程序运行速度很快, 另一方面, 其占用的编译时间是很少的.
很大的项目在编译上的花费也就是几秒.
这是如何做到的?&lt;/p&gt;

&lt;p&gt;Well, let’s take the often complained about decision to have unused imports throw compile errors. This is intrinsic with this desire to go fast! The experience of the language designers on huge projects taught them that unnecessary includes resulted in ridiculous extraneous I/O during builds while imports would be included thousands of extra times. Throwing the error then is a friendly reminder from the compiler to take that trash out of your code so you can go fast.&lt;/p&gt;

&lt;p&gt;目前大家讨论与抱怨比较多的是, Go语言在发现不必要的import时会提示错误.
这是在编译期速度快的一个原因.
一些有经验的开发者发现在很多大型项目中, 如果一个程序源代码大量无效引用了外部文件,
会导致编译期大量的IO操作, 这样就导致了编译期大量的时间浪费.
目前这种设计: 在发现无效import时报错, 对于开发者是很好的帮助, 另一方面又可以优化编译时间.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    The construction of a single C++ binary at Google can open and read hundreds of individual header files tens of thousands of times. In 2007, build engineers at Google instrumented the compilation of a major Google binary. The file contained about two thousand files that, if simply concatenated together, totaled 4.2 megabytes. By the time the #includes had been expanded, over 8 gigabytes were being delivered to the input of the compiler, a blow-up of 2000 bytes for every C++ source byte.
    Rob Pike Go at Google

    在google, 一个独立的C++二进制程序在构建过程中一般会引用读取数万个独立的头文件.
    在2007年, Google的构建工程师统计发现, 一般一个二进制程序会包含近两千文件, 如果简单的合并起来, 总共有4.2M. 如果将所有的include文件全部展开,有将近8G的文件将进入编译器.
    平均源代码的每byte就有近2000bytes的占用.

        Rob Pike Go at Google
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is also connected to the decision to not declare implements explicitly for interfaces. If you have to type implements in all the spots that an interface is satisfied, that also means you have to include the “header” of the place where that interface is defined…once again, many more includes which would slow down the builds. Implicit satisfication of interfaces also results in more flexible code, which is itself more resilient to change, delaying interface ossification as long as possible (which is a good thing!).&lt;/p&gt;

&lt;p&gt;另一方面, 为了减少引用, 每个结构没有必要显式声明其实现的具体接口.
如果按java的方式, 每个接口都显式地声明其需要实现的接口, 一方面增加了代码模块间的依赖关系;
另一方面, 这种显式的引用导致了大量的编译时间浪费.
如果接口发生变化, 会要求各实现模块完整实现各模块.&lt;/p&gt;

&lt;p&gt;If you didn’t know the above, you might be tempted to complain, “why do I have to add and delete the fmt package for debugging, how annoying!”, when in fact the language is preventing you from slowing down your builds. It isn’t intuitive, since we’ve become used to these very language “features” which ultimately undermine larger projects.&lt;/p&gt;

&lt;p&gt;如果开发者不了解上面这些设计原则, 就会抱怨&quot;为何需要将用于调试的fmt模块进行删除, 太麻烦了&quot;,
而实际是为了帮助开发者提升编译效率.
这种特性也非常有助于大型项目的开发.&lt;/p&gt;

&lt;p&gt;As this is the Internet, I feel compelled to throw in the YMMV caveat. If you know the gotchas of whatever language you’ve been using for years, you’ll be able to avoid many things simply due to your skill. I think Go helps the average developer not make these sort of mistakes (because they are compile errors). An important distiction to keep in mind, and one coherent with the language designers’ goals.&lt;/p&gt;

&lt;p&gt;在互联网时代, .
如果你以前使用的很多语言, 你将在开发中发现很多问题.
我认为Go语言的这个特性帮助程序员忽略很多错误.
这也是Go语言的设计目标与初衷.&lt;/p&gt;

&lt;h2&gt;问题二: 现代化&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;    The computing landscape today is almost unrelated to the environment in which the languages being used, mostly C++, Java, and Python, had been created. The problems introduced by multicore processors, networked systems, massive computation clusters, and the web programming model were being worked around rather than addressed head-on.

    Rob Pike Go at Google

    在现代编程环境中, 已经有大量的现代编程语言出现与使用, 例如 C++, Java, Python, 但目前的问题已经不再是编程语言的选择上了.
    目前的问题已经成为: 多核心, 网络系统, 大计算集群 与 Web开发编程模型, 而不再是原先的基于地址的简单编程.

    Rob Pike Go at Google
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;C++ 1979. Python 1989. Java 1990. Ruby 1993. Let’s face it…that’s more than a few internet years. As a computer guy, I’m confident we could do our jobs with any sane language (having worked in Fortran77 for a short while, I can attest that you can build stuff with almost any tool), but the question of suitability of a language for a particular task should be considered.&lt;/p&gt;

&lt;p&gt;在过去的一些年, 有大量的编程语言产生, 这些数量的语言如果互联网络时代一样, 繁花似锦. 1979 C++, 1989 Python, 1990 Java, 1993 Ruby.
作为一个程序员, 其它用什么语言完成任务都是可以的.
不过从合适度上, 目前的问题已经成为找到一门合理的语言快速有效地完成工作.&lt;/p&gt;

&lt;p&gt;How does that play out? For Go, I’d reference the concurrency model and it’s standard library. I want to write more about these in depth, so a brief aside will have to suffice here.&lt;/p&gt;

&lt;p&gt;Go语言的现代特性主要是并行化支持与强大的标准库.
作者已经在这方面写了很多文章, 这里仅简单地介绍下.&lt;/p&gt;

&lt;h3&gt;并行&lt;/h3&gt;

&lt;p&gt;Let’s say you want to decompose a linear process into a concurrent one…one which can be parallelized if the running environment were to permit it. In Go, it’s this easy:&lt;/p&gt;

&lt;p&gt;我们目前来简单演示下如何将一个线性处理过程转成并行.&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/qianjigui/7f60d0b16dbe3b7445e0.js&quot;&gt;&lt;/script&gt;


&lt;p&gt;Now, there a many approaches to concurrency but they can be notoriously difficult to reason about. If you have had to debug a deadlock with mutexes, you don’t need me to elaborate on this. Go’s approach results in code that is easily understood as it can be reasoned about like a sequential program. That’s a huge plus.&lt;/p&gt;

&lt;p&gt;现在, 目前已经有很多并行编程的方法, 但是都很难编写与设计.
如果你正在调试一个信号量的死锁问题, 你目前已经没有很好的调试方法.
Go语言在这方面的设计就更容易让开发者理解, 你可以像串行编程一样进行开发.
这可以说是Go语言的强大扩展.&lt;/p&gt;

&lt;p&gt;If this is your first foray into CSP, I recommend reading the original CSP paper by Hoare. It’s epic. If a video is more your thing, try Rob Pike’s talk: Concurrency is not Parallelism.&lt;/p&gt;

&lt;p&gt;如果这是你第一次接触CSP, 我建议你认真了解下由Hoare编写的CSP的相关文章.
如果有兴趣可以详细看到这个视频.&lt;/p&gt;

&lt;h3&gt;强大的标准库&lt;/h3&gt;

&lt;p&gt;The Go developers like to describe the standard library as a “batteries-included” library. What I think they mean by that is if you spin up a simple webserver like so:&lt;/p&gt;

&lt;p&gt;Go语言开发者需要将标准库看到一组增量工具库.
作者认为他们可能是觉得实现一个功能可以很简单地搭建展开.
例如如下的这个web服务:&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/qianjigui/1a91e6e5e1ed39dafffb.js&quot;&gt;&lt;/script&gt;


&lt;p&gt;&lt;/p&gt;

&lt;p&gt;that it will actually be awesome from the start (I’d say “webscale” but then I couldn’t finish writing the article for humilitation). This leads to one source of confusion for newbies who immediately ask for the “Ruby on Rails” of Go. There are plenty of great libraries that build upon the strong foundations of the Standard Library, but you can get away without having to use them. I admit, it was really weird for me at first that I could use a standard library and not a diadem-full of Gems to build something.&lt;/p&gt;

&lt;p&gt;这就导致了一些开发者会有为何没有如同RoR的开发库.
其实在Go语言中, 有很多基于Go语言富强大的基础设施标准库上面的的框架库, 但是你可以在不需要这些扩展库的情况下通过基础设施简单地构建出来.
作者说, 在使用Go语言进行开发时, 通过简单库构建功能业务是件让人很开心的事情.&lt;/p&gt;

&lt;p&gt;Ok, well I want to cover those again in the future, so for now, that will have to suffice.&lt;/p&gt;

&lt;p&gt;好了, 先讨论到这里, 关于Go语言的现代性, 作者会在后续的文章中详细谈到.&lt;/p&gt;

&lt;h2&gt;问题三: 复杂性&lt;/h2&gt;

&lt;p&gt;Finally, I think the Go designers wanted to keep the language simple (simple in the usual definition of simple).&lt;/p&gt;

&lt;p&gt;最后呢, 作者认为Go语言的设计者希望将语言设计的简单(在语言定义与使用上简单).&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;How many loop keywords are there? 1 for&lt;/li&gt;
&lt;li&gt;Why Garbage Collection? Because it’s easier while working with concurrency.&lt;/li&gt;
&lt;li&gt;Why eliminate inheritance? Because it’s inflexible to change and composition is almost always better.&lt;/li&gt;
&lt;li&gt;How many keywords? 25. vs 50 in Java and 48 in C++ Expressiveness of Go&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Why CSP model for concurrency? Because mutexes and locking are a hard paradigm to get right.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;只有1种描述循环的关键字: for&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;有GC特性, 便于并行编程的数据生命周期控制&lt;/li&gt;
&lt;li&gt;为何去掉&lt;strong&gt;继承&lt;/strong&gt;? 因为对扩展性不好, 取而代之的是&lt;strong&gt;组合&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;仅有25个关键字: java中是50, C++是48&lt;/li&gt;
&lt;li&gt;为何选用CSP模型用于并行开发? 因为信号量与锁非常难管理&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Another way to see this is you can sit down and read the Language Specification in one sitting and have it all in your working memory. The concepts are “simple” enough that this is a feasible task. It’s actually really cool…one, that there is a language spec…nudge nudge…but primarily that it’s written in such comprehensible terms. I’ve had serveral sittings by the fire with the spec in one hand and a Lagavulin 16 in the other…and each time I appreciate the efforts of the developers in documenting their work.&lt;/p&gt;

&lt;p&gt;如果想更详细地了解Go语言, 你可以阅读Go语言规格.
&quot;简明&quot;这个概念在Go语言中到处体现.&lt;/p&gt;

&lt;p&gt;If you’ve read this far, then you are most certainly a delightful person. I’ll write quite a bit more on Go, hopefully this was a helpful first step.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>买房WorkFlow</title>
   <link href="http://www.5wpc.info/it/project/home/2014/09/04/WorkFlow"/>
   <updated>2014-09-04T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/project/home/2014/09/04/WorkFlow</id>
   <content type="html">&lt;h1&gt;买房WorkFlow&lt;/h1&gt;

&lt;h2&gt;1.了解与选择：主要是在符合租房基本要求后，还要考虑开发商与物业&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;2014年买房注意事项 20条黄金法则买房不吃亏

&lt;ul&gt;
&lt;li&gt;http://news.sjz.fang.com/2014-02-10/12055612_all.html&lt;/li&gt;
&lt;li&gt;不一定要新房

&lt;ul&gt;
&lt;li&gt;周边配套&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;慎买纯小户型社区的房子

&lt;ul&gt;
&lt;li&gt;容积率

&lt;ul&gt;
&lt;li&gt;人口密度&lt;/li&gt;
&lt;li&gt;公共资源&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;具有一定投资价值&lt;/li&gt;
&lt;li&gt;建议在购买小户型时一定要注意户型最好是明厨明卫，且房间内的透气性一定要好，实用性要高&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;注意交房时间&lt;/li&gt;
&lt;li&gt;经济适用量力而行

&lt;ul&gt;
&lt;li&gt;建议年轻人在选择按揭贷款时，每月月供额度最好不要超过家庭月收入的30%，否则将会影响生活质量&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;先定地段再选户型&lt;/li&gt;
&lt;li&gt;确定5公里生活圈&lt;/li&gt;
&lt;li&gt;小区绿化要达到35%以上

&lt;ul&gt;
&lt;li&gt;“绿地率”与“绿化履盖率”是两个不同的概念，绿地不包括阳台和屋顶绿化，有些开发商会故意混淆这两个概念&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;社区人性化设计

&lt;ul&gt;
&lt;li&gt;人车分流，保证交通的便捷性、安全性、以及减少对居住环境的影响&lt;/li&gt;
&lt;li&gt;商住分区，娱乐购物影响不到居住的安静和安全&lt;/li&gt;
&lt;li&gt;住宅布局成街区式，利于形成良好的邻里关系&lt;/li&gt;
&lt;li&gt;社区内规划有大型巴士站、人工湖、学校等，生活配套相当完善&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;社区配套齐备

&lt;ul&gt;
&lt;li&gt;衣：服装店、裁缝铺、洗衣房等&lt;/li&gt;
&lt;li&gt;食：超市、菜场、面包店、饮食店、小吃店&lt;/li&gt;
&lt;li&gt;住：不仅要看自己的房子，也要看周边的楼是怎样的房子，更要看有没有化工厂、电站、加油站、汽车、机动车维修点等，绿化如何也须看。&lt;/li&gt;
&lt;li&gt;行：不仅要看房子附近有没有地铁、轻轨、来往车辆、有几个车站等，还要看高架旁的下车道是不是在你的新房附近，出门是不是单行道等。&lt;/li&gt;
&lt;li&gt;其他：还得看附近有没有公园、银行、医院，有老人的家庭最好离医院近一点；有孩子的应关心托儿所、幼等。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;建筑密度小

&lt;ul&gt;
&lt;li&gt;低“容积率”

&lt;ul&gt;
&lt;li&gt;一个良好的低密度居住小区，多层住宅应不超过1.5。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;买同一区域连续成功开发的楼盘&lt;/li&gt;
&lt;li&gt;购买1999年2月以后造的楼盘&lt;/li&gt;
&lt;li&gt;层高不宜超过3米房&lt;/li&gt;
&lt;li&gt;购买错层房型最好以东西向错&lt;/li&gt;
&lt;li&gt;购买小房型作投资须谨慎&lt;/li&gt;
&lt;li&gt;不选择炒作过度的楼盘&lt;/li&gt;
&lt;li&gt;小的不一定是美丽的

&lt;ul&gt;
&lt;li&gt;每个房间非常局促，使用功能便大打折扣。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;买开发商的头脑&lt;/li&gt;
&lt;li&gt;选择区域考虑景观系数&lt;/li&gt;
&lt;li&gt;购买十万平方米左右的楼盘&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;选房子

&lt;ul&gt;
&lt;li&gt;先选择区域

&lt;ul&gt;
&lt;li&gt;zf规划蓝图，地铁规划布局，景观，生态公园&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;再选择楼盘

&lt;ul&gt;
&lt;li&gt;工作远近，学区房，大型超市，地铁口，高校周边，名盘周边，小区新老, 医院&lt;/li&gt;
&lt;li&gt;小区的物业，保安，是否市政水，电，气&lt;/li&gt;
&lt;li&gt;对比

&lt;ul&gt;
&lt;li&gt;横向就是跟其他小区的楼盘对比

&lt;ul&gt;
&lt;li&gt;老房子

&lt;ul&gt;
&lt;li&gt;已购公房的实际面积比方本的面积大&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;回迁房

&lt;ul&gt;
&lt;li&gt;要看房本的产权，是不是个人所有的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;纵向就是跟历史成交价格的对比&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;再选楼层

&lt;ul&gt;
&lt;li&gt;最好不要买9－11层的。因为这个高度是大气的污染层&lt;/li&gt;
&lt;li&gt;南北通透&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;列出关注点,汇集表格,准备挑选

&lt;ul&gt;
&lt;li&gt;周边配套

&lt;ul&gt;
&lt;li&gt;教育

&lt;ul&gt;
&lt;li&gt;学校

&lt;ul&gt;
&lt;li&gt;幼儿园&lt;/li&gt;
&lt;li&gt;小学&lt;/li&gt;
&lt;li&gt;中学&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;健身游泳&lt;/li&gt;
&lt;li&gt;SPA瑜伽&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;交通

&lt;ul&gt;
&lt;li&gt;公交车&lt;/li&gt;
&lt;li&gt;地铁&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;商业

&lt;ul&gt;
&lt;li&gt;购物广场&lt;/li&gt;
&lt;li&gt;菜市场&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;卫生

&lt;ul&gt;
&lt;li&gt;医院&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;楼规格参数

&lt;ul&gt;
&lt;li&gt;容积率

&lt;ul&gt;
&lt;li&gt;电梯使用/小区使用&lt;/li&gt;
&lt;li&gt;车位使用

&lt;ul&gt;
&lt;li&gt;1:0.88&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;物业费&lt;/li&gt;
&lt;li&gt;绿化率&lt;/li&gt;
&lt;li&gt;装修情况&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;主要问题

&lt;ul&gt;
&lt;li&gt;价格&lt;/li&gt;
&lt;li&gt;入住时间&lt;/li&gt;
&lt;li&gt;容积率&lt;/li&gt;
&lt;li&gt;楼间间隔&lt;/li&gt;
&lt;li&gt;物业公司&lt;/li&gt;
&lt;li&gt;小区服务&lt;/li&gt;
&lt;li&gt;地点

&lt;ul&gt;
&lt;li&gt;交通&lt;/li&gt;
&lt;li&gt;学校&lt;/li&gt;
&lt;li&gt;医院&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;2.签订认购书和商品买卖合同，查验五证&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;补充条款（在买卖的时候一个是签订认购书，第二个签订购房合同，购房合同有一个补充协议，这个补充协议往往是房屋购买合同里没有约定的事项通常在补充条款里进行约定）签订的时候应该把握几个问题：

&lt;ul&gt;
&lt;li&gt;明确的把售楼书和其他广告的内容写进补充协议&lt;/li&gt;
&lt;li&gt;明确房屋所有权证办理的时间&lt;/li&gt;
&lt;li&gt;要明确按揭办不下来的话，双方的责任&lt;/li&gt;
&lt;li&gt;明确关于公摊建筑面积&lt;/li&gt;
&lt;li&gt;应该明确装修标准&lt;/li&gt;
&lt;li&gt;明确退房的责任&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;3.交房和办理产权登记，就是开发商在办理完登记后，签收“两书”&lt;/h2&gt;

&lt;h2&gt;http://jingyan.baidu.com/article/e75057f28ac9a6ebc91a89d6.html&lt;/h2&gt;
</content>
 </entry>
 
 <entry>
   <title>StockManage</title>
   <link href="http://www.5wpc.info/it/project/financialmanage/2014/09/04/StockManage"/>
   <updated>2014-09-04T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/project/financialmanage/2014/09/04/StockManage</id>
   <content type="html">&lt;h1&gt;StockManage&lt;/h1&gt;

&lt;h2&gt;交易通道&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;资金走向

&lt;ul&gt;
&lt;li&gt;添加独立银行账号用于向香港证券机构汇款

&lt;ul&gt;
&lt;li&gt;香港一卡通&lt;/li&gt;
&lt;li&gt;购汇

&lt;ul&gt;
&lt;li&gt;自助购汇业务的交易时间为：工作日（8：30-22：00）；周六、日（8：30-17：20）；一般节假日（8：30-17：20）；春节和国庆七天长假系统不开放；每年的12月31日（8：30-17：20）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;汇款

&lt;ul&gt;
&lt;li&gt;http://www.cmbchina.com/cmbpb/v50/gb/pb/TransferHK.htm&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;选择证券机构

&lt;ul&gt;
&lt;li&gt;香港盈透&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;https://www.ibkr.com.cn/cn/main.php

&lt;ul&gt;
&lt;li&gt;证券通道&lt;/li&gt;
&lt;li&gt;开户相关

&lt;ul&gt;
&lt;li&gt;http://blog.sina.com.cn/s/blog_672f4b1f0102uzun.html&lt;/li&gt;
&lt;li&gt;http://www.aliway.com/read.php?tid=255547&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;相关信息学习

&lt;ul&gt;
&lt;li&gt;工具安装

&lt;ul&gt;
&lt;li&gt;http://blog.sina.com.cn/s/blog_661972880100jt26.html&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;http://xueqiu.com/

&lt;ul&gt;
&lt;li&gt;信息汇总通道&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;体验感受&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;20140925晚上

&lt;ul&gt;
&lt;li&gt;在TWS的虚拟系统上体验后

&lt;ul&gt;
&lt;li&gt;我们这种做短期处理的,基本不会有什么收益

&lt;ul&gt;
&lt;li&gt;对于大量的股票如果没有内部消息,很难可以一天涨很多倍&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;在这种情况下,基本就是做为长线投资, 通过对业界的了解与把握去做出选择.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;20140929上午学习

&lt;ul&gt;
&lt;li&gt;http://xueqiu.com/4226803442/21990358

&lt;ul&gt;
&lt;li&gt;将这些材料汇总用于个人学习&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;20141102理论学习

&lt;ul&gt;
&lt;li&gt;经过学习相关理财书籍,目前已经基本了解了股票中的一些概念

&lt;ul&gt;
&lt;li&gt;http://book.douban.com/doulist/13912649/

&lt;ul&gt;
&lt;li&gt;我最需要的理财常识书&lt;/li&gt;
&lt;li&gt;从零开始学炒股&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;看懂财经新闻的第一本书&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;主要的建议是

&lt;ul&gt;
&lt;li&gt;专注投资,不是投机&lt;/li&gt;
&lt;li&gt;常识看事,劳动致富&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;途径&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;P2P贷款&lt;/li&gt;
&lt;li&gt;股票&lt;/li&gt;
&lt;li&gt;理财产品&lt;/li&gt;
&lt;li&gt;基金&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;主要要求&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;资金流转

&lt;ul&gt;
&lt;li&gt;每个人每年50000美金&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>FitnessLesson</title>
   <link href="http://www.5wpc.info/it/project/fitness/2014/09/04/Lesson"/>
   <updated>2014-09-04T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/project/fitness/2014/09/04/Lesson</id>
   <content type="html">&lt;h1&gt;FitnessLesson&lt;/h1&gt;

&lt;h2&gt;Review&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;饮食

&lt;ul&gt;
&lt;li&gt;原则

&lt;ul&gt;
&lt;li&gt;少食多餐&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;习惯

&lt;ul&gt;
&lt;li&gt;下蹲拿东西时, 少用腰部力量, 多使用腿部力量&lt;/li&gt;
&lt;li&gt;意志力&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;1.激活身体肌能(20140903晚上)&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;肌力与肌耐力&lt;/li&gt;
&lt;li&gt;饮水少量&lt;/li&gt;
&lt;li&gt;动作要标准&lt;/li&gt;
&lt;li&gt;登山机10min

&lt;ul&gt;
&lt;li&gt;1-6: &gt;6.5&lt;/li&gt;
&lt;li&gt;7-8: &gt;8.5&lt;/li&gt;
&lt;li&gt;9-10: 全力&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;上肢力量

&lt;ul&gt;
&lt;li&gt;拉力&lt;/li&gt;
&lt;li&gt;举力&lt;/li&gt;
&lt;li&gt;第个四组,每组20&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;全身力量

&lt;ul&gt;
&lt;li&gt;跳绳

&lt;ul&gt;
&lt;li&gt;60个&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;平板

&lt;ul&gt;
&lt;li&gt;50s&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;张合跳

&lt;ul&gt;
&lt;li&gt;1min&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;卷腹

&lt;ul&gt;
&lt;li&gt;20个&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;下蹲

&lt;ul&gt;
&lt;li&gt;20个&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;每个四组&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;2. 激活腿部肌肉(20140905晚上)&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;登山机10min&lt;/li&gt;
&lt;li&gt;腿部力量

&lt;ul&gt;
&lt;li&gt;绕圈跨步

&lt;ul&gt;
&lt;li&gt;膝盖不能过脚尖&lt;/li&gt;
&lt;li&gt;小腿与地面垂直&lt;/li&gt;
&lt;li&gt;后腿与身体保持一条线&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;3圈&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;胸大肌

&lt;ul&gt;
&lt;li&gt;推力&lt;/li&gt;
&lt;li&gt;总共4组&lt;/li&gt;
&lt;li&gt;每组10个&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;腹部力量

&lt;ul&gt;
&lt;li&gt;俯卧撑&lt;/li&gt;
&lt;li&gt;直腿起&lt;/li&gt;
&lt;li&gt;10m*2&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;腹部力量

&lt;ul&gt;
&lt;li&gt;抬腿&lt;/li&gt;
&lt;li&gt;卷腹&lt;/li&gt;
&lt;li&gt;总共4组&lt;/li&gt;
&lt;li&gt;每组10个&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;椭圆机

&lt;ul&gt;
&lt;li&gt;10min&lt;/li&gt;
&lt;li&gt;自由行&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;2.1(20140907晚上)&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;与第一次一样

&lt;ul&gt;
&lt;li&gt;将器械练习转成哑铃&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;3. 下肢锻炼(20140909晚上)&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;划船机10min&lt;/li&gt;
&lt;li&gt;四项

&lt;ul&gt;
&lt;li&gt;平板

&lt;ul&gt;
&lt;li&gt;30s&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;立卧撑

&lt;ul&gt;
&lt;li&gt;10个&lt;/li&gt;
&lt;li&gt;俯卧撑&lt;/li&gt;
&lt;li&gt;跳起&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;卷腹

&lt;ul&gt;
&lt;li&gt;20个&lt;/li&gt;
&lt;li&gt;最简单的方式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;划船

&lt;ul&gt;
&lt;li&gt;10个&lt;/li&gt;
&lt;li&gt;28磅&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;联合四组&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;高抬脚

&lt;ul&gt;
&lt;li&gt;20s&lt;/li&gt;
&lt;li&gt;3组&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;半蹲翻转

&lt;ul&gt;
&lt;li&gt;一个来回&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;椭圆机

&lt;ul&gt;
&lt;li&gt;10min&lt;/li&gt;
&lt;li&gt;自由行&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;3.1(20140911晚上)&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;半小时划船机&lt;/li&gt;
&lt;li&gt;100个深蹲&lt;/li&gt;
&lt;li&gt;1圈跨步&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;3.2(20140913晚上)&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;10分钟椭圆机&lt;/li&gt;
&lt;li&gt;60个俯卧撑&lt;/li&gt;
&lt;li&gt;40个哑铃伸臂&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;4. 全身运动(20140915晚上)&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;10分钟划船机&lt;/li&gt;
&lt;li&gt;全身项目

&lt;ul&gt;
&lt;li&gt;爬行俯卧撑&lt;/li&gt;
&lt;li&gt;平板&lt;/li&gt;
&lt;li&gt;卷腹&lt;/li&gt;
&lt;li&gt;张合跳&lt;/li&gt;
&lt;li&gt;下蹲跳&lt;/li&gt;
&lt;li&gt;高抬腿&lt;/li&gt;
&lt;li&gt;每个2组&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;3分钟爬山机&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;5. 上肢专项练习(20140917晚上)&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;10分爬山机&lt;/li&gt;
&lt;li&gt;500m划船机&lt;/li&gt;
&lt;li&gt;俯卧撑

&lt;ul&gt;
&lt;li&gt;手下持有哑铃&lt;/li&gt;
&lt;li&gt;10*(3~4)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;下蹲

&lt;ul&gt;
&lt;li&gt;30s*4&lt;/li&gt;
&lt;li&gt;靠墙

&lt;ul&gt;
&lt;li&gt;大腿与小腿90度&lt;/li&gt;
&lt;li&gt;背部靠墙&lt;/li&gt;
&lt;li&gt;头离开墙&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;哑铃

&lt;ul&gt;
&lt;li&gt;L&lt;/li&gt;
&lt;li&gt;T&lt;/li&gt;
&lt;li&gt;下蹲T&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;滚动球

&lt;ul&gt;
&lt;li&gt;大腿&lt;/li&gt;
&lt;li&gt;腰&lt;/li&gt;
&lt;li&gt;臀部&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;椭圆机10min&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;6. 下肢专项练习(20140919晚上)&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;10分钟跑步机

&lt;ul&gt;
&lt;li&gt;5min: 6.5km/h&lt;/li&gt;
&lt;li&gt;5min: 11km/h&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;500m划船机&lt;/li&gt;
&lt;li&gt;平板4*40s&lt;/li&gt;
&lt;li&gt;腿部

&lt;ul&gt;
&lt;li&gt;蛙跳2圈&lt;/li&gt;
&lt;li&gt;腿部力量

&lt;ul&gt;
&lt;li&gt;4组*12&lt;/li&gt;
&lt;li&gt;抬腿&lt;/li&gt;
&lt;li&gt;勾腿&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;靠墙下蹲

&lt;ul&gt;
&lt;li&gt;4*30s&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;矮子走路2个来回&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;俯卧撑20个&lt;/li&gt;
&lt;li&gt;椭圆机10min&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;6.1 上肢练习(20140921晚上)&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;俯卧撑20*5&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;7. 肱二头肌练习(20140923晚上)&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;10min 爬山&lt;/li&gt;
&lt;li&gt;矮子步

&lt;ul&gt;
&lt;li&gt;3*来回&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;支撑俯卧撑

&lt;ul&gt;
&lt;li&gt;4*15个&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;举抬器械

&lt;ul&gt;
&lt;li&gt;4*9&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;依靠腿部单手抬举哑铃

&lt;ul&gt;
&lt;li&gt;4*左&amp;amp;右9&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;双手上拉

&lt;ul&gt;
&lt;li&gt;4*9&lt;/li&gt;
&lt;li&gt;5kg&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;双手下拉

&lt;ul&gt;
&lt;li&gt;4*9&lt;/li&gt;
&lt;li&gt;5kg&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;绕场&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;8. 背阔肌练习(20140925晚上)&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;10min跑步&lt;/li&gt;
&lt;li&gt;500m划船&lt;/li&gt;
&lt;li&gt;靠墙下蹲

&lt;ul&gt;
&lt;li&gt;40s*4&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;双手托杠铃下蹲

&lt;ul&gt;
&lt;li&gt;4*10&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;深蹲

&lt;ul&gt;
&lt;li&gt;4*20&lt;/li&gt;
&lt;li&gt;负重深蹲&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;双杠臂屈伸

&lt;ul&gt;
&lt;li&gt;4*10&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;锤式哑铃臂弯举

&lt;ul&gt;
&lt;li&gt;4*10&lt;/li&gt;
&lt;li&gt;左右都是&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;俯卧撑

&lt;ul&gt;
&lt;li&gt;20个&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;3min椭圆机&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;8.1 上肢锻炼(20140927晚上)&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;80个俯卧撑&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;8.2 上肢练习(20140929晚上)&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;10min椭圆机&lt;/li&gt;
&lt;li&gt;20*4个俯卧撑&lt;/li&gt;
&lt;li&gt;20*4深蹲&lt;/li&gt;
&lt;li&gt;35s*4靠墙下蹲&lt;/li&gt;
&lt;li&gt;1min*4平板&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;8.3 十一练习&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;目标

&lt;ul&gt;
&lt;li&gt;保持+增加体能&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;过程

&lt;ul&gt;
&lt;li&gt;热身

&lt;ul&gt;
&lt;li&gt;开合跳/跳绳 10min&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;具体

&lt;ul&gt;
&lt;li&gt;从如下项目中取４个&lt;/li&gt;
&lt;li&gt;立卧撑

&lt;ul&gt;
&lt;li&gt;10*4&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;深蹲

&lt;ul&gt;
&lt;li&gt;20*5&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;高抬腿

&lt;ul&gt;
&lt;li&gt;1min*5&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;平板

&lt;ul&gt;
&lt;li&gt;1min*5&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;凳上反屈伸

&lt;ul&gt;
&lt;li&gt;20*4&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;卷腹

&lt;ul&gt;
&lt;li&gt;20*4&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;仰卧举腿

&lt;ul&gt;
&lt;li&gt;20*5&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;前步蹲

&lt;ul&gt;
&lt;li&gt;20*5&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;靠墙静坐

&lt;ul&gt;
&lt;li&gt;50s*5&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;休息

&lt;ul&gt;
&lt;li&gt;20min有氧&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;8.4练习&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;20141001

&lt;ul&gt;
&lt;li&gt;立卧撑&lt;/li&gt;
&lt;li&gt;前步蹲&lt;/li&gt;
&lt;li&gt;平板&lt;/li&gt;
&lt;li&gt;仰卧举腿&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;20141003

&lt;ul&gt;
&lt;li&gt;凳上反屈伸&lt;/li&gt;
&lt;li&gt;高抬腿&lt;/li&gt;
&lt;li&gt;卷腹&lt;/li&gt;
&lt;li&gt;靠墙静坐&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;20141005

&lt;ul&gt;
&lt;li&gt;立卧撑&lt;/li&gt;
&lt;li&gt;前步蹲&lt;/li&gt;
&lt;li&gt;平板&lt;/li&gt;
&lt;li&gt;凳上反屈伸&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;20141007

&lt;ul&gt;
&lt;li&gt;深蹲&lt;/li&gt;
&lt;li&gt;凳上反屈伸&lt;/li&gt;
&lt;li&gt;卷腹&lt;/li&gt;
&lt;li&gt;靠墙静坐&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;9.1上肢(肱三头肌,斜方肌,三角肌)练习(20141009晚上)&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;爬山机10min&lt;/li&gt;
&lt;li&gt;双杠臂屈伸

&lt;ul&gt;
&lt;li&gt;10*2&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;窄握引体向上

&lt;ul&gt;
&lt;li&gt;10*2&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;俯卧撑

&lt;ul&gt;
&lt;li&gt;10*2&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;杠铃颈后推举

&lt;ul&gt;
&lt;li&gt;10*2&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;杠铃前平举

&lt;ul&gt;
&lt;li&gt;10*2&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;蹲步前行

&lt;ul&gt;
&lt;li&gt;1个来回&lt;/li&gt;
&lt;li&gt;移动杠铃&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;倒立&lt;/li&gt;
&lt;li&gt;椭圆机5min&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;9.2 上肢练习(20141011晚上)&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;爬山机10min&lt;/li&gt;
&lt;li&gt;上肢练习

&lt;ul&gt;
&lt;li&gt;自己练习关键是动作标准与加大力量&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;椭圆机5min&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;9.3 上肢练习(20141013晚上)&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;自由练习&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;10.1下肢练习(20141014晚上)&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;椭圆机10min&lt;/li&gt;
&lt;li&gt;下肢练习

&lt;ul&gt;
&lt;li&gt;引体向上

&lt;ul&gt;
&lt;li&gt;10*4&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;蹬腿

&lt;ul&gt;
&lt;li&gt;10*4&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;靠墙下蹲

&lt;ul&gt;
&lt;li&gt;30s*4&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;立卧撑

&lt;ul&gt;
&lt;li&gt;10*4&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;打坐

&lt;ul&gt;
&lt;li&gt;2min*2&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;上举哑铃

&lt;ul&gt;
&lt;li&gt;10*4&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;11.1上肢练习(20141016晚上)&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;爬山机10min&lt;/li&gt;
&lt;li&gt;引体向上+绕圈跑

&lt;ul&gt;
&lt;li&gt;3*4&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;蛙跳俯卧撑

&lt;ul&gt;
&lt;li&gt;10*4&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;杠铃平举

&lt;ul&gt;
&lt;li&gt;8*4&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;拉绳子

&lt;ul&gt;
&lt;li&gt;8*4&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;单腿深蹲

&lt;ul&gt;
&lt;li&gt;2&lt;em&gt;10&lt;/em&gt;4&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;倒立&lt;/li&gt;
&lt;li&gt;椭圆机5min&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;11.2 上肢练习(20141019晚上)&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;椭圆机10min&lt;/li&gt;
&lt;li&gt;蛙跳俯卧撑

&lt;ul&gt;
&lt;li&gt;10*4&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;单腿深蹲

&lt;ul&gt;
&lt;li&gt;2&lt;em&gt;10&lt;/em&gt;3&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;平板

&lt;ul&gt;
&lt;li&gt;3*60s&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;凳上反屈伸

&lt;ul&gt;
&lt;li&gt;3*10&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;12 上肢持续练习(20141021晚上)&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;爬山机5min&lt;/li&gt;
&lt;li&gt;引体向上

&lt;ul&gt;
&lt;li&gt;5*4&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;高抬脚

&lt;ul&gt;
&lt;li&gt;10s*3&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;移动俯卧撑

&lt;ul&gt;
&lt;li&gt;50个&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;深蹲,哑铃平举

&lt;ul&gt;
&lt;li&gt;10*4&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;划船机

&lt;ul&gt;
&lt;li&gt;500m&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;椭圆机5min&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;13 整体练习(20141024晚上)&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;跑步机10min&lt;/li&gt;
&lt;li&gt;起立哑铃高举

&lt;ul&gt;
&lt;li&gt;10*4&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;卷腹+坐姿引体向上

&lt;ul&gt;
&lt;li&gt;10&lt;em&gt;2&lt;/em&gt;4&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;坐姿宽握划船

&lt;ul&gt;
&lt;li&gt;10*4&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;划船机

&lt;ul&gt;
&lt;li&gt;500m&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;凳上俯卧撑+反屈伸

&lt;ul&gt;
&lt;li&gt;10&lt;em&gt;2&lt;/em&gt;4&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;椭圆机5min&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;13.1 上肢练习(20141026晚上)&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;椭圆机10min&lt;/li&gt;
&lt;li&gt;凳上俯卧撑+反屈伸

&lt;ul&gt;
&lt;li&gt;10&lt;em&gt;2&lt;/em&gt;4&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;卷腹

&lt;ul&gt;
&lt;li&gt;30*4&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;哑铃平举

&lt;ul&gt;
&lt;li&gt;30*4&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;椭圆机3min&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;14 全身练习(20141029晚上)&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;划船机5min&lt;/li&gt;
&lt;li&gt;原地高抬腿+窄距俯卧撑

&lt;ul&gt;
&lt;li&gt;(40+10)*4&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;手握哑铃+单腿支撑

&lt;ul&gt;
&lt;li&gt;10&lt;em&gt;2&lt;/em&gt;2&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;跨步向前

&lt;ul&gt;
&lt;li&gt;两个来回&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;平板+转腰

&lt;ul&gt;
&lt;li&gt;(40s+20)*4&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;坐姿宽握划船

&lt;ul&gt;
&lt;li&gt;33L&lt;em&gt;9+36L&lt;/em&gt;9+39L&lt;em&gt;6+36L&lt;/em&gt;9&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;俯卧撑+原地跳

&lt;ul&gt;
&lt;li&gt;35&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;窄手臂引体向上

&lt;ul&gt;
&lt;li&gt;10*3&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;14.1 上肢练习(20141031晚上)&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;跑步机10min&lt;/li&gt;
&lt;li&gt;俯卧撑

&lt;ul&gt;
&lt;li&gt;20*5&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;卷腹

&lt;ul&gt;
&lt;li&gt;30*4&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;抬腿

&lt;ul&gt;
&lt;li&gt;10*4&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;凳上反屈伸

&lt;ul&gt;
&lt;li&gt;10*4&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;14.2 上肢练习(20141101晚上)&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;俯身提臀

&lt;ul&gt;
&lt;li&gt;10*4&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;仰卧起坐

&lt;ul&gt;
&lt;li&gt;25*4&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;俯立臂屈伸

&lt;ul&gt;
&lt;li&gt;12*4&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;宽距俯卧撑

&lt;ul&gt;
&lt;li&gt;12*4&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;俯卧撑哑铃划船

&lt;ul&gt;
&lt;li&gt;10*4&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;跑步机

&lt;ul&gt;
&lt;li&gt;3min&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;15 上肢练习(20141103晚上)&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;跑步机

&lt;ul&gt;
&lt;li&gt;10min&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;爬山机10min&lt;/li&gt;
&lt;li&gt;深蹲交换手推杠铃

&lt;ul&gt;
&lt;li&gt;12*4&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;单手深蹲划船

&lt;ul&gt;
&lt;li&gt;10&lt;em&gt;2&lt;/em&gt;4&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;双杠臂屈伸

&lt;ul&gt;
&lt;li&gt;１０+８+８+１０&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;杠铃弯举

&lt;ul&gt;
&lt;li&gt;１０*４&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;深蹲+拉杠铃+弯举

&lt;ul&gt;
&lt;li&gt;10*4&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;器械托臂屈伸

&lt;ul&gt;
&lt;li&gt;１０*４&lt;/li&gt;
&lt;li&gt;３６Ｌ&lt;em&gt;３+４０Ｌ&lt;/em&gt;１&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;15.1 上肢练习(20141105晚上)&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;划船5min&lt;/li&gt;
&lt;li&gt;椭圆机10min&lt;/li&gt;
&lt;li&gt;坐姿宽握划船

&lt;ul&gt;
&lt;li&gt;10*4&lt;/li&gt;
&lt;li&gt;背部&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;拉力器双臂下拉

&lt;ul&gt;
&lt;li&gt;10*4&lt;/li&gt;
&lt;li&gt;胸部&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;锤式下拉

&lt;ul&gt;
&lt;li&gt;10*4

&lt;ul&gt;
&lt;li&gt;5*4&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;三头肌&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;反手引体向上

&lt;ul&gt;
&lt;li&gt;二头肌&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;注意保暖&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;16 上肢练习(20141107晚上)&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;椭圆机10min&lt;/li&gt;
&lt;li&gt;跑步机15min&lt;/li&gt;
&lt;li&gt;引体向上

&lt;ul&gt;
&lt;li&gt;5*4&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;史密斯杠铃卧推+上斜哑铃卧推

&lt;ul&gt;
&lt;li&gt;(10+8)*5&lt;/li&gt;
&lt;li&gt;0+5*4&lt;/li&gt;
&lt;li&gt;15L&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;深蹲+哑铃划船+哑铃过头推举

&lt;ul&gt;
&lt;li&gt;10*4&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;背杠铃马步前进

&lt;ul&gt;
&lt;li&gt;1个来回&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;凳上反屈伸

&lt;ul&gt;
&lt;li&gt;20*4&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;俯卧撑

&lt;ul&gt;
&lt;li&gt;10&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;靠墙深蹲

&lt;ul&gt;
&lt;li&gt;35s*4&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;拉伸&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;16.1 上肢练习(20141112晚上)&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;跑步机10min&lt;/li&gt;
&lt;li&gt;坐姿宽距划船

&lt;ul&gt;
&lt;li&gt;4*8&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;宽握下拉

&lt;ul&gt;
&lt;li&gt;4*8&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;仰卧起坐

&lt;ul&gt;
&lt;li&gt;4*30&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;锤式下拉

&lt;ul&gt;
&lt;li&gt;4*10&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;17 上肢练习(20141114晚上)&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;跑步机15min&lt;/li&gt;
&lt;li&gt;深蹲哑铃平举

&lt;ul&gt;
&lt;li&gt;4*8&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;深蹲

&lt;ul&gt;
&lt;li&gt;4*25&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;宽距俯卧撑

&lt;ul&gt;
&lt;li&gt;20&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;俯身哑铃侧平举

&lt;ul&gt;
&lt;li&gt;4*8&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;哑铃侧平举

&lt;ul&gt;
&lt;li&gt;4*8&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;扩胸器扩胸

&lt;ul&gt;
&lt;li&gt;4*10&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;重力器上推

&lt;ul&gt;
&lt;li&gt;4*10&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;杠铃前平举+窄距俯卧撑

&lt;ul&gt;
&lt;li&gt;4*(8+8)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;单臂哑铃侧屈

&lt;ul&gt;
&lt;li&gt;4&lt;em&gt;2&lt;/em&gt;20&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;17.1 上肢练习(20141117晚上)&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;划船机5min&lt;/li&gt;
&lt;li&gt;宽距划船拉力

&lt;ul&gt;
&lt;li&gt;4*10&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;锤式下拉

&lt;ul&gt;
&lt;li&gt;4*10&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;宽距下拉

&lt;ul&gt;
&lt;li&gt;4*10&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;仰卧起坐

&lt;ul&gt;
&lt;li&gt;2*30&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;宽式蝴蝶夹胸

&lt;ul&gt;
&lt;li&gt;4*10&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;重力器上推

&lt;ul&gt;
&lt;li&gt;4*10&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;引体向上

&lt;ul&gt;
&lt;li&gt;3*10&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;椭圆机

&lt;ul&gt;
&lt;li&gt;5min&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;18 上肢与肩部练习(20141119晚上)&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;划船机10min&lt;/li&gt;
&lt;li&gt;引体向上

&lt;ul&gt;
&lt;li&gt;3*4&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;拉力器双臂平拉

&lt;ul&gt;
&lt;li&gt;5*12&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;哑铃弓步前行

&lt;ul&gt;
&lt;li&gt;两个来回&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;前倾哑铃划船

&lt;ul&gt;
&lt;li&gt;5*12&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;前倾哑铃高举

&lt;ul&gt;
&lt;li&gt;5*12&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;提臀俯卧撑

&lt;ul&gt;
&lt;li&gt;5*10&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;凳上臂屈伸

&lt;ul&gt;
&lt;li&gt;5*12&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;拉伸&lt;/li&gt;
&lt;li&gt;Review

&lt;ul&gt;
&lt;li&gt;核心力量不足&lt;/li&gt;
&lt;li&gt;平时锻炼不足&lt;/li&gt;
&lt;li&gt;注重全身力量与协调&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;18.1 上肢与肩部练习(20141121晚上)&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;跑步10min&lt;/li&gt;
&lt;li&gt;二头肌引体向上

&lt;ul&gt;
&lt;li&gt;4*4&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;重力器上推

&lt;ul&gt;
&lt;li&gt;5*8&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;重力器斜板托臂弯举

&lt;ul&gt;
&lt;li&gt;5*8&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;宽式蝴蝶夹胸

&lt;ul&gt;
&lt;li&gt;4*10&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;重力器引体向上

&lt;ul&gt;
&lt;li&gt;5*8&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;坐姿宽握划船

&lt;ul&gt;
&lt;li&gt;4*8&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;19 全身练习(20141124晚上)&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;热身

&lt;ul&gt;
&lt;li&gt;跳绳100&lt;/li&gt;
&lt;li&gt;弓字步2个来回

&lt;ul&gt;
&lt;li&gt;2*15m&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;肩部练习

&lt;ul&gt;
&lt;li&gt;立卧撑&lt;/li&gt;
&lt;li&gt;杠铃直拉&lt;/li&gt;
&lt;li&gt;4*(10+10)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;手臂练习

&lt;ul&gt;
&lt;li&gt;引体向上&lt;/li&gt;
&lt;li&gt;双杠臂屈伸&lt;/li&gt;
&lt;li&gt;4*(8+8)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;全身

&lt;ul&gt;
&lt;li&gt;靠墙静蹲&lt;/li&gt;
&lt;li&gt;哑铃上拉

&lt;ul&gt;
&lt;li&gt;上拉到肩部水平&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;4*12&lt;/li&gt;
&lt;li&gt;4*30s&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;拉伸

&lt;ul&gt;
&lt;li&gt;弹力带全身拉&lt;/li&gt;
&lt;li&gt;臀部上提&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;椭圆机

&lt;ul&gt;
&lt;li&gt;10min&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Review

&lt;ul&gt;
&lt;li&gt;手臂练习时, 汗出的很多&lt;/li&gt;
&lt;li&gt;自己需要下决心在没有力气时发力&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;19.1 上肢练习(20141126晚上)&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;跑步

&lt;ul&gt;
&lt;li&gt;10min&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;手臂练习

&lt;ul&gt;
&lt;li&gt;引体向上&lt;/li&gt;
&lt;li&gt;双杠臂屈伸&lt;/li&gt;
&lt;li&gt;4*(10+8)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;上体

&lt;ul&gt;
&lt;li&gt;胸部

&lt;ul&gt;
&lt;li&gt;重力器下拉

&lt;ul&gt;
&lt;li&gt;4*10&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;背部

&lt;ul&gt;
&lt;li&gt;宽距坐姿划船

&lt;ul&gt;
&lt;li&gt;4*10&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;肩部

&lt;ul&gt;
&lt;li&gt;垂式下拉

&lt;ul&gt;
&lt;li&gt;4*10&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;重力器推举

&lt;ul&gt;
&lt;li&gt;5*10&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;价值&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;1: 第一次体会完整的一次健身,

&lt;ul&gt;
&lt;li&gt;是对个人躯体状况的查看&lt;/li&gt;
&lt;li&gt;对个人意志力的锻炼&lt;/li&gt;
&lt;li&gt;有种想呕吐的感觉

&lt;ul&gt;
&lt;li&gt;身体突破的表现,正常反应&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;要领&lt;/li&gt;
&lt;li&gt;力量不能放

&lt;ul&gt;
&lt;li&gt;始终保持发力&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;动作要标准&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;意志力有下降&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;3.1 注意装备安全,保护好自己&lt;/li&gt;
&lt;li&gt;3.2 加油,坚持&lt;/li&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;第一次呕吐&lt;/li&gt;
&lt;li&gt;以后每天练习平板&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;上肢力量非常弱&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;tags: Review&lt;/h2&gt;
</content>
 </entry>
 
 <entry>
   <title>Ruby 中的闭包</title>
   <link href="http://www.5wpc.info/it/technical/language/ruby/2014/09/03/Closure"/>
   <updated>2014-09-03T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/technical/language/ruby/2014/09/03/Closure</id>
   <content type="html">&lt;p&gt;http://rubyer.me/blog/917/&lt;/p&gt;

&lt;p&gt;Ruby:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;block = Proc&lt;/li&gt;
&lt;li&gt;Proc = code part 代码片断, 与引用部分属于同一个上下文&lt;/li&gt;
&lt;li&gt;lambda = noname Method&lt;/li&gt;
&lt;li&gt;Method&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code class=&quot;ruby&quot;&gt;def a
    sum = 0
    return lambda do |x|
        sum += x
    end
end

pos = a
neg = a

(1.upto(5)).each do |i|
    puts &#39;%d %d&#39; % [pos.call(i),neg.call(-2*i)]
end

#  1 -2
#  3 -6
#  6 -12
#  10 -20
#  15 -30
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>Ruby on Rails 相关技术</title>
   <link href="http://www.5wpc.info/it/technical/web/2014/08/22/RoR"/>
   <updated>2014-08-22T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/technical/web/2014/08/22/RoR</id>
   <content type="html">&lt;h1&gt;相关技术&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/it/technical/language/ruby/2013/01/30/RailsRecipes/&quot;&gt;Rails Recipes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/it/technical/language/ruby/2013/01/30/AdvancedRailsRecipes/&quot;&gt;Advanced Rails Recipes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/it/technical/language/ruby/2014/01/20/TDD/&quot;&gt;Rspec&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;系统优化&lt;/h1&gt;

&lt;h2&gt;小系统优化&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;分库分表&lt;/li&gt;
&lt;li&gt;读写分离&lt;/li&gt;
&lt;li&gt;DB数据内存化: 利用LRU进行部分内存化的优化处理, 这样便于数据局部性的处理

&lt;ul&gt;
&lt;li&gt;Redis&lt;/li&gt;
&lt;li&gt;MemoryCache&lt;/li&gt;
&lt;li&gt;开发时注意缓存同步&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;可用框架技术点&lt;/h1&gt;

&lt;h2&gt;MYSQL 数据库使用&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;# For server
sudo apt-get install mysql-server
# For mysql2 gem
sudo apt-get install libmysqlclient-dev
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;优先使用mysql2 gem&lt;/li&gt;
&lt;li&gt;注意从数据库到应用系统的整个编码体系

&lt;ul&gt;
&lt;li&gt;Database : UTF-8

&lt;ul&gt;
&lt;li&gt;Change default encoding: http://stackoverflow.com/questions/3513773/change-mysql-default-character-set-to-utf-8-in-my-cnf&lt;/li&gt;
&lt;li&gt;Add default database: https://www.digitalocean.com/community/tutorials/scaling-ruby-on-rails-setting-up-a-dedicated-mysql-server-part-2&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;传输解码 : UTF-8&lt;/li&gt;
&lt;li&gt;应用自身 : UTF-8&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;script src=&quot;https://gist.github.com/qianjigui/00502e6218a32526187f.js&quot;&gt;&lt;/script&gt;


&lt;h2&gt;Sidekiq 队列处理器&lt;/h2&gt;

&lt;h3&gt;Install&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;依赖的数据库:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  sudo add-apt-repository ppa:chris-lea/redis-server
  sudo apt-get install redis-server
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Gemfile:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  # For queue process
  gem &#39;sidekiq&#39;
  # sidekiq monitor
  gem &#39;sinatra&#39;, &#39;&amp;gt;= 1.3.0&#39;, :require =&amp;gt; nil
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;数据清理&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;rails console -e development&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ruby&quot;&gt;# Clear Sidekiq tasks
Sidekiq.redis { |conn| conn.flushdb }
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>Java 编译处理过程</title>
   <link href="http://www.5wpc.info/it/technical/language/java/2014/08/19/JavaCompileTransform"/>
   <updated>2014-08-19T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/technical/language/java/2014/08/19/JavaCompileTransform</id>
   <content type="html">&lt;h1&gt;预编译过程&lt;/h1&gt;

&lt;h2&gt;方案&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;现有方案: http://stackoverflow.com/questions/10483423/java-code-transform-at-compile-time

&lt;ul&gt;
&lt;li&gt;http://projectlombok.org/features/index.html&lt;/li&gt;
&lt;li&gt;http://hllvm.group.iteye.com/group/topic/38188&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;利用Java 标注进行处理

&lt;ul&gt;
&lt;li&gt;http://deors.wordpress.com/2011/09/26/annotation-types/&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;将编译工具链进行连接整合, 一步步完成程序的生成

&lt;ul&gt;
&lt;li&gt;利用GCC做预编译处理, 将C风格的宏进行处理, 将结果存储为JAVA&lt;/li&gt;
&lt;li&gt;再由javac完成后续编译&lt;/li&gt;
&lt;li&gt;存在的问题是: java就是在针对c的语言问题上, 提出了一些编译简化过程. 如果通过工具链整合, 又会引入坏味道&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;评估方法&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;工程化支持: 工具链, IDE的支持效果&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>Android系统编译User/Eng等状态</title>
   <link href="http://www.5wpc.info/it/technical/os/android/security/2014/06/16/BuildType"/>
   <updated>2014-06-16T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/technical/os/android/security/2014/06/16/BuildType</id>
   <content type="html">&lt;h1&gt;ADB服务管理&lt;/h1&gt;

&lt;p&gt;目前网络上有各种应用会通过adb通道对系统进行静默安装应用. 例如: &lt;a href=&quot;http://www.huxiu.com/article/35648/1.html&quot;&gt;App adb install&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Android系统针对adb有如下管理策略:
* 在4.2.2版本后,针对所有连接设备的应用都需要使用者在设备上进行确认.而且是分设备与MAC进行权限管理
* 在Android 4.2等设备上有针对adb管理的开发者模式. 通过该模式对adb debug权限进行管理
* Opensource的版本,针对eng/userdebug/user进行管理与放开adb权限&lt;/p&gt;

&lt;p&gt;如果需要从系统编译与编译环境控制的角度处理, 可以通过如下property进行管理.
* build:
    * &lt;code&gt;ro.debuggable&lt;/code&gt;
* system/core/rootdir/init.usb.rc
    * &lt;code&gt;sys.usb.config&lt;/code&gt;包含&lt;code&gt;adb&lt;/code&gt;选项(也是通过上面的编译系统一步步管理到这个参数的)&lt;/p&gt;

&lt;p&gt;如果需要在Opensource上管理并检查这些选项可以通过如下方法:
* 查找与&lt;code&gt;ro.debuggable&lt;/code&gt;相关在环境控制
     * 例如变量: &lt;code&gt;enable_target_debugging&lt;/code&gt;
* 查找initrc中的相关权限改变
* 添加开发者模式进行管理
* 临时关闭adb看效果: 在root下运行命令: &lt;code&gt;stop adbd&lt;/code&gt;&lt;/p&gt;

&lt;h1&gt;系统编译选项&lt;/h1&gt;

&lt;p&gt;下面的讨论基于标准Android 4.4代码.&lt;/p&gt;

&lt;h2&gt;user/userdebug/eng&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt; Built Type &lt;/th&gt;
&lt;th&gt; 具体影响 &lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt; eng          &lt;/td&gt;
&lt;td&gt; This is the default flavor. A plain &quot;make&quot; is the same as &quot;make eng&quot;. droid is an alias for eng.  Installs modules tagged with: eng, debug, user, and/or development.  Installs non-APK modules that have no tags specified.  Installs APKs according to the product definition files, in addition to tagged APKs. &lt;code&gt;ro.secure=0 ro.debuggable=1 ro.kernel.android.checkjni=1&lt;/code&gt; adb is enabled by default. &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; user &lt;/td&gt;
&lt;td&gt; &quot;make user&quot; This is the flavor intended to be the final release bits.  Installs modules tagged with user.  Installs non-APK modules that have no tags specified.  Installs APKs according to the product definition files; tags are ignored for APK modules.  &lt;code&gt;ro.secure=1 ro.debuggable=0&lt;/code&gt; adb is disabled by default.  &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; userdebug &lt;/td&gt;
&lt;td&gt; &quot;make userdebug&quot; The same as user, except: Also installs modules tagged with debug.  &lt;code&gt;ro.debuggable=1&lt;/code&gt; adb is enabled by default.  &lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;


&lt;h3&gt;Eng&lt;/h3&gt;

&lt;p&gt;编译时的默认选项&lt;/p&gt;

&lt;h3&gt;User&lt;/h3&gt;

&lt;p&gt;最后用于产品生成的发布版本&lt;/p&gt;

&lt;h3&gt;UserDebug&lt;/h3&gt;

&lt;p&gt;与User版本相同,　添加adb服务&lt;/p&gt;

&lt;h2&gt;关键property分析&lt;/h2&gt;

&lt;h3&gt;&lt;code&gt;ro.secure&lt;/code&gt;&lt;/h3&gt;

&lt;h4&gt;源代码涉及的修改&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;./frameworks/base/services/java/com/android/server/wm/WindowManagerService.java:    private static final String SYSTEM_SECURE = &quot;ro.secure&quot;;
./frameworks/base/core/java/android/net/http/AndroidHttpClient.java:                // Never print auth token -- we used to check ro.secure=0 to
./bionic/libc/bionic/system_properties.c: * binary tree.  For instance, &quot;ro.secure&quot;=&quot;1&quot; could be stored as follows:
./bionic/libc/bionic/system_properties.c: *                     v        v            v     +--------&amp;gt;| ro.secure |
./build/core/main.mk:  ADDITIONAL_DEFAULT_PROPERTIES += ro.secure=1
./build/core/main.mk:  ADDITIONAL_DEFAULT_PROPERTIES += ro.secure=0
./build/core/build-system.html:        &amp;lt;li&amp;gt;&amp;lt;code&amp;gt;ro.secure=0&amp;lt;/code&amp;gt;
./build/core/build-system.html:        &amp;lt;li&amp;gt;&amp;lt;code&amp;gt;ro.secure=1&amp;lt;/code&amp;gt;
./system/core/adb/adb.c:   /* run adbd in secure mode if ro.secure is set and
./system/core/adb/adb.c:        property_get(&quot;ro.secure&quot;, value, &quot;1&quot;);
./system/core/adb/adb.c:            // don&#39;t run as root if ro.secure is set...
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;具体作用总结&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;build/xxx: 环境设置&lt;/li&gt;
&lt;li&gt;system/xxx/adb.c: 如果=1,&lt;code&gt;adb root&lt;/code&gt;将无法成功. 还有其它的附加条件除外.&lt;/li&gt;
&lt;li&gt;WindowManagerService: 用于管理viewserver(Hierarchy Viewer) http://blog.csdn.net/michaelpp/article/details/12611787&lt;/li&gt;
&lt;li&gt;AndroidHttpClient: 在=1时,不会在log中dump auth token&lt;/li&gt;
&lt;li&gt;bionic/xxx/system_properties.c: 介绍properties存储结构时用的例子&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;&lt;code&gt;ro.debuggable&lt;/code&gt;&lt;/h3&gt;

&lt;h4&gt;源代码涉及的修改&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;./bootable/recovery/adb_install.cpp:    int len = property_get(&quot;ro.debuggable&quot;, value, NULL);
./bootable/recovery/etc/init.rc:on property:ro.debuggable=1
./build/core/build-system.html:        &amp;lt;li&amp;gt;&amp;lt;code&amp;gt;ro.debuggable=0&amp;lt;/code&amp;gt;
./build/core/build-system.html:        &amp;lt;li&amp;gt;&amp;lt;code&amp;gt;ro.debuggable=1&amp;lt;/code&amp;gt;
./build/core/build-system.html:        &amp;lt;li&amp;gt;&amp;lt;code&amp;gt;ro.debuggable=1&amp;lt;/code&amp;gt;
./build/core/main.mk:  ADDITIONAL_DEFAULT_PROPERTIES += ro.debuggable=0
./build/core/main.mk:  ADDITIONAL_DEFAULT_PROPERTIES += ro.debuggable=1
./build/tools/post_process_props.py:  # If ro.debuggable is 1, then enable adb on USB by default
./build/tools/post_process_props.py:  if prop.get(&quot;ro.debuggable&quot;) == &quot;1&quot;:
./dalvik/docs/debugger.html:for all applications when the system property &amp;lt;code&amp;gt;ro.debuggable&amp;lt;/code&amp;gt;
./dalvik/docs/debugger.html:is set to &amp;lt;/code&amp;gt;1&amp;lt;/code&amp;gt; (use &amp;lt;code&amp;gt;adb shell getprop ro.debuggable&amp;lt;/code&amp;gt;
./device/samsung/manta/init.manta.rc:on property:ro.debuggable=1
./external/libnfc-nxp/Linux_x86/phDal4Nfc.c:    property_get(&quot;ro.debuggable&quot;, value, &quot;&quot;);
./external/openssh/servconf.c:  /* Allow root login if ro.debuggable is set */
./external/openssh/servconf.c:  property_get(&quot;ro.debuggable&quot;, value, &quot;&quot;);
./frameworks/av/services/audioflinger/AudioFlinger.cpp:    (void) property_get(&quot;ro.debuggable&quot;, value, &quot;0&quot;);
./frameworks/base/core/java/android/net/SSLCertificateSocketFactory.java:        return &quot;1&quot;.equals(SystemProperties.get(&quot;ro.debuggable&quot;)) &amp;amp;&amp;amp;
./frameworks/base/core/java/android/os/Build.java:            SystemProperties.getInt(&quot;ro.debuggable&quot;, 0) == 1;
./frameworks/base/core/java/com/android/internal/os/ZygoteConnection.java:        if (&quot;1&quot;.equals(SystemProperties.get(&quot;ro.debuggable&quot;))) {
./frameworks/base/core/java/com/android/internal/os/ZygoteConnection.java:     * If &quot;ro.debuggable&quot; is &quot;1&quot;, all apps are debuggable. Otherwise,
./frameworks/base/policy/src/com/android/internal/policy/impl/PhoneWindowManager.java:        mEnableShiftMenuBugReports = &quot;1&quot;.equals(SystemProperties.get(&quot;ro.debuggable&quot;));
./frameworks/base/services/java/com/android/server/BootReceiver.java:        SystemProperties.getInt(&quot;ro.debuggable&quot;, 0) == 1 ? 98304 : 65536;
./frameworks/base/services/java/com/android/server/am/ActivityManagerService.java:    private static final String SYSTEM_DEBUGGABLE = &quot;ro.debuggable&quot;;
./frameworks/base/services/java/com/android/server/wm/WindowManagerService.java:    private static final String SYSTEM_DEBUGGABLE = &quot;ro.debuggable&quot;;
./frameworks/native/opengl/libs/EGL/egl.cpp:        property_get(&quot;ro.debuggable&quot;, value, &quot;0&quot;);
./packages/services/Telephony/src/com/android/phone/AudioRouter.java:            (PhoneGlobals.DBG_LEVEL &amp;gt;= 1) &amp;amp;&amp;amp; (SystemProperties.getInt(&quot;ro.debuggable&quot;, 0) == 1);
./packages/services/Telephony/src/com/android/phone/BluetoothManager.java:            (PhoneGlobals.DBG_LEVEL &amp;gt;= 1) &amp;amp;&amp;amp; (SystemProperties.getInt(&quot;ro.debuggable&quot;, 0) == 1);
./packages/services/Telephony/src/com/android/phone/BluetoothPhoneService.java:            &amp;amp;&amp;amp; (SystemProperties.getInt(&quot;ro.debuggable&quot;, 0) == 1);
./packages/services/Telephony/src/com/android/phone/CallCommandService.java:            (PhoneGlobals.DBG_LEVEL &amp;gt;= 1) &amp;amp;&amp;amp; (SystemProperties.getInt(&quot;ro.debuggable&quot;, 0) == 1);
./packages/services/Telephony/src/com/android/phone/CallController.java:            (PhoneGlobals.DBG_LEVEL &amp;gt;= 1) &amp;amp;&amp;amp; (SystemProperties.getInt(&quot;ro.debuggable&quot;, 0) == 1);
./packages/services/Telephony/src/com/android/phone/CallHandlerServiceProxy.java:            &quot;ro.debuggable&quot;, 0) == 1);
./packages/services/Telephony/src/com/android/phone/CallLogger.java:        (SystemProperties.getInt(&quot;ro.debuggable&quot;, 0) == 1);
./packages/services/Telephony/src/com/android/phone/CallModeler.java:            (PhoneGlobals.DBG_LEVEL &amp;gt;= 1) &amp;amp;&amp;amp; (SystemProperties.getInt(&quot;ro.debuggable&quot;, 0) == 1);
./packages/services/Telephony/src/com/android/phone/CallNotifier.java:            (PhoneGlobals.DBG_LEVEL &amp;gt;= 1) &amp;amp;&amp;amp; (SystemProperties.getInt(&quot;ro.debuggable&quot;, 0) == 1);
./packages/services/Telephony/src/com/android/phone/CallStateMonitor.java:            (PhoneGlobals.DBG_LEVEL &amp;gt;= 1) &amp;amp;&amp;amp; (SystemProperties.getInt(&quot;ro.debuggable&quot;, 0) == 1);
./packages/services/Telephony/src/com/android/phone/CallerInfoCache.java:            (PhoneGlobals.DBG_LEVEL &amp;gt;= 1) &amp;amp;&amp;amp; (SystemProperties.getInt(&quot;ro.debuggable&quot;, 0) == 1);
./packages/services/Telephony/src/com/android/phone/CallerInfoCacheUpdateReceiver.java:            (PhoneGlobals.DBG_LEVEL &amp;gt;= 1) &amp;amp;&amp;amp; (SystemProperties.getInt(&quot;ro.debuggable&quot;, 0) == 1);
./packages/services/Telephony/src/com/android/phone/CdmaDisplayInfo.java:    private static final boolean DBG = (SystemProperties.getInt(&quot;ro.debuggable&quot;, 0) == 1);
./packages/services/Telephony/src/com/android/phone/InCallScreenShowActivation.java:                    &amp;amp;&amp;amp; (SystemProperties.getInt(&quot;ro.debuggable&quot;, 0) == 1)) {
./packages/services/Telephony/src/com/android/phone/InCallScreenShowActivation.java:            (PhoneGlobals.DBG_LEVEL &amp;gt;= 1) &amp;amp;&amp;amp; (SystemProperties.getInt(&quot;ro.debuggable&quot;, 0) == 1);
./packages/services/Telephony/src/com/android/phone/NotificationMgr.java:            (PhoneGlobals.DBG_LEVEL &amp;gt;= 1) &amp;amp;&amp;amp; (SystemProperties.getInt(&quot;ro.debuggable&quot;, 0) == 1);
./packages/services/Telephony/src/com/android/phone/OutgoingCallBroadcaster.java:            (PhoneGlobals.DBG_LEVEL &amp;gt;= 1) &amp;amp;&amp;amp; (SystemProperties.getInt(&quot;ro.debuggable&quot;, 0) == 1);
./packages/services/Telephony/src/com/android/phone/PhoneGlobals.java:            (PhoneGlobals.DBG_LEVEL &amp;gt;= 1) &amp;amp;&amp;amp; (SystemProperties.getInt(&quot;ro.debuggable&quot;, 0) == 1);
./packages/services/Telephony/src/com/android/phone/PhoneGlobals.java:     *   (PhoneApp.DBG_LEVEL &amp;gt;= 1) &amp;amp;&amp;amp; (SystemProperties.getInt(&quot;ro.debuggable&quot;, 0) == 1)
./packages/services/Telephony/src/com/android/phone/PhoneGlobals.java:     *   1 - normal debug logging if ro.debuggable is set (which is true in
./packages/services/Telephony/src/com/android/phone/RespondViaSmsManager.java:            (PhoneGlobals.DBG_LEVEL &amp;gt;= 1) &amp;amp;&amp;amp; (SystemProperties.getInt(&quot;ro.debuggable&quot;, 0) == 1);
./packages/services/Telephony/src/com/android/phone/Ringer.java:            (PhoneGlobals.DBG_LEVEL &amp;gt;= 1) &amp;amp;&amp;amp; (SystemProperties.getInt(&quot;ro.debuggable&quot;, 0) == 1);
./packages/services/Telephony/src/com/android/phone/SipCallOptionHandler.java:            (PhoneGlobals.DBG_LEVEL &amp;gt;= 1) &amp;amp;&amp;amp; (SystemProperties.getInt(&quot;ro.debuggable&quot;, 0) == 1);
./packages/services/Telephony/src/com/android/phone/WiredHeadsetManager.java:            (PhoneGlobals.DBG_LEVEL &amp;gt;= 1) &amp;amp;&amp;amp; (SystemProperties.getInt(&quot;ro.debuggable&quot;, 0) == 1);
./sdk/eclipse/plugins/com.android.ide.eclipse.adt/src/com/android/ide/eclipse/adt/internal/launch/AndroidLaunchController.java:                        // because am -D does not check for ro.debuggable and the
./system/core/adb/adb.c:            property_get(&quot;ro.debuggable&quot;, value, &quot;&quot;);
./system/core/adb/adb.c:    property_get(&quot;ro.debuggable&quot;, value, &quot;&quot;);
./system/core/adb/services.c:        property_get(&quot;ro.debuggable&quot;, value, &quot;&quot;);
./system/core/debuggerd/tombstone.c:    property_get(&quot;ro.debuggable&quot;, value, &quot;0&quot;);
./system/core/include/cutils/trace.h: * level tracing is not allowed unless the ro.debuggable system property is
./system/core/init/property_service.c:    ret = property_get(&quot;ro.debuggable&quot;, debuggable);
./system/core/libcutils/trace.c:    property_get(&quot;ro.debuggable&quot;, value, &quot;0&quot;);
./system/core/libcutils/trace.c:// application-level tracing is allowed when the ro.debuggable system property
./system/core/rootdir/init.rc:on property:ro.debuggable=1
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;具体作用总结&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;./bootable/recovery/adb_install.cpp: debuggable 开启时,才可以成功重启adb&lt;/li&gt;
&lt;li&gt;./build/xxxx : debuggable 数据设置&lt;/li&gt;
&lt;li&gt;./dalvik/xxx : 在dalvik中,如果debuggable为0, 仅AndroidManifest.xml中含有debuggable 才会支持jdwp调试&lt;/li&gt;
&lt;li&gt;./external/libnfc-nxp/Linux_x86/phDal4Nfc.c : NFC调试支持开关&lt;/li&gt;
&lt;li&gt;./external/openssh/servconf.c: openssh 允许root访问开关&lt;/li&gt;
&lt;li&gt;./frameworks/av/services/audioflinger/AudioFlinger.cpp: Audio Debug 开关&lt;/li&gt;
&lt;li&gt;./frameworks/base/core/java/android/net/SSLCertificateSocketFactory.java: SSL check 开关&lt;/li&gt;
&lt;li&gt;./frameworks/base/core/java/android/os/Build.java: IS_DEBUGGABLE环境变量控制&lt;/li&gt;
&lt;li&gt;./frameworks/base/core/java/com/android/internal/os/ZygoteConnection.java: App debuggable 开关, 如果=1, 所有应用都将进行debug支持&lt;/li&gt;
&lt;li&gt;./frameworks/base/policy/src/com/android/internal/policy/impl/PhoneWindowManager.java: mEnableShiftMenuBugReports 支持&lt;/li&gt;
&lt;li&gt;./frameworks/base/services/java/com/android/server/BootReceiver.java: logged event size 控制, =1 存储量大&lt;/li&gt;
&lt;li&gt;./frameworks/base/services/java/com/android/server/am/ActivityManagerService.java: 系统DEBUG状态

&lt;ul&gt;
&lt;li&gt;do Bug report&lt;/li&gt;
&lt;li&gt;OpenGLTrace&lt;/li&gt;
&lt;li&gt;App Profile&lt;/li&gt;
&lt;li&gt;App Heap Dump&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;./frameworks/base/services/java/com/android/server/wm/WindowManagerService.java:  系统DEBUG状态

&lt;ul&gt;
&lt;li&gt;与ro.secure 一起管理viewserver&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;./frameworks/native/opengl/libs/EGL/egl.cpp: EGL debug&lt;/li&gt;
&lt;li&gt;LOGD 开关:

&lt;ul&gt;
&lt;li&gt;./packages/services/Telephony/src/com/android/phone/AudioRouter.java:&lt;/li&gt;
&lt;li&gt;./packages/services/Telephony/src/com/android/phone/BluetoothManager.java:&lt;/li&gt;
&lt;li&gt;./packages/services/Telephony/src/com/android/phone/BluetoothPhoneService.java&lt;/li&gt;
&lt;li&gt;./packages/services/Telephony/src/com/android/phone/CallCommandService.java&lt;/li&gt;
&lt;li&gt;./packages/services/Telephony/src/com/android/phone/CallController.java&lt;/li&gt;
&lt;li&gt;./packages/services/Telephony/src/com/android/phone/CallHandlerServiceProxy.java&lt;/li&gt;
&lt;li&gt;./packages/services/Telephony/src/com/android/phone/CallLogger.java&lt;/li&gt;
&lt;li&gt;./packages/services/Telephony/src/com/android/phone/CallModeler.java&lt;/li&gt;
&lt;li&gt;./packages/services/Telephony/src/com/android/phone/CallNotifier.java&lt;/li&gt;
&lt;li&gt;./packages/services/Telephony/src/com/android/phone/CallStateMonitor.java&lt;/li&gt;
&lt;li&gt;./packages/services/Telephony/src/com/android/phone/CallerInfoCache.java&lt;/li&gt;
&lt;li&gt;./packages/services/Telephony/src/com/android/phone/CallerInfoCacheUpdateReceiver.java&lt;/li&gt;
&lt;li&gt;./packages/services/Telephony/src/com/android/phone/CdmaDisplayInfo.java&lt;/li&gt;
&lt;li&gt;./packages/services/Telephony/src/com/android/phone/InCallScreenShowActivation.java&lt;/li&gt;
&lt;li&gt;./packages/services/Telephony/src/com/android/phone/InCallScreenShowActivation.java&lt;/li&gt;
&lt;li&gt;./packages/services/Telephony/src/com/android/phone/NotificationMgr.java&lt;/li&gt;
&lt;li&gt;./packages/services/Telephony/src/com/android/phone/OutgoingCallBroadcaster.java&lt;/li&gt;
&lt;li&gt;./packages/services/Telephony/src/com/android/phone/PhoneGlobals.java&lt;/li&gt;
&lt;li&gt;./packages/services/Telephony/src/com/android/phone/PhoneGlobals.java&lt;/li&gt;
&lt;li&gt;./packages/services/Telephony/src/com/android/phone/PhoneGlobals.java&lt;/li&gt;
&lt;li&gt;./packages/services/Telephony/src/com/android/phone/RespondViaSmsManager.java&lt;/li&gt;
&lt;li&gt;./packages/services/Telephony/src/com/android/phone/Ringer.java&lt;/li&gt;
&lt;li&gt;./packages/services/Telephony/src/com/android/phone/SipCallOptionHandler.java&lt;/li&gt;
&lt;li&gt;./packages/services/Telephony/src/com/android/phone/WiredHeadsetManager.java&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;./sdk/eclipse/plugins/com.android.ide.eclipse.adt/src/com/android/ide/eclipse/adt/internal/launch/AndroidLaunchController.java: ADT app debug launcher 支持&lt;/li&gt;
&lt;li&gt;./system/core/adb/adb.c: adb root permission&lt;/li&gt;
&lt;li&gt;./system/core/adb/services.c: adb root permission&lt;/li&gt;
&lt;li&gt;./system/core/debuggerd/tombstone.c: dump_crash want log if =1&lt;/li&gt;
&lt;li&gt;./system/core/init/property_service.c: Allow local property overwrite ro.debuggerd value&lt;/li&gt;
&lt;li&gt;./system/core/libcutils/trace.c : app trace on/off&lt;/li&gt;
&lt;li&gt;./system/core/rootdir/init.rc: adbd服务开启控制&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;&lt;code&gt;ro.kernel.android.checkjni&lt;/code&gt;&lt;/h3&gt;

&lt;h4&gt;源代码涉及的修改&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;./frameworks/base/core/jni/AndroidRuntime.cpp:        property_get(&quot;ro.kernel.android.checkjni&quot;, propBuf, &quot;&quot;);
./dalvik/docs/embedded-vm-control.html:first is &amp;lt;code&amp;gt;ro.kernel.android.checkjni&amp;lt;/code&amp;gt;.  This is set by the
./dalvik/docs/embedded-vm-control.html:of this overrides the value from &amp;lt;code&amp;gt;ro.kernel.android.checkjni&amp;lt;/code&amp;gt;.
./build/core/main.mk:  ADDITIONAL_BUILD_PROPERTIES += ro.kernel.android.checkjni=1
./build/core/build-system.html:        &amp;lt;li&amp;gt;&amp;lt;code&amp;gt;ro.kernel.android.checkjni=1&amp;lt;/code&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;具体作用总结&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;./frameworks/base/core/jni/AndroidRuntime.cpp: checkJNI value load&lt;/li&gt;
&lt;li&gt;dalvik/xxx: Java VM CheckJNI on/off&lt;/li&gt;
&lt;li&gt;build/xxx: checkJNI 状态设置&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;总结&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;ro.secure : 系统安全相关的属性控制开关

&lt;ul&gt;
&lt;li&gt;adb 的 ROOT 权限&lt;/li&gt;
&lt;li&gt;viewserver(Hierarchy Viewer) 的开关&lt;/li&gt;
&lt;li&gt;系统各模块敏感信息dump的控制: http auth token&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ro.debuggable : 系统debug状态控制

&lt;ul&gt;
&lt;li&gt;关键调试服务ADB的管理: 是否可root, 是否开机时运行&lt;/li&gt;
&lt;li&gt;viewserver(Hierarchy Viewer) 的开关&lt;/li&gt;
&lt;li&gt;系统各模块debug信息开关:

&lt;ul&gt;
&lt;li&gt;应用内部log控制dump&lt;/li&gt;
&lt;li&gt;Audio Debug, SSL Check, NFC, OpenGL EGL 等level的dump, logged event size, atrace, mEnableShiftMenuBugReports&lt;/li&gt;
&lt;li&gt;系统级各 APP 级别状态: profile, jdwp-debug, heap dump, OpenGL Trace&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ro.kernel.android.checkjni

&lt;ul&gt;
&lt;li&gt;Java VM checkJNI on/off&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>Java内部类的状态</title>
   <link href="http://www.5wpc.info/it/technical/language/java/2014/06/02/InnerClass"/>
   <updated>2014-06-02T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/technical/language/java/2014/06/02/InnerClass</id>
   <content type="html">&lt;h1&gt;一个例子&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public class B{
    private int tc;
    public B(int c){
        tc = c;
    }
    public void a(){
        final int cc = (new C(5)).c;
        new Thread() {
            @Override
                public void run() {
                    System.out.println(String.valueOf(cc));
                }
        }.start();
    }
    public static void main(String[] args){
        (new B(23)).a();
        int i =(new D()).d;
    }

    class C{
        int c;
        public C(int i){
            c=i;
        }
    }

    static class D{
        int d;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;B$C:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;Compiled from &quot;B.java&quot;
class B$C extends java.lang.Object{
int c;

final B this$0;

public B$C(B, int);
  Code:
   0:   aload_0
   1:   aload_1
   2:   putfield    #1; //Field this$0:LB;
   5:   aload_0
   6:   invokespecial   #2; //Method java/lang/Object.&quot;&amp;lt;init&amp;gt;&quot;:()V
   9:   aload_0
   10:  iload_2
   11:  putfield    #3; //Field c:I
   14:  return
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;B$D:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;Compiled from &quot;B.java&quot;
class B$D extends java.lang.Object{
int d;

B$D();
  Code:
   0:   aload_0
   1:   invokespecial   #1; //Method java/lang/Object.&quot;&amp;lt;init&amp;gt;&quot;:()V
   4:   return

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;静态内部类&lt;/h1&gt;

&lt;p&gt;不会添加对外部类的对象的引用.&lt;/p&gt;

&lt;h1&gt;普通内部类&lt;/h1&gt;

&lt;p&gt;与匿名内部类相同, 会在内部动态添加对父亲对象的引用.&lt;/p&gt;

&lt;h1&gt;匿名内部类&lt;/h1&gt;

&lt;p&gt;匿名内部类中, 通过编译器添加了成员变量保存final产生的数据.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public class B{
    private int tc;
    public B(int c){
        tc = c;
    }
    public void a(){
        final int cc = tc;
        new Thread() {
            @Override
                public void run() {
                    System.out.println(String.valueOf(cc));
                }
        }.start();
    }
    public static void main(String[] args){
        (new B(23)).a();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;Compiled from &quot;B.java&quot;
class B$1 extends java.lang.Thread{
final int val$cc;

final B this$0;

B$1(B, int);
  Code:
   0:   aload_0
   1:   aload_1
   2:   putfield        #1; //Field this$0:LB;
   5:   aload_0
   6:   iload_2
   7:   putfield        #2; //Field val$cc:I
   10:  aload_0
   11:  invokespecial   #3; //Method java/lang/Thread.&quot;&amp;lt;init&amp;gt;&quot;:()V
   14:  return

public void run();
  Code:
   0:   getstatic       #4; //Field java/lang/System.out:Ljava/io/PrintStream;
   3:   aload_0
   4:   getfield        #2; //Field val$cc:I
   7:   invokestatic    #5; //Method java/lang/String.valueOf:(I)Ljava/lang/String;
   10:  invokevirtual   #6; //Method java/io/PrintStream.println:(Ljava/lang/String;)V
   13:  return

}
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>Android系统内存优化学习</title>
   <link href="http://www.5wpc.info/it/technical/os/android/memoryopt/2014/05/22/index.memoryopt"/>
   <updated>2014-05-22T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/technical/os/android/memoryopt/2014/05/22/index.memoryopt</id>
   <content type="html">&lt;h1&gt;学习过程中涉及的问题点&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;内存泄漏的核心问题: 长生命周期(存活)object引用了短生命周期object

&lt;ol&gt;
&lt;li&gt;Android系统Google开发环境提供的编程环境是Context+Logic的开发模式, 在这种模式下程序员容易将一些生命周期不一致的object进行关联,导致内在泄漏&lt;/li&gt;
&lt;li&gt;需要注意Java语言级别的生命周期与框架的对应与关系&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;

</content>
 </entry>
 
 <entry>
   <title>Android系统运行环境启动学习</title>
   <link href="http://www.5wpc.info/it/technical/os/android/init/2014/05/22/index"/>
   <updated>2014-05-22T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/technical/os/android/init/2014/05/22/index</id>
   <content type="html">&lt;h1&gt;学习过程中涉及的问题点&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;SystemServer 中系统各个服务的启动过程&lt;/li&gt;
&lt;li&gt;ActivityManager 启动 HOMESHELL 的过程&lt;/li&gt;
&lt;li&gt;各阶段的主要点:PRELOADER, BOOT, LINUX, Android&lt;/li&gt;
&lt;/ol&gt;

</content>
 </entry>
 
 <entry>
   <title>Android Native Executable 模块编译过程学习</title>
   <link href="http://www.5wpc.info/it/technical/os/android/build/2014/03/12/executable"/>
   <updated>2014-03-12T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/technical/os/android/build/2014/03/12/executable</id>
   <content type="html">&lt;h1&gt;一个例子&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Android.mk :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;`&quot;&gt; LOCAL_PATH := $(call my-dir)
 include $(CLEAR_VARS)
 LOCAL_SRC_FILES := main.c
 LOCAL_MODULE := mm_test_execute
 iLOCAL_FORCE_STATIC_EXECUTABLE :=true
 include $(BUILD_EXECUTABLE)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;关键依赖模块&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;`&quot;&gt;         Successfully remade target file `out/target/product/maguro/obj/EXECUTABLES/mm_test_execute_intermediates/import_includes&#39;.
         Successfully remade target file `all_copied_headers&#39;.
       Successfully remade target file `out/target/product/maguro/obj/EXECUTABLES/mm_test_execute_intermediates/main.o&#39;.
     Successfully remade target file `out/target/product/maguro/obj/EXECUTABLES/mm_test_execute_intermediates/LINKED/mm_test_execute&#39;.
   Successfully remade target file `out/target/product/maguro/symbols/system/bin/mm_test_execute&#39;.
   Successfully remade target file `out/target/product/maguro/obj/EXECUTABLES/mm_test_execute_intermediates/export_includes&#39;.
 Successfully remade target file `out/target/product/maguro/obj/EXECUTABLES/mm_test_execute_intermediates/mm_test_execute&#39;.
   Successfully remade target file `NOTICE-TARGET-STATIC_LIBRARIES-libcompiler-rt-extras&#39;.
 Successfully remade target file `out/target/product/maguro/system/bin/mm_test_execute&#39;.
Successfully remade target file `mm_test_execute&#39;.
Successfully remade target file `all_modules&#39;.
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;import_includes

&lt;ol&gt;
&lt;li&gt;根据配置文件中描述的依赖的动态与静态库, 引入其模块产生的export_includes文件的内容.&lt;/li&gt;
&lt;li&gt;以产生需要的头文件&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;all_copied_headers&lt;/li&gt;
&lt;li&gt;x.o&lt;/li&gt;
&lt;li&gt;LINKED file&lt;/li&gt;
&lt;li&gt;Symbol file&lt;/li&gt;
&lt;li&gt;export_includes

&lt;ol&gt;
&lt;li&gt;产生export_includes 文件&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;file&lt;/li&gt;
&lt;li&gt;install file&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;内部的主要实现&lt;/h1&gt;

&lt;h2&gt;支持的源代码级文件&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;$(asm_objects)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$(cpp_objects)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$(gen_cpp_objects)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$(gen_asm_objects)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$(c_objects)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$(gen_c_objects)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$(objc_objects)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$(yacc_objects)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$(lex_objects)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$(proto_generated_objects)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;开发者需要关注的API&lt;/h1&gt;

&lt;h2&gt;可以使用的工具&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://code.google.com/p/aprof/&quot;&gt;Android Profile&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;LOCAL_ENABLE_APROF&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;强制将依赖的动态库(目前仅用于/sbin/下的相关文件,libc库)合并为静态库

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;LOCAL_FORCE_STATIC_EXECUTABLE :=true&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>Android 编译系统整体结构</title>
   <link href="http://www.5wpc.info/it/technical/os/android/build/2014/03/12/GlobalStructure"/>
   <updated>2014-03-12T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/technical/os/android/build/2014/03/12/GlobalStructure</id>
   <content type="html">&lt;h1&gt;一张全景图&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/assets/svgfiles/AndroidBuildSystemGlobalIncludeview.svg&quot; alt=&quot;Android Build System Global include relationship&quot; /&gt;&lt;/p&gt;

&lt;h2&gt;注意细节&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;请复制URL单独打开&lt;/li&gt;
&lt;li&gt;从文件名级别就可以看出整个体系结构的清晰

&lt;ol&gt;
&lt;li&gt;与系统环境与状态设置相关的main.mk&lt;/li&gt;
&lt;li&gt;与具体编译业务相关的模块, 这些模块均依赖于base_rules.mk&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;主要工作流程&lt;/h1&gt;

&lt;h2&gt;从mm开始&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;make从main.mk进入编译系统

&lt;ul&gt;
&lt;li&gt;其中的&lt;code&gt;ONE_SHOT_MAKEFILE&lt;/code&gt;变量已经设定值为mm对应目前的Android.mk的路径&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;main.mk中

&lt;ol&gt;
&lt;li&gt;整体使用的function定义(definitions.mk)&lt;/li&gt;
&lt;li&gt;环境配置(config.mk)&lt;/li&gt;
&lt;li&gt;编译依赖的检查&lt;/li&gt;
&lt;li&gt;进入&lt;code&gt;ONE_SHOT_MAKEFILE&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;ONE_SHOT_MAKEFILE

&lt;ol&gt;
&lt;li&gt;CLEAR_VARS&lt;/li&gt;
&lt;li&gt;LOCAL_* 相关参数设置&lt;/li&gt;
&lt;li&gt;关键点: &lt;code&gt;BUILD_XXXXXX&lt;/code&gt;

&lt;ol&gt;
&lt;li&gt;例如: build/core/executable.mk&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;模块分析&lt;/h1&gt;

&lt;h2&gt;基础模块分析&lt;/h2&gt;

&lt;h3&gt;lunch&lt;/h3&gt;

&lt;p&gt;这个阶段,shell竟然使用了make过程中的&lt;code&gt;$(info xxx)&lt;/code&gt;进行上下文构建.&lt;/p&gt;

&lt;h3&gt;base_rules.mk&lt;/h3&gt;

&lt;h3&gt;功能&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;选择中间产生文件与最终生成文件&lt;/li&gt;
&lt;li&gt;AIDL Convert&lt;/li&gt;
&lt;li&gt;logtags&lt;/li&gt;
&lt;li&gt;proto Convert&lt;/li&gt;
&lt;li&gt;java compile&lt;/li&gt;
&lt;li&gt;添加通用FLAGS信息

&lt;ul&gt;
&lt;li&gt;AAPT&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;模块安装: 最后输出Install的地方

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;$(LOCAL_INSTALLED_MODULE): $(LOCAL_BUILT_MODULE) | $(ACP)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;odex&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h4&gt;Input&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;LOCAL_MODULE&lt;/li&gt;
&lt;li&gt;LOCAL_MODULE_TAGS&lt;/li&gt;
&lt;li&gt;LOCAL_MODULE_PATH&lt;/li&gt;
&lt;li&gt;Pick a name for the intermediate and final targets

&lt;ul&gt;
&lt;li&gt;LOCAL_MODULE_STEM&lt;/li&gt;
&lt;li&gt;LOCAL_MODULE_SUFFIX&lt;/li&gt;
&lt;li&gt;LOCAL_BUILT_MODULE_STEM&lt;/li&gt;
&lt;li&gt;LOCAL_BUILT_MODULE&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;功能定制&lt;/h1&gt;

&lt;h2&gt;由谁确定最终安装的文件?&lt;/h2&gt;

&lt;p&gt;其中的主要流程是:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;PRODUCT_PACKAGES:

&lt;ul&gt;
&lt;li&gt;由两部分组成, 首先是build下的product标准项目模块集合, 再有是各个device自己添加的产品&lt;/li&gt;
&lt;li&gt;build/target/product/core.mk

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;all_product_configs := $(get-all-product-makefiles)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;get-all-product-makefiles return core.mk&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;product_MODULES&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; product_MODULES := $(PRODUCTS.$(INTERNAL_PRODUCT).PRODUCT_PACKAGES)
 product_MODULES := $(filter-out $(foreach p, $(product_MODULES), \
     $(PACKAGES.$(p).OVERRIDES)), $(product_MODULES))
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;product_FILES&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  product_FILES := $(call module-installed-files, $(product_MODULES))
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;modules_to_install&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; modules_to_install := $(sort \
     $(ALL_DEFAULT_INSTALLED_MODULES) \
     $(product_FILES) \
     $(foreach tag,$(tags_to_install),$($(tag)_MODULES)) \
     $(call get-tagged-modules, shell_$(TARGET_SHELL)) \
     $(CUSTOM_MODULES) \
   )
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;ALL_DEFAULT_INSTALLED_MODULES&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; ALL_DEFAULT_INSTALLED_MODULES := $(modules_to_install)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;make target 依赖关系&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;droid&lt;/li&gt;
&lt;li&gt;droidcore&lt;/li&gt;
&lt;li&gt;files&lt;/li&gt;
&lt;li&gt;modules_to_install&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h2&gt;LOCAL_MODULE_TAGS 的作用是什么&lt;/h2&gt;

&lt;p&gt;在 &lt;em&gt;build/core/build-system.html&lt;/em&gt; 文件中的描述为:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Set LOCAL_MODULE_TAGS to any number of whitespace-separated tags. If the tag list is empty or contains droid, the module will get installed as part of a make droid. Modules with the tag shell_$(TARGET_SHELL) will also be installed. Otherwise, it will only get installed by running make &amp;lt;your-module&amp;gt; or with the make all pseudotarget.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用于控制模块在哪些模式下会进行安装.
但是在Android 4.2 以后, 控制权已经交给了 &lt;code&gt;PRODUCT_PACKAGES&lt;/code&gt; 变量进行处理.&lt;/p&gt;

&lt;p&gt;Android 4.2 以后的具体的状态对应:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt; LOCAL_MODULE_TAGS 包含&lt;/th&gt;
&lt;th&gt; 作用 &lt;/th&gt;
&lt;th&gt; 目前起作用的方法 &lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt; user  &lt;/td&gt;
&lt;td&gt; 指定在User下进行安装 &lt;/td&gt;
&lt;td&gt; PRODUCT_PACKAGES &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; gnu   &lt;/td&gt;
&lt;td&gt; 模块是GPL/MPL 协议   &lt;/td&gt;
&lt;td&gt;                  &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; test,samples  &lt;/td&gt;
&lt;td&gt; 如果模块没有指定&lt;code&gt;LOCAL_MODULE_PATH&lt;/code&gt;, 设置&lt;code&gt;partition_tag&lt;/code&gt;为空, &lt;strong&gt;不安装&lt;/strong&gt; . &lt;/td&gt;
&lt;td&gt; LOCAL_MODULE_PATH &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; test  &lt;/td&gt;
&lt;td&gt; 可以用于指定proguard使用的配置文件, 可以控制AAPT的参数(-z 资源存在性检查), 关闭EMMA &lt;/td&gt;
&lt;td&gt;    &lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;


&lt;p&gt;目前Android4.2 上支持的值: &lt;code&gt;debug eng tests optional samples shell_ash shell_mksh&lt;/code&gt;,
没有赋值时, 默认数据为&lt;code&gt;optional&lt;/code&gt;.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>邮件客户端配置</title>
   <link href="http://www.5wpc.info/it/technical/pcmanage/2014/02/21/mail-client"/>
   <updated>2014-02-21T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/technical/pcmanage/2014/02/21/mail-client</id>
   <content type="html">&lt;h1&gt;ThunderBird&lt;/h1&gt;

&lt;h2&gt;Markdown Here配置&lt;/h2&gt;

&lt;p&gt;主要关注各结构的margin与padding&lt;/p&gt;

&lt;h2&gt;LDAP服务配置&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;prefs.js&quot;&gt;user_pref(&quot;ldap_2.autoComplete.directoryServer&quot;, &quot;ldap_2.servers.LDAP&quot;);
user_pref(&quot;ldap_2.autoComplete.useDirectory&quot;, true);
user_pref(&quot;ldap_2.servers.LDAP.auth.dn&quot;, &quot;xxx@xxx.com&quot;);
user_pref(&quot;ldap_2.servers.LDAP.auth.saslmech&quot;, &quot;&quot;);
user_pref(&quot;ldap_2.servers.LDAP.autoComplete.commentFormat&quot;, &quot;[displayName] [firstName] [surname]([givenName])([department])&quot;);
user_pref(&quot;ldap_2.servers.LDAP.autoComplete.nameFormat&quot;, &quot;[surname] [givenName]&quot;);
user_pref(&quot;ldap_2.servers.LDAP.description&quot;, &quot;LDAP&quot;);
user_pref(&quot;ldap_2.servers.LDAP.filename&quot;, &quot;ldap.mab&quot;);
user_pref(&quot;ldap_2.servers.LDAP.maxHits&quot;, 100);
user_pref(&quot;ldap_2.servers.LDAP.uri&quot;, &quot;ldaps://ldap.xxx-inc.com/DC=xxx,DC=com??sub?(objectclass=*)&quot;);
user_pref(&quot;ldap_2.servers.default.autoComplete.nameFormat&quot;, &quot;[displayName][givenName][firstName][department]&quot;);
user_pref(&quot;ldap_2.servers.eds.description&quot;, &quot;EDS Address Book Bootstrapper&quot;);
user_pref(&quot;ldap_2.servers.eds.dirType&quot;, 3);
user_pref(&quot;ldap_2.servers.eds.filename&quot;, &quot;eds.mab&quot;);
user_pref(&quot;ldap_2.servers.eds.position&quot;, 1);
user_pref(&quot;ldap_2.servers.eds.uri&quot;, &quot;moz-abedsdirectory://&quot;);
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>C 语言最佳实践</title>
   <link href="http://www.5wpc.info/it/technical/language/c/2014/01/28/CBestPractice"/>
   <updated>2014-01-28T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/technical/language/c/2014/01/28/CBestPractice</id>
   <content type="html">&lt;h1&gt;沙箱运行模式&lt;/h1&gt;

&lt;h2&gt;解决场景&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;不影响原运行环境&lt;/li&gt;
&lt;li&gt;获取运行结果状态&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;具体实现细节&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;父进程准备好&lt;em&gt;前文的状态&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;通过&lt;code&gt;fork&lt;/code&gt;调用子进程&lt;/li&gt;
&lt;li&gt;子进程处理&lt;/li&gt;
&lt;li&gt;父进程通过&lt;code&gt;waitpid&lt;/code&gt;进行等待, 并根据返回结果处理后续工作&lt;/li&gt;
&lt;/ul&gt;


&lt;script src=&quot;http://gist.github.com/qianjigui/8644808.js&quot;&gt;&lt;/script&gt;


&lt;h1&gt;上下文维持&lt;/h1&gt;

&lt;h2&gt;解决场景&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;防止程序重入&lt;/li&gt;
&lt;li&gt;Context 维持最简洁&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;具体实现细节&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;在实现时, 需要考虑根据&lt;em&gt;持久化数据&lt;/em&gt;的状态.&lt;/li&gt;
&lt;li&gt;步骤与任务间可以串行运行, 各任务间通过&lt;em&gt;事务&lt;/em&gt;的概念进行统一管理.&lt;/li&gt;
&lt;li&gt;在这种情况下, 事务实现时需要保证&lt;em&gt;可回滚&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;


&lt;script src=&quot;http://gist.github.com/qianjigui/8663359.js&quot;&gt;&lt;/script&gt;


&lt;h1&gt;网络通信处理&lt;/h1&gt;

&lt;h2&gt;网络传输&lt;/h2&gt;

&lt;h3&gt;相关支持库&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;libcurl&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;传输安全&lt;/h2&gt;

&lt;h3&gt;相关支持库&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;openssl&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;协议解析&lt;/h2&gt;

&lt;p&gt;其中的标准解决方案是: 针对协议规范制定标准语言文法描述, 通过编译原理的前端处理技术完成相关工作.
目前实现上述方案的有: Ragel, lex, yacc等标准生成引擎.&lt;/p&gt;

&lt;h3&gt;手工处理&lt;/h3&gt;

&lt;p&gt;类似于&lt;a href=&quot;/it/technical/language/ruby/2014/01/20/TextProcessing/&quot;&gt;Ruby文本处理方法&lt;/a&gt;, 目前主要讨论基于行解析的一些实践.
主要使用如下API:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;sscanf&lt;/li&gt;
&lt;li&gt;sgets&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;整体结构:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;int count=0;
int tcount=0;
char* multiline=&quot;Download: a\nDownload: b\nDownload: c\nRun: c\nRun: a\n&quot;;
char s[1024];
int tot = 0;
int b;
do{
    b=0;
    tcount +=(count=sscanf(multiline+tot,&quot;Download: %s\n%n&quot;,s,&amp;amp;b));
    if(count&amp;gt;0){
        //Process Download
    }
    tot += b;
    tcount +=(count=sscanf(multiline+tot,&quot;Run: %s\n%n&quot;,s,&amp;amp;b));
    if(count&amp;gt;0){
        //Process Run
    }
    tot += b;
}while(tcount&amp;gt;0);
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;Log&lt;/h1&gt;

&lt;h2&gt;Android NDK logger&lt;/h2&gt;

&lt;script src=&quot;http://gist.github.com/qianjigui/8910802.js&quot;&gt;&lt;/script&gt;


&lt;h1&gt;Other&lt;/h1&gt;

&lt;h2&gt;利用%n去处理sscanf 的移动&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;//http://stackoverflow.com/questions/4217583/sscanf-with-multiline-string
int byte_read=0;
int total_read=0;
while(EOF!=sscanf((const char*)(res+total_read), &quot;%s %d %n&quot;, name, &amp;amp;filesize, &amp;amp;byte_read)){
    total_read+=byte_read;
    LOGI(&quot;Name=%s, Size=%d&quot;,buff,filesize);
}
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>iOS 应用开发整体流程</title>
   <link href="http://www.5wpc.info/it/technical/os/ios/2014/01/23/app-develop-step"/>
   <updated>2014-01-23T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/technical/os/ios/2014/01/23/app-develop-step</id>
   <content type="html">&lt;h1&gt;入库AppStore流程&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/jwzbskywz/article/details/7730231&quot;&gt;iPhone应用提交流程：如何将App程序发布到App Store？&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Ruby文本处理相关实践</title>
   <link href="http://www.5wpc.info/it/technical/language/ruby/2014/01/20/TextProcessing"/>
   <updated>2014-01-20T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/technical/language/ruby/2014/01/20/TextProcessing</id>
   <content type="html">&lt;h1&gt;整体介绍&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;本文主要是对&amp;lt;Ruby最佳实践&gt;文本处理内容的再次复习&lt;/em&gt;.
具体读书笔记见&lt;a href=&quot;http://book.douban.com/people/qianjigui/annotation/4214148/&quot;&gt;douban&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;该章节目录如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ruby&quot;&gt;4. Text Processing and File Management
Line-Based File Processing with State Tracking
Regular Expressions
    Don’t Work Too Hard
    Anchors Are Your Friends
    Use Caution When Working with Quantifiers
Working with Files
    Using Pathname and FileUtils
The tempfile Standard Library
    Automatic Temporary Directory Handling
    Collision Avoidance
    Same Old I/O Operations
    Automatic Unlinking
Text-Processing Strategies
    Advanced Line Processing
    Atomic Saves
Conclusions
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;文中主要涉及如下处理方法与手段:
- 基于行的状态处理
- 正则表达式
- 文件处理的相关API
- 临时文件API
- 主要处理策略&lt;/p&gt;

&lt;h1&gt;具体实践方案&lt;/h1&gt;

&lt;h2&gt;基于行的带有状态的处理&lt;/h2&gt;

&lt;p&gt;主要特征如下:
- 通过一个完整的Context记录整体分析状态, 可以借助栈等数据结构进行有序支持.
- 每行有具体特征符号用于识别
- 利用状态机进行有上下关联的整合
- 对其它文本的报警与skip&lt;/p&gt;

&lt;p&gt;其实现的一般结构如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ruby&quot;&gt;case section
when [xxx,xxx]
   process
when [xxx,xxx]
   process
else
   process
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;基于正则表达式的处理&lt;/h2&gt;

&lt;p&gt;充分利用正则表达式的特性, 特别是 锚点, 分组与捕获.&lt;/p&gt;

&lt;p&gt;关于正则表达式的详细API见&lt;a href=&quot;/it/technical/language/ruby/2014/01/15/Regular/&quot;&gt;Regular&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;文件处理的API&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Pathname, Ruby 1.9

&lt;ul&gt;
&lt;li&gt;支持大量关于路径的操作与关系运算&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;FileUtils, Ruby 1.8&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;tempfile API&lt;/h2&gt;

&lt;p&gt;通过tempfile进行中间状态的保存与过渡.&lt;/p&gt;

&lt;p&gt;tempfile API 内部具有与File类似的API, 并且可以防止文件操作的冲突.&lt;/p&gt;

&lt;p&gt;自动删除有两种: 一种是unlink!, 直接删除; 一种是unlink, GC时处理.&lt;/p&gt;

&lt;h2&gt;文本处理的一般策略&lt;/h2&gt;

&lt;h3&gt;Enumerator&lt;/h3&gt;

&lt;p&gt;迭代器: 逐行处理, 行号访问&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ruby&quot;&gt;f=File.open
f.each
f.lineno
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;原子化操作&lt;/h3&gt;

&lt;p&gt;利用tempfile API进行中间过程的处理, 再通过mv进行保存.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Ruby开发模式学习</title>
   <link href="http://www.5wpc.info/it/technical/language/ruby/2014/01/20/TDD"/>
   <updated>2014-01-20T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/technical/language/ruby/2014/01/20/TDD</id>
   <content type="html">&lt;h1&gt;整体介绍&lt;/h1&gt;

&lt;p&gt;在敏捷开发的过程中,&lt;/p&gt;

&lt;p&gt;BDD要解决的一个关键问题是提升问题领域人员和解决方案领域人员之间的交流。
BDD的目的是为了创建并发展一个这两个领域之间相互理解的公共区域，创建一种公共语言，一种普及的语言（正如领域驱动设计中所定义的那样）。&lt;/p&gt;

&lt;h2&gt;测试/行为驱动开发技术栈&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://cukes.info/&quot;&gt;cucumber&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://rspec.info/&quot;&gt;RSpec&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;nUnit

&lt;ul&gt;
&lt;li&gt;Mock &amp;amp; Stubs 用于测试数据的生成&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;BDD&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Spec&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;TDD&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;nUnit&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;相关使用的问题总结&lt;/h1&gt;

&lt;h2&gt;RSPEC&lt;/h2&gt;

&lt;h3&gt;development database to test database&lt;/h3&gt;

&lt;p&gt;添加一个第三方支持:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    gem &#39;db_fixtures_dump&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在需要的环境中, 运行 &lt;code&gt;rake db:fixtures:dump RAILS_ENV=development&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;不过这些数据输出的yml文件有个问题,会在每个单项前添加yml文档开始标记&lt;code&gt;---&lt;/code&gt;, 导致后面的数据无法解析.
目前需要再通过脚本清理掉.&lt;/p&gt;

&lt;p&gt;目前主流的测试对象生成方法, 已经转向factory_girl,
如果需要通过yml+fixtures的方式, 请注意所有的加载方法都只能在 &lt;code&gt;it&lt;/code&gt; 语句生效.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    fixtures :post

    it &#39;load post&#39; do
        post(:a)
    end
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Rspec error: Diff is not a module&lt;/h3&gt;

&lt;p&gt;主要是由于 rspec 会通过反射进行所有 ActiveModel 的加载与查找,
其实现方法则是通过文件的require, 而rspec依赖的包中有文件名称与diff.rb相同, 从而导致
无法加载用户自己定义的 diff.rb&lt;/p&gt;

&lt;p&gt;解决方法:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在设计时, 不要用diff 名称&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在spec中, 先行加载 diff.rb&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  # spec/rails_helper.rb
  # This file is copied to spec/ when you run &#39;rails generate rspec:install&#39;
  ENV[&quot;RAILS_ENV&quot;] ||= &#39;test&#39;
  require &#39;spec_helper&#39;
  require File.expand_path(&quot;../../config/environment&quot;, __FILE__)
  #### Add this line Begin
  Dir[Rails.root.join(&quot;app/models/diff.rb&quot;)].each { |f| require f }
  #### End
  require &#39;rspec/rails&#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>git常用技巧</title>
   <link href="http://www.5wpc.info/it/technical/continuousintegration/2014/01/16/git"/>
   <updated>2014-01-16T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/technical/continuousintegration/2014/01/16/git</id>
   <content type="html">&lt;h1&gt;Patch&lt;/h1&gt;

&lt;h2&gt;纯文本&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;git diff &amp;gt; a.patch
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;综合&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;# The last commit change
git format-patch HEAD^..HEAD
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>系统变更比对方法</title>
   <link href="http://www.5wpc.info/it/technical/continuousintegration/2014/01/16/compare"/>
   <updated>2014-01-16T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/technical/continuousintegration/2014/01/16/compare</id>
   <content type="html">&lt;h1&gt;一般思路&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;对比资源创建与组装

&lt;ol&gt;
&lt;li&gt;各种文件格式的支持&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;目录对比

&lt;ol&gt;
&lt;li&gt;不同文件类型的比对&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;结果汇总与反馈

&lt;ol&gt;
&lt;li&gt;关注结果的过滤与高亮&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;具体实现&lt;/h1&gt;

&lt;h2&gt;数据包解压&lt;/h2&gt;

&lt;h3&gt;zip&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;unzip -d destination aaa.zip
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;boot.img&lt;/h3&gt;

&lt;p&gt;boot.img: u-boot legacy uImage, Linux-3.4.35_s40, Linux/ARM, OS Kernel Image (Not compressed)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://ftp.maddes.net/u-boot/&quot;&gt;ubootExtractTool&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://forum.xda-developers.com/showthread.php?t=901152&quot;&gt;zImageUnzip&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;code&gt;shell
&lt;/code&gt;&lt;/p&gt;

&lt;h2&gt;目录级对比&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;diff -rq tmp/1228/ tmp/0107/ | sort | uniq | grep -v \.svn
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>Ruby 正则表达式</title>
   <link href="http://www.5wpc.info/it/technical/language/ruby/2014/01/15/Regular"/>
   <updated>2014-01-15T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/technical/language/ruby/2014/01/15/Regular</id>
   <content type="html">&lt;p&gt;&lt;em&gt;声明: 下列内容基于ruby 2.0.0p247 (2013-06-27) [x86_64-linux]&lt;/em&gt;&lt;/p&gt;

&lt;h1&gt;一堆小例子&lt;/h1&gt;

&lt;h2&gt;基本使用&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;ruby&quot;&gt;/hay/ =~ &#39;haystack&#39;   #=&amp;gt; 0
%r[y].match(&#39;haystack&#39;) #=&amp;gt; #&amp;lt;MatchData &quot;y&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;主要概念&lt;/h1&gt;

&lt;h2&gt;New a object&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;ruby&quot;&gt;# matching check
=~

# MatchData
obj=regexpObject.match(stringobj)

# Regexp class
r1 = Regexp.new(&#39;^a-z+:\s+\w+&#39;) #=&amp;gt; /^a-z+:\s+\w+/
r2 = Regexp.new(&#39;cat&#39;, true)     #=&amp;gt; /cat/i
r3 = Regexp.new(r2)              #=&amp;gt; /cat/i
r4 = Regexp.new(&#39;dog&#39;, Regexp::EXTENDED | Regexp::IGNORECASE) #=&amp;gt; /dog/ix
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;字符组 Character Classes&lt;/h2&gt;

&lt;h3&gt;通用表示&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt; 符号 &lt;/th&gt;
&lt;th&gt; English &lt;/th&gt;
&lt;th&gt; 备注 &lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;/./&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;  Any character except a newline. &lt;/td&gt;
&lt;td&gt; 除新行外的所有字符             &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;/./m&lt;/code&gt; &lt;/td&gt;
&lt;td&gt; Any character (the m modifier enables multiline mode) &lt;/td&gt;
&lt;td&gt; 带多行支持后,表示所有字符  &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;/\w/&lt;/code&gt; &lt;/td&gt;
&lt;td&gt; A word character (&lt;code&gt;[a-zA-Z0-9_]&lt;/code&gt;) &lt;/td&gt;
&lt;td&gt;    &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;/\W/&lt;/code&gt; &lt;/td&gt;
&lt;td&gt; A non-word character (&lt;code&gt;[^a-zA-Z0-9_]&lt;/code&gt;). Please take a look at Bug #4044 if using /\W/ with the /i modifier. &lt;/td&gt;
&lt;td&gt;              &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;/\d/&lt;/code&gt; &lt;/td&gt;
&lt;td&gt; A digit character (&lt;code&gt;[0-9]&lt;/code&gt;) &lt;/td&gt;
&lt;td&gt;              &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;/\D/&lt;/code&gt; &lt;/td&gt;
&lt;td&gt; A non-digit character (&lt;code&gt;[^0-9]&lt;/code&gt;) &lt;/td&gt;
&lt;td&gt;              &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;/\h/&lt;/code&gt; &lt;/td&gt;
&lt;td&gt; A hexdigit character (&lt;code&gt;[0-9a-fA-F]&lt;/code&gt;) &lt;/td&gt;
&lt;td&gt;              &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;/\H/&lt;/code&gt; &lt;/td&gt;
&lt;td&gt; A non-hexdigit character (&lt;code&gt;[^0-9a-fA-F]&lt;/code&gt;) &lt;/td&gt;
&lt;td&gt;              &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;/\s/&lt;/code&gt; &lt;/td&gt;
&lt;td&gt; A whitespace character: /&lt;code&gt;[ \t\r\n\f]&lt;/code&gt;/ &lt;/td&gt;
&lt;td&gt;              &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;/\S/&lt;/code&gt; &lt;/td&gt;
&lt;td&gt; A non-whitespace character: /&lt;code&gt;[^ \t\r\n\f]&lt;/code&gt;/ &lt;/td&gt;
&lt;td&gt;              &lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;


&lt;h3&gt;POSIX&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt; 符号 &lt;/th&gt;
&lt;th&gt; English &lt;/th&gt;
&lt;th&gt; 备注 &lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;/[[:alnum:]]/&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;  Alphabetic and numeric character &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;/[[:alpha:]]/&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;  Alphabetic character &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;/[[:blank:]]/&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;  Space or tab &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;/[[:cntrl:]]/&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;  Control character &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;/[[:digit:]]/&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;  Digit &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;/[[:graph:]]/&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;  Non-blank character (excludes spaces, control characters, and similar) &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;/[[:lower:]]/&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;  Lowercase alphabetical character &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;/[[:print:]]/&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;  Like &lt;code&gt;[:graph:]&lt;/code&gt;, but includes the space character &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;/[[:punct:]]/&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;  Punctuation character &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;/[[:space:]]/&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;  Whitespace character (&lt;code&gt;[:blank:]&lt;/code&gt;, newline, carriage return, etc.) &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;/[[:upper:]]/&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;  Uppercase alphabetical &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;/[[:xdigit:]]/&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;  Digit allowed in a hexadecimal number (i.e., 0-9a-fA-F) &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;


&lt;h3&gt;non-POSIX&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt; 符号 &lt;/th&gt;
&lt;th&gt; English &lt;/th&gt;
&lt;th&gt; 备注 &lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;/[[:word:]]/&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;  A character in one of the following Unicode general categories Letter, Mark, Number, Connector_Punctuation &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;/[[:ascii:]]/&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;  A character in the ASCII character set &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;


&lt;h3&gt;扩展字符集合 Character Properties&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt; 符号 &lt;/th&gt;
&lt;th&gt; English &lt;/th&gt;
&lt;th&gt; 备注 &lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;/\p{Alnum}/&lt;/code&gt; &lt;/td&gt;
&lt;td&gt; Alphabetic and numeric character &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;/\p{Alpha}/&lt;/code&gt; &lt;/td&gt;
&lt;td&gt; Alphabetic character &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;/\p{Blank}/&lt;/code&gt; &lt;/td&gt;
&lt;td&gt; Space or tab &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;/\p{Cntrl}/&lt;/code&gt; &lt;/td&gt;
&lt;td&gt; Control character &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;/\p{Digit}/&lt;/code&gt; &lt;/td&gt;
&lt;td&gt; Digit &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;/\p{Graph}/&lt;/code&gt; &lt;/td&gt;
&lt;td&gt; Non-blank character (excludes spaces, control characters, and similar) &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;/\p{Lower}/&lt;/code&gt; &lt;/td&gt;
&lt;td&gt; Lowercase alphabetical character &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;/\p{Print}/&lt;/code&gt; &lt;/td&gt;
&lt;td&gt; Like \p{Graph}, but includes the space character &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;/\p{Punct}/&lt;/code&gt; &lt;/td&gt;
&lt;td&gt; Punctuation character &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;/\p{Space}/&lt;/code&gt; &lt;/td&gt;
&lt;td&gt; Whitespace character ([:blank:], newline, carriage return, etc.) &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;/\p{Upper}/&lt;/code&gt; &lt;/td&gt;
&lt;td&gt; Uppercase alphabetical &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;/\p{XDigit}/&lt;/code&gt; &lt;/td&gt;
&lt;td&gt; Digit allowed in a hexadecimal number (i.e., 0-9a-fA-F) &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;/\p{Word}/&lt;/code&gt; &lt;/td&gt;
&lt;td&gt; A member of one of the following Unicode general category Letter, Mark, Number, Connector_Punctuation &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;/\p{ASCII}/&lt;/code&gt; &lt;/td&gt;
&lt;td&gt; A character in the ASCII character set &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;/\p{Any}/&lt;/code&gt; &lt;/td&gt;
&lt;td&gt; Any Unicode character (including unassigned characters) &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;/\p{Assigned}/&lt;/code&gt; &lt;/td&gt;
&lt;td&gt; An assigned character &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;/\p{L}/&lt;/code&gt; &lt;/td&gt;
&lt;td&gt; &#39;Letter&#39; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;/\p{Ll}/&lt;/code&gt; &lt;/td&gt;
&lt;td&gt; &#39;Letter: Lowercase&#39; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;/\p{Lm}/&lt;/code&gt; &lt;/td&gt;
&lt;td&gt; &#39;Letter: Mark&#39; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;/\p{Lo}/&lt;/code&gt; &lt;/td&gt;
&lt;td&gt; &#39;Letter: Other&#39; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;/\p{Lt}/&lt;/code&gt; &lt;/td&gt;
&lt;td&gt; &#39;Letter: Titlecase&#39; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;/\p{Lu}/&lt;/code&gt; &lt;/td&gt;
&lt;td&gt; &#39;Letter: Uppercase &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;/\p{Lo}/&lt;/code&gt; &lt;/td&gt;
&lt;td&gt; &#39;Letter: Other&#39; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;/\p{M}/&lt;/code&gt; &lt;/td&gt;
&lt;td&gt; &#39;Mark&#39; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;/\p{Mn}/&lt;/code&gt; &lt;/td&gt;
&lt;td&gt; &#39;Mark: Nonspacing&#39; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;/\p{Mc}/&lt;/code&gt; &lt;/td&gt;
&lt;td&gt; &#39;Mark: Spacing Combining&#39; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;/\p{Me}/&lt;/code&gt; &lt;/td&gt;
&lt;td&gt; &#39;Mark: Enclosing&#39; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;/\p{N}/&lt;/code&gt; &lt;/td&gt;
&lt;td&gt; &#39;Number&#39; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;/\p{Nd}/&lt;/code&gt; &lt;/td&gt;
&lt;td&gt; &#39;Number: Decimal Digit&#39; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;/\p{Nl}/&lt;/code&gt; &lt;/td&gt;
&lt;td&gt; &#39;Number: Letter&#39; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;/\p{No}/&lt;/code&gt; &lt;/td&gt;
&lt;td&gt; &#39;Number: Other&#39; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;/\p{P}/&lt;/code&gt; &lt;/td&gt;
&lt;td&gt; &#39;Punctuation&#39; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;/\p{Pc}/&lt;/code&gt; &lt;/td&gt;
&lt;td&gt; &#39;Punctuation: Connector&#39; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;/\p{Pd}/&lt;/code&gt; &lt;/td&gt;
&lt;td&gt; &#39;Punctuation: Dash&#39; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;/\p{Ps}/&lt;/code&gt; &lt;/td&gt;
&lt;td&gt; &#39;Punctuation: Open&#39; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;/\p{Pe}/&lt;/code&gt; &lt;/td&gt;
&lt;td&gt; &#39;Punctuation: Close&#39; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;/\p{Pi}/&lt;/code&gt; &lt;/td&gt;
&lt;td&gt; &#39;Punctuation: Initial Quote&#39; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;/\p{Pf}/&lt;/code&gt; &lt;/td&gt;
&lt;td&gt; &#39;Punctuation: Final Quote&#39; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;/\p{Po}/&lt;/code&gt; &lt;/td&gt;
&lt;td&gt; &#39;Punctuation: Other&#39; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;/\p{S}/&lt;/code&gt; &lt;/td&gt;
&lt;td&gt; &#39;Symbol&#39; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;/\p{Sm}/&lt;/code&gt; &lt;/td&gt;
&lt;td&gt; &#39;Symbol: Math&#39; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;/\p{Sc}/&lt;/code&gt; &lt;/td&gt;
&lt;td&gt; &#39;Symbol: Currency&#39; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;/\p{Sc}/&lt;/code&gt; &lt;/td&gt;
&lt;td&gt; &#39;Symbol: Currency&#39; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;/\p{Sk}/&lt;/code&gt; &lt;/td&gt;
&lt;td&gt; &#39;Symbol: Modifier&#39; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;/\p{So}/&lt;/code&gt; &lt;/td&gt;
&lt;td&gt; &#39;Symbol: Other&#39; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;/\p{Z}/&lt;/code&gt; &lt;/td&gt;
&lt;td&gt; &#39;Separator&#39; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;/\p{Zs}/&lt;/code&gt; &lt;/td&gt;
&lt;td&gt; &#39;Separator: Space&#39; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;/\p{Zl}/&lt;/code&gt; &lt;/td&gt;
&lt;td&gt; &#39;Separator: Line&#39; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;/\p{Zp}/&lt;/code&gt; &lt;/td&gt;
&lt;td&gt; &#39;Separator: Paragraph&#39; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;/\p{C}/&lt;/code&gt; &lt;/td&gt;
&lt;td&gt; &#39;Other&#39; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;/\p{Cc}/&lt;/code&gt; &lt;/td&gt;
&lt;td&gt; &#39;Other: Control&#39; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;/\p{Cf}/&lt;/code&gt; &lt;/td&gt;
&lt;td&gt; &#39;Other: Format&#39; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;/\p{Cn}/&lt;/code&gt; &lt;/td&gt;
&lt;td&gt; &#39;Other: Not Assigned&#39; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;/\p{Co}/&lt;/code&gt; &lt;/td&gt;
&lt;td&gt; &#39;Other: Private Use&#39; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;/\p{Cs}/&lt;/code&gt; &lt;/td&gt;
&lt;td&gt; &#39;Other: Surrogate&#39; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;


&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;Lastly, `\p{}` matches a character’s Unicode script. The following scripts are supported: Arabic, Armenian, Balinese, Bengali, Bopomofo, Braille, Buginese, Buhid, Canadian_Aboriginal, Carian, Cham, Cherokee, Common, Coptic, Cuneiform, Cypriot, Cyrillic, Deseret, Devanagari, Ethiopic, Georgian, Glagolitic, Gothic, Greek, Gujarati, Gurmukhi, Han, Hangul, Hanunoo, Hebrew, Hiragana, Inherited, Kannada, Katakana, Kayah_Li, Kharoshthi, Khmer, Lao, Latin, Lepcha, Limbu, Linear_B, Lycian, Lydian, Malayalam, Mongolian, Myanmar, New_Tai_Lue, Nko, Ogham, Ol_Chiki, Old_Italic, Old_Persian, Oriya, Osmanya, Phags_Pa, Phoenician, Rejang, Runic, Saurashtra, Shavian, Sinhala, Sundanese, Syloti_Nagri, Syriac, Tagalog, Tagbanwa, Tai_Le, Tamil, Telugu, Thaana, Thai, Tibetan, Tifinagh, Ugaritic, Vai, and Yi.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于其它字符的支持:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ruby&quot;&gt;/\p{Arabic}/.match(&quot;\u06E9&quot;) #=&amp;gt; #&amp;lt;MatchData &quot;\u06E9&quot;&amp;gt;
/\p{^Ll}/.match(&quot;A&quot;) #=&amp;gt; #&amp;lt;MatchData &quot;A&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;复用 Repetition&lt;/h2&gt;

&lt;h3&gt;结构/量词&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt; 符号/量词 &lt;/th&gt;
&lt;th&gt; English &lt;/th&gt;
&lt;th&gt; 备注 &lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt; * &lt;/td&gt;
&lt;td&gt; Zero or more times &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; + &lt;/td&gt;
&lt;td&gt; One or more times &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; ? &lt;/td&gt;
&lt;td&gt; Zero or one times (optional) &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; {n} &lt;/td&gt;
&lt;td&gt; Exactly n times &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; {n,} &lt;/td&gt;
&lt;td&gt; n or more times &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; {,m} &lt;/td&gt;
&lt;td&gt; m or less times &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; {n,m} &lt;/td&gt;
&lt;td&gt; At least n and at most m times &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;


&lt;h3&gt;模式&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;默认为贪婪型, 最多成功匹配&lt;/li&gt;
&lt;li&gt;非贪婪/懒惰型, 最少&lt;em&gt;成功&lt;/em&gt;匹配

&lt;ul&gt;
&lt;li&gt;量词后面添加&lt;code&gt;?&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;涉及量词: &lt;code&gt;* + {n,}&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code class=&quot;ruby&quot;&gt;/&amp;lt;(.+)&amp;gt;/.match(&quot;&amp;lt;a&amp;gt;&amp;lt;b&amp;gt;&quot;) # =&amp;gt; #&amp;lt;MatchData &quot;&amp;lt;a&amp;gt;&amp;lt;b&amp;gt;&quot; 1:&quot;a&amp;gt;&amp;lt;b&quot;&amp;gt;
/&amp;lt;(.+?)&amp;gt;/.match(&quot;&amp;lt;a&amp;gt;&amp;lt;b&amp;gt;&quot;) # =&amp;gt; #&amp;lt;MatchData &quot;&amp;lt;a&amp;gt;&quot; 1:&quot;a&quot;&amp;gt;
/&amp;lt;(.+?)&amp;gt;/.match(&quot;&amp;lt;abc&amp;gt;&amp;lt;b&amp;gt;&quot;) # =&amp;gt; #&amp;lt;MatchData &quot;&amp;lt;abc&amp;gt;&quot; 1:&quot;abc&quot;&amp;gt;
/&amp;lt;(.{1,}?)&amp;gt;/.match(&quot;&amp;lt;abc&amp;gt;&amp;lt;b&amp;gt;&quot;) # =&amp;gt; #&amp;lt;MatchData &quot;&amp;lt;abc&amp;gt;&quot; 1:&quot;abc&quot;&amp;gt;
/&amp;lt;(.{1,})&amp;gt;/.match(&quot;&amp;lt;abc&amp;gt;&amp;lt;b&amp;gt;&quot;) # =&amp;gt; #&amp;lt;MatchData &quot;&amp;lt;abc&amp;gt;&amp;lt;b&amp;gt;&quot; 1:&quot;abc&amp;gt;&amp;lt;b&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;分组 Grouping&lt;/h2&gt;

&lt;p&gt;分组应该算是对上面东西的结构化.
从分组到归类,又是引用.&lt;/p&gt;

&lt;h3&gt;捕捉/获取 Capturing&lt;/h3&gt;

&lt;p&gt;主要涉及两种操作: 捕捉与引用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ruby&quot;&gt;/(?&amp;lt;vowel&amp;gt;[aeiou]).\k&amp;lt;vowel&amp;gt;.\k&amp;lt;vowel&amp;gt;/.match(&#39;ototomy&#39;)
    #=&amp;gt; #&amp;lt;MatchData &quot;ototo&quot; vowel:&quot;o&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;捕捉&lt;/h4&gt;

&lt;p&gt;以&lt;code&gt;()&lt;/code&gt;包含的一个Regular串是一个捕捉组, 从前到后依次为1,2,3,......&lt;/p&gt;

&lt;p&gt;有名字的组,以如下模式进行包含&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ruby&quot;&gt;(?&amp;lt;name&amp;gt;)
# or
(?&#39;name&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;原子分组/捕捉&lt;/h4&gt;

&lt;p&gt;通过&lt;code&gt;(?&amp;gt;pat)&lt;/code&gt;定义的分组是原子分组.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;在正则表达式的底层实现中, 通过原子分组, 可以取消匹配过程中的回溯.
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;ruby&quot;&gt;/&quot;(.*)&quot;/.match(&#39;&quot;Quote&quot;&#39;)     #=&amp;gt; #&amp;lt;MatchData &quot;\&quot;Quote\&quot;&quot; 1:&quot;Quote&quot;&amp;gt;
/&quot;(?&amp;gt;.*)&quot;/.match(&#39;&quot;Quote&quot;&#39;) #=&amp;gt; nil
# 失败原因: .* 由于贪婪的原则, 匹配了&quot;, 后续正则式中的&quot;无法再进行匹配, 导致出错.
# 上面的成功是产生的回溯.
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;取消捕捉&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;ruby&quot;&gt;(?:regular)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;引用&lt;/h4&gt;

&lt;p&gt;直接可以使用&lt;code&gt;\1,\2,\k&amp;lt;name&amp;gt;&lt;/code&gt;等进行引用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ruby&quot;&gt;\1
# with name
\k&amp;lt;name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;有名变量化&lt;/h4&gt;

&lt;p&gt;如果正则表达式在&lt;code&gt;=~&lt;/code&gt;&lt;em&gt;左侧&lt;/em&gt;, 会按名字产生局部变量.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ruby&quot;&gt;dollars = &#39;abc&#39;
/\$(?&amp;lt;dollars&amp;gt;\d+)\.(?&amp;lt;cents&amp;gt;\d+)/ =~ &quot;$3.67&quot; #=&amp;gt; 0
dollars #=&amp;gt; &quot;3&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;注意局部变量会被修改&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ruby&quot;&gt;/[aeiou]\w{2}/.match(&quot;Caenorhabditis elegans&quot;) #=&amp;gt; #&amp;lt;MatchData &quot;aen&quot;&amp;gt;
/([aeiou]\w){2}/.match(&quot;Caenorhabditis elegans&quot;)
    #=&amp;gt; #&amp;lt;MatchData &quot;enor&quot; 1:&quot;or&quot;&amp;gt;
/I(n)ves(ti)ga\2ons/.match(&quot;Investigations&quot;)
    #=&amp;gt; #&amp;lt;MatchData &quot;Investigations&quot; 1:&quot;n&quot; 2:&quot;ti&quot;&amp;gt;
/I(?:n)ves(ti)ga\1ons/.match(&quot;Investigations&quot;)
    #=&amp;gt; #&amp;lt;MatchData &quot;Investigations&quot; 1:&quot;ti&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;分组共用 子表达式共用 Subexpression Calls&lt;/h3&gt;

&lt;p&gt;通过&lt;code&gt;\g&amp;lt;name&amp;gt;&lt;/code&gt;进行表达式的复用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ruby&quot;&gt;/\A(?&amp;lt;paren&amp;gt;\(\g&amp;lt;paren&amp;gt;*\))*\z/ .match &#39;&#39; # =&amp;gt; #&amp;lt;MatchData &quot;&quot; paren:nil&amp;gt;

/\A(?&amp;lt;paren&amp;gt;\(\g&amp;lt;paren&amp;gt;*\))*\z/ .match &#39;()&#39; # =&amp;gt; #&amp;lt;MatchData &quot;()&quot; paren:&quot;()&quot;&amp;gt;

/\A(?&amp;lt;paren&amp;gt;\(\g&amp;lt;paren&amp;gt;*\))*\z/ .match &#39;(())&#39; # =&amp;gt; #&amp;lt;MatchData &quot;(())&quot; paren:&quot;(())&quot;&amp;gt;
# ^1 字符串开始
#      ^2 Regular(paren)实际内容是 ()
#           ^3 实际字符 (
#                 ^4 复用Regular(paren)
#                      ^7 多个Regular(paren)
#                       ^^8 实际字符 )
#                           ^10 字符串结束
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;组内数据多选一 Alternation&lt;/h4&gt;

&lt;p&gt;通过&lt;code&gt;|&lt;/code&gt;分割多个Regular&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ruby&quot;&gt;/\w(and|or)\w/.match(&quot;Feliformia&quot;) #=&amp;gt; #&amp;lt;MatchData &quot;form&quot; 1:&quot;or&quot;&amp;gt;
/\w(and|or)\w/.match(&quot;furandi&quot;)    #=&amp;gt; #&amp;lt;MatchData &quot;randi&quot; 1:&quot;and&quot;&amp;gt;
/\w(and|or)\w/.match(&quot;dissemblance&quot;) #=&amp;gt; nil
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;锚点Anchors&lt;/h2&gt;

&lt;p&gt;用于后续正则表达式的&lt;em&gt;定位&lt;/em&gt;, &lt;em&gt;不&lt;/em&gt;参加匹配内容&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt; 符号 &lt;/th&gt;
&lt;th&gt; English &lt;/th&gt;
&lt;th&gt; 备注 &lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;^&lt;/code&gt; &lt;/td&gt;
&lt;td&gt; Matches beginning of line &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;$&lt;/code&gt; &lt;/td&gt;
&lt;td&gt; Matches end of line &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;\A&lt;/code&gt; &lt;/td&gt;
&lt;td&gt; Matches beginning of string. &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;\Z&lt;/code&gt; &lt;/td&gt;
&lt;td&gt; Matches end of string. If string ends with a newline, it matches just before newline &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;\z&lt;/code&gt; &lt;/td&gt;
&lt;td&gt; Matches end of string &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;\G&lt;/code&gt; &lt;/td&gt;
&lt;td&gt; Matches point where last match finished &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;\b&lt;/code&gt; &lt;/td&gt;
&lt;td&gt; Matches word boundaries when outside brackets; backspace (0x08) when inside brackets &lt;/td&gt;
&lt;td&gt; 单词分割符 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;\B&lt;/code&gt; &lt;/td&gt;
&lt;td&gt; Matches non-word boundaries &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;(?=pat)&lt;/code&gt; &lt;/td&gt;
&lt;td&gt; Positive lookahead assertion: ensures that the following characters match pat, but doesn&#39;t include those characters in the matched text &lt;/td&gt;
&lt;td&gt; 零宽度正预测先行断言 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;(?!pat)&lt;/code&gt; &lt;/td&gt;
&lt;td&gt; Negative lookahead assertion: ensures that the following characters do not match pat, but doesn&#39;t include those characters in the matched text &lt;/td&gt;
&lt;td&gt; 零宽度负预测先行断言 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;(?&amp;lt;=pat)&lt;/code&gt; &lt;/td&gt;
&lt;td&gt; Positive lookbehind assertion: ensures that the preceding characters match pat, but doesn&#39;t include those characters in the matched text &lt;/td&gt;
&lt;td&gt; 零宽度正回顾后发断言 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;(?&amp;lt;!pat)&lt;/code&gt; &lt;/td&gt;
&lt;td&gt; Negative lookbehind assertion: ensures that the preceding characters do not match pat, but doesn&#39;t include those characters in the matched text &lt;/td&gt;
&lt;td&gt; 零宽度负回顾后发断言 &lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;


&lt;p&gt;其中涉及断言机制, 具体名称可以再参见&lt;a href=&quot;http://richardustc.github.io/blog/2013/06/assertion-in-regular-expression/&quot;&gt;正则表达式断言&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;下面以零宽度正预测先行断言为例子,看看效果:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ruby&quot;&gt;/(\w+)(?=abc)/.match &#39;defabcdef&#39; # =&amp;gt; #&amp;lt;MatchData &quot;def&quot; 1:&quot;def&quot;&amp;gt;
#      ^ 用于定位
#                        ^ 发现abc
#                     ^^^ (\w+) 的匹配, 位于指定位置前的数据
/(?=abc)(\w+)/.match &#39;defabcdef&#39; # =&amp;gt; #&amp;lt;MatchData &quot;abcdef&quot; 1:&quot;abcdef&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;整体配置&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt; 符号 &lt;/th&gt;
&lt;th&gt; English &lt;/th&gt;
&lt;th&gt; 备注 &lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;/pat/i&lt;/code&gt; &lt;/td&gt;
&lt;td&gt; Ignore case &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;/pat/m&lt;/code&gt; &lt;/td&gt;
&lt;td&gt; Treat a newline as a character matched by . &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;/pat/x&lt;/code&gt; &lt;/td&gt;
&lt;td&gt; Ignore whitespace and comments in the pattern &lt;/td&gt;
&lt;td&gt; 通过这个参数,可以在正则表达式中写注释了&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;/pat/o&lt;/code&gt; &lt;/td&gt;
&lt;td&gt; Perform #{} interpolation only once &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;


&lt;pre&gt;&lt;code class=&quot;ruby&quot;&gt;float_pat = /\A
    [[:digit:]]+ # 1 or more digits before the decimal point
    (\.          # Decimal point
        [[:digit:]]+ # 1 or more digits after the decimal point
    )? # The decimal point and following digits are optional
\Z/x
float_pat.match(&#39;3.14&#39;) #=&amp;gt; #&amp;lt;MatchData &quot;3.14&quot; 1:&quot;.14&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;编码 Encoding&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt; 符号 &lt;/th&gt;
&lt;th&gt; English &lt;/th&gt;
&lt;th&gt; 备注 &lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;/pat/u&lt;/code&gt; &lt;/td&gt;
&lt;td&gt; UTF-8  &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;/pat/e&lt;/code&gt; &lt;/td&gt;
&lt;td&gt; EUC-JP  &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;/pat/s&lt;/code&gt; &lt;/td&gt;
&lt;td&gt; Windows-31J  &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;/pat/n&lt;/code&gt; &lt;/td&gt;
&lt;td&gt; ASCII-8BIT  &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;


&lt;h2&gt;Ruby 特色的全局变量&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt; 符号 &lt;/th&gt;
&lt;th&gt; English &lt;/th&gt;
&lt;th&gt; 备注 &lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;$~&lt;/code&gt; &lt;/td&gt;
&lt;td&gt; is equivalent to ::last_match; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;$&amp;amp;&lt;/code&gt; &lt;/td&gt;
&lt;td&gt; contains the complete matched text; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; $`&lt;/td&gt;
&lt;td&gt; contains string before match; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;$&#39;&lt;/code&gt; &lt;/td&gt;
&lt;td&gt; contains string after match; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;$1, $2 and so&lt;/code&gt; &lt;/td&gt;
&lt;td&gt; on contain text matching first, second, etc capture group; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; &lt;code&gt;$+&lt;/code&gt; &lt;/td&gt;
&lt;td&gt; contains last capture group. &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;


&lt;h1&gt;参考资料&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.ruby-doc.org/core-2.1.0/Regexp.html&quot;&gt;Ruby Regular RDoc&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.chinaunix.net/uid-298861-id-3144205.html&quot;&gt;Ruby 正则表达式官方文档翻译参照&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>周末活动收集与落实</title>
   <link href="http://www.5wpc.info/it/living/life/2014/01/14/WeekActivity"/>
   <updated>2014-01-14T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/living/life/2014/01/14/WeekActivity</id>
   <content type="html">&lt;h1&gt;2014&lt;/h1&gt;

&lt;h2&gt;Winter&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;滑雪&lt;/li&gt;
&lt;li&gt;火锅&lt;/li&gt;
&lt;/ol&gt;


&lt;h2&gt;Spring&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Biking&lt;/li&gt;
&lt;li&gt;游览景点&lt;/li&gt;
&lt;li&gt;Skating&lt;/li&gt;
&lt;li&gt;陶艺&lt;/li&gt;
&lt;li&gt;Climbing&lt;/li&gt;
&lt;/ol&gt;


&lt;h2&gt;Summer&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;游泳&lt;/li&gt;
&lt;/ol&gt;


&lt;h2&gt;Autunm&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;收水果&lt;/li&gt;
&lt;/ol&gt;


&lt;h2&gt;Simple&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Movie&lt;/li&gt;
&lt;li&gt;KTV&lt;/li&gt;
&lt;li&gt;Shopping&lt;/li&gt;
&lt;li&gt;打电动&lt;/li&gt;
&lt;li&gt;Group Activity&lt;/li&gt;
&lt;li&gt;关注身体&lt;/li&gt;
&lt;/ol&gt;


&lt;h2&gt;Interesting&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;私室逃生&lt;/li&gt;
&lt;li&gt;网球&lt;/li&gt;
&lt;li&gt;保龄球&lt;/li&gt;
&lt;/ol&gt;

</content>
 </entry>
 
 <entry>
   <title>2014旅行计划</title>
   <link href="http://www.5wpc.info/it/living/interest/travel/2014/01/11/2014"/>
   <updated>2014-01-11T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/living/interest/travel/2014/01/11/2014</id>
   <content type="html">&lt;h1&gt;时间安排&lt;/h1&gt;

&lt;p&gt;国家假期安排:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;*: Holiday
-: Work
                             2014

      January               February               March
Mo Tu We Th Fr Sa Su  Mo Tu We Th Fr Sa Su  Mo Tu We Th Fr Sa Su
       *  2  3  4  5                  *  *                  1  2
 6  7  8  9 10 11 12   *  *  *  *  7  -  9   3  4  5  6  7  8  9
13 14 15 16 17 18 19  10 11 12 13 14 15 16  10 11 12 13 14 15 16
20 21 22 23 24 25 26  17 18 19 20 21 22 23  17 18 19 20 21 22 23
27 28 29 30 **        24 25 26 27 28        24 25 26 27 28 29 30
                                            31
       April                  May                   June
Mo Tu We Th Fr Sa Su  Mo Tu We Th Fr Sa Su  Mo Tu We Th Fr Sa Su
    1  2  3  4  *  *            *  *  *  -                     *
 *  8  9 10 11 12 13   5  6  7  8  9 10 11   *  3  4  5  6  7  8
14 15 16 17 18 19 20  12 13 14 15 16 17 18   9 10 11 12 13 14 15
21 22 23 24 25 26 27  19 20 21 22 23 24 25  16 17 18 19 20 21 22
28 29 30              26 27 28 29 30 **     23 24 25 26 27 28 29
                                            30
        July                 August              September
Mo Tu We Th Fr Sa Su  Mo Tu We Th Fr Sa Su  Mo Tu We Th Fr Sa Su
    1  2  3  4  5  6               1  2  3   1  2  3  4  5  *  *
 7  8  9 10 11 12 13   4  5  6  7  8  9 10   *  9 10 11 12 13 14
14 15 16 17 18 19 20  11 12 13 14 15 16 17  15 16 17 18 19 20 21
21 22 23 24 25 26 27  18 19 20 21 22 23 24  22 23 24 25 26 27 --
28 29 30 31           25 26 27 28 29 30 31  29 30

      October               November              December
Mo Tu We Th Fr Sa Su  Mo Tu We Th Fr Sa Su  Mo Tu We Th Fr Sa Su
       *  *  *  *  *                  1  2   1  2  3  4  5  6  7
 *  *  8  9 10 -- 12   3  4  5  6  7  8  9   8  9 10 11 12 13 14
13 14 15 16 17 18 19  10 11 12 13 14 15 16  15 16 17 18 19 20 21
20 21 22 23 24 25 26  17 18 19 20 21 22 23  22 23 24 25 26 27 28
27 28 29 30 31        24 25 26 27 28 29 30  29 30 31
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;整体规划&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;清明节: 武汉&lt;/li&gt;
&lt;li&gt;劳动节: 广东, 香港&lt;/li&gt;
&lt;li&gt;端午节: 绍兴&lt;/li&gt;
&lt;li&gt;中秋节: 杭州&lt;/li&gt;
&lt;li&gt;国庆节: 台湾&lt;/li&gt;
&lt;/ol&gt;


&lt;h3&gt;台湾&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://heidixie.me/2013/12/%E5%8F%B0%E6%B9%BE%E5%B0%8F%E6%97%85%E8%A1%8C%E6%B8%B8%E8%AE%B0%E5%85%BC%E6%94%BB%E7%95%A5%E4%B8%80%E3%80%90%E8%A1%8C%E5%89%8D%E5%8F%8A%E5%9E%A6%E4%B8%81%E7%AF%87%E3%80%91/&quot;&gt;Demo&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;主要关注&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;机票&lt;/li&gt;
&lt;li&gt;住宿&lt;/li&gt;
&lt;li&gt;关注&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>Android baes_rules 模块编译过程学习</title>
   <link href="http://www.5wpc.info/it/technical/os/android/build/2014/01/08/base_rules"/>
   <updated>2014-01-08T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/technical/os/android/build/2014/01/08/base_rules</id>
   <content type="html">&lt;h1&gt;编译脚本分析&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;build/core/base_rules.mk

&lt;ul&gt;
&lt;li&gt;Variables Check&lt;/li&gt;
&lt;li&gt;.aidl to .java&lt;/li&gt;
&lt;li&gt;.logtags&lt;/li&gt;
&lt;li&gt;.proto to .java&lt;/li&gt;
&lt;li&gt;.java to .class&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;主要功能&lt;/h1&gt;

&lt;p&gt;由于涉及到大量基本的处理, 主要是定义了公共的依赖关系定义.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Android STATIC_JAVA_LIBRARY 模块编译过程学习</title>
   <link href="http://www.5wpc.info/it/technical/os/android/build/2014/01/07/static_java_library"/>
   <updated>2014-01-07T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/technical/os/android/build/2014/01/07/static_java_library</id>
   <content type="html">&lt;h1&gt;编译脚本分析&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;build/core/static_java_library.mk

&lt;ul&gt;
&lt;li&gt;环境设置

&lt;ul&gt;
&lt;li&gt;LOCAL_UNINSTALLABLE_MODULE := true&lt;/li&gt;
&lt;li&gt;LOCAL_IS_STATIC_JAVA_LIBRARY := true&lt;/li&gt;
&lt;li&gt;package resouces&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;build/core/java_library.mk&lt;/li&gt;
&lt;li&gt;处理R.stamp&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;整体分析&lt;/h1&gt;

&lt;p&gt;从上述模块结构, 我们可以看到, static_java_library 作为一个静态库
需要对资源进行支持.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Android java 模块编译过程学习</title>
   <link href="http://www.5wpc.info/it/technical/os/android/build/2014/01/07/java"/>
   <updated>2014-01-07T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/technical/os/android/build/2014/01/07/java</id>
   <content type="html">&lt;h1&gt;编译脚本分析&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;build/core/java.mk

&lt;ul&gt;
&lt;li&gt;配置基础编译依赖包

&lt;ul&gt;
&lt;li&gt;根据 LOCAL_NO_STANDARD_LIBRARIES, LOCAL_SDK_VERSION, proto等上下文添加依赖包.&lt;/li&gt;
&lt;li&gt;标准SDK, 需要添加 core core-junit ext framework&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;标准中间模块添加&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;``shell&quot;&gt;  LOCAL_INTERMEDIATE_TARGETS += \
      $(full_classes_compiled_jar) \
      $(full_classes_jarjar_jar) \
      $(full_classes_emma_jar) \
      $(full_classes_jar) \
      $(full_classes_proguard_jar) \
      $(built_dex_intermediate) \
      $(built_dex) \
      $(full_classes_stubs_jar)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;可能的中间模块&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;RenderScript/FilterScript to .java/.bc&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;build/core/base_rules.mk&lt;/li&gt;
&lt;li&gt;具体中间文件生成规则

&lt;ul&gt;
&lt;li&gt;create common directories&lt;/li&gt;
&lt;li&gt;full_classes_compiled_jar: java -&gt; classes -&gt; compiled-jar&lt;/li&gt;
&lt;li&gt;full_classes_jarjar_jar: acp/jarjar compiled-jar -&gt; jarjar-jar&lt;/li&gt;
&lt;li&gt;full_classes_emma_jar: acp/emmajar jarjar-jar -&gt; emma-jar&lt;/li&gt;
&lt;li&gt;full_classes_jar: acp emma-jar -&gt; classses-jar&lt;/li&gt;
&lt;li&gt;full_classes_proguard_jar: acp/proguard classes-jar -&gt; proguard-jar&lt;/li&gt;
&lt;li&gt;built_dex_intermediate: dx proguard-jar -&gt; dex-in&lt;/li&gt;
&lt;li&gt;built_dex: acp dex-in -&gt; dex&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;关键上下文接入点&lt;/h2&gt;

&lt;h3&gt;Input&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;LOCAL_BUILT_MODULE_STEM&lt;/li&gt;
&lt;li&gt;LOCAL_JAVA_LIBRARIES&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;Output&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;LOCAL_INTERMEDIATE_TARGETS&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;整体依赖关系&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;make all_modules
all\_modules : $(ALL_MODULES)
ALL\_MODULES += $(LOCAL_MODULE)
$(LOCAL_MODULE): $(LOCAL_BUILT_MODULE) $(LOCAL_INSTALLED_MODULE)
$(LOCAL_INSTALLED_MODULE): $(LOCAL_BUILT_MODULE)

LOCAL_BUILT_MODULE := $(built_module_path)/$(LOCAL_BUILT_MODULE_STEM)
.......
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过让 &lt;em&gt;LOCAL_BUILT_MODULE&lt;/em&gt; 产生对具体上下模块的依赖.&lt;/p&gt;

&lt;p&gt;例如:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;package.mk&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;``shell&quot;&gt;  $(LOCAL_BUILT_MODULE): $(built_dex)
  $(LOCAL_BUILT_MODULE): $(R_file_stamp)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>Java 技术学习列表</title>
   <link href="http://www.5wpc.info/it/technical/language/java/2014/01/07/index.java"/>
   <updated>2014-01-07T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/technical/language/java/2014/01/07/index.java</id>
   <content type="html">&lt;h1&gt;主要关注点&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;内存模型: http://www.infoq.com/cn/articles/java-memory-model-5&lt;/li&gt;
&lt;li&gt;JVM学习列表: http://rednaxelafx.iteye.com/blog/1886170&lt;/li&gt;
&lt;li&gt;常见最差实践: http://www.infoq.com/cn/news/2013/12/common-red-flags-in-java-1    2 3&lt;/li&gt;
&lt;li&gt;并发

&lt;ul&gt;
&lt;li&gt;http://www.infoq.com/cn/articles/java-blocking-queue&lt;/li&gt;
&lt;li&gt;http://www.infoq.com/cn/articles/fork-join-introduction&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;

</content>
 </entry>
 
 <entry>
   <title>Android系统研发与学习</title>
   <link href="http://www.5wpc.info/it/technical/os/android/2014/01/07/index"/>
   <updated>2014-01-07T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/technical/os/android/2014/01/07/index</id>
   <content type="html">&lt;h1&gt;工程化优化&lt;/h1&gt;

&lt;h2&gt;一些不错的开发资源&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;http://www.iteye.com/news/28627-42-Links-for-Android-Developers&lt;/li&gt;
&lt;/ol&gt;

</content>
 </entry>
 
 <entry>
   <title>Android JAVA_LIBRARY 模块编译过程学习</title>
   <link href="http://www.5wpc.info/it/technical/os/android/build/2014/01/07/Java_library"/>
   <updated>2014-01-07T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/technical/os/android/build/2014/01/07/Java_library</id>
   <content type="html">&lt;h1&gt;一个例子&lt;/h1&gt;

&lt;p&gt;利用development/samples/UiAutomator模块进行学习&lt;/p&gt;

&lt;h2&gt;中间产生的所有模块&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;                    out/target/common/obj/JAVA_LIBRARIES/uiautomator.samples_intermediates/classes-full-debug.jar
                  out/target/common/obj/JAVA_LIBRARIES/uiautomator.samples_intermediates/classes-jarjar.jar
                out/target/common/obj/JAVA_LIBRARIES/uiautomator.samples_intermediates/emma_out/lib/classes-jarjar.jar
              out/target/common/obj/JAVA_LIBRARIES/uiautomator.samples_intermediates/classes.jar
            out/target/common/obj/JAVA_LIBRARIES/uiautomator.samples_intermediates/noproguard.classes.jar
          out/target/common/obj/JAVA_LIBRARIES/uiautomator.samples_intermediates/noproguard.classes-with-local.dex
        out/target/common/obj/JAVA_LIBRARIES/uiautomator.samples_intermediates/noproguard.classes.dex
      out/target/common/obj/JAVA_LIBRARIES/uiautomator.samples_intermediates/javalib.jar
    out/target/product/maguro/obj/JAVA_LIBRARIES/uiautomator.samples_intermediates/javalib.jar
    out/target/product/maguro/system/framework/uiautomator.samples.jar
  uiautomator.samples
all_modules
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从上面的log看,其主要的过程与&lt;a href=&quot;/it/technical/os/Android/build/2014/01/03/APP/&quot;&gt;APP&lt;/a&gt;相同.
主要区别是最后产生的是javalib.jar, 需要进行安装的是/system/framework/uiautomator.samples.jar&lt;/p&gt;

&lt;p&gt;具体模块列表如下:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;没有R.stamp&lt;/li&gt;
&lt;li&gt;out/target/common/obj/JAVA_LIBRARIES/uiautomator.samples_intermediates/classes-full-debug.jar&lt;/li&gt;
&lt;li&gt;out/target/common/obj/JAVA_LIBRARIES/uiautomator.samples_intermediates/classes-jarjar.jar&lt;/li&gt;
&lt;li&gt;out/target/common/obj/JAVA_LIBRARIES/uiautomator.samples_intermediates/emma_out/lib/classes-jarjar.jar&lt;/li&gt;
&lt;li&gt;out/target/common/obj/JAVA_LIBRARIES/uiautomator.samples_intermediates/classes.jar&lt;/li&gt;
&lt;li&gt;以下是没有进行proguard处理的中间模块&lt;/li&gt;
&lt;li&gt;out/target/common/obj/JAVA_LIBRARIES/uiautomator.samples_intermediates/noproguard.classes.jar&lt;/li&gt;
&lt;li&gt;out/target/common/obj/JAVA_LIBRARIES/uiautomator.samples_intermediates/noproguard.classes-with-local.dex&lt;/li&gt;
&lt;li&gt;out/target/common/obj/JAVA_LIBRARIES/uiautomator.samples_intermediates/noproguard.classes.dex&lt;/li&gt;
&lt;li&gt;以下有不同, 多出来了一个处于common的javalib.jar打包文件&lt;/li&gt;
&lt;li&gt;out/target/common/obj/JAVA_LIBRARIES/uiautomator.samples_intermediates/javalib.jar&lt;/li&gt;
&lt;li&gt;out/target/product/maguro/obj/JAVA_LIBRARIES/uiautomator.samples_intermediates/javalib.jar&lt;/li&gt;
&lt;li&gt;out/target/product/maguro/system/framework/uiautomator.samples.jar&lt;/li&gt;
&lt;li&gt;uiautomator.samples&lt;/li&gt;
&lt;li&gt;all_modules&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;过程分析&lt;/h2&gt;

&lt;h3&gt;没有R.stamp&lt;/h3&gt;

&lt;p&gt;这个东西,现在看看, 应该算是一个不通用的设计.
从而导致了Android自身的资源也是单独放在一个APK中进行framework化的.
像Android的framework-res.apk作为公共资源, 也不得不利用LOCAL_EXPORT_PACKAGE_RESOURCES这样的接口完成工作.&lt;/p&gt;

&lt;p&gt;可见目前的framework 是不支持资源的.&lt;/p&gt;

&lt;h3&gt;java.mk相关的处理&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;out/target/common/obj/JAVA_LIBRARIES/uiautomator.samples_intermediates/classes-full-debug.jar&lt;/li&gt;
&lt;li&gt;out/target/common/obj/JAVA_LIBRARIES/uiautomator.samples_intermediates/classes-jarjar.jar&lt;/li&gt;
&lt;li&gt;out/target/common/obj/JAVA_LIBRARIES/uiautomator.samples_intermediates/emma_out/lib/classes-jarjar.jar&lt;/li&gt;
&lt;li&gt;out/target/common/obj/JAVA_LIBRARIES/uiautomator.samples_intermediates/classes.jar&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;现在看看,主要是java-&gt;classes-&gt;jarjar-&gt;emma-&gt;proguard&lt;/p&gt;

&lt;h3&gt;out/target/common/obj/JAVA_LIBRARIES/uiautomator.samples_intermediates/javalib.jar&lt;/h3&gt;

&lt;p&gt;主要是为了统一JAVA_LIBRARY 与 STATIC_JAVA_LIBRARY.&lt;/p&gt;

&lt;h3&gt;out/target/product/maguro/obj/JAVA_LIBRARIES/uiautomator.samples_intermediates/javalib.jar&lt;/h3&gt;

&lt;p&gt;产生需要安装的模块.&lt;/p&gt;

&lt;p&gt;该部分与APP不同, 没有如下过程:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;signature zip&lt;/li&gt;
&lt;li&gt;Alignment zip&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;编译脚本&lt;/h1&gt;

&lt;p&gt;整体过程与APP类似, 仅从main.mk出来后进入的是java_library.mk&lt;/p&gt;

&lt;h2&gt;Makefile 处理过程&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Makefile

&lt;ul&gt;
&lt;li&gt;build/core/main.mk

&lt;ul&gt;
&lt;li&gt;studymodules/UiAutomator/Android.mk

&lt;ul&gt;
&lt;li&gt;build/core/clear_vars.mk&lt;/li&gt;
&lt;li&gt;build/core/java_library.mk

&lt;ul&gt;
&lt;li&gt;build/core/java.mk

&lt;ul&gt;
&lt;li&gt;build/core/base_rules.mk&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;具体过程&lt;/h2&gt;

&lt;p&gt;上下文与APP类似,主要关注java_library.mk&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;build/core/java_library.mk

&lt;ul&gt;
&lt;li&gt;环境设置

&lt;ul&gt;
&lt;li&gt;LOCAL_MODULE_SUFFIX&lt;/li&gt;
&lt;li&gt;LOCAL_MODULE_CLASS&lt;/li&gt;
&lt;li&gt;LOCAL_BUILT_MODULE_STEM := javalib.jar&lt;/li&gt;
&lt;li&gt;dexpreopt&lt;/li&gt;
&lt;li&gt;emma&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;build/core/java.mk&lt;/li&gt;
&lt;li&gt;Check is STATIC Library

&lt;ul&gt;
&lt;li&gt;Static

&lt;ul&gt;
&lt;li&gt;Copy classes.jar to built&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Shared

&lt;ul&gt;
&lt;li&gt;classes to dex&lt;/li&gt;
&lt;li&gt;dex to jar&lt;/li&gt;
&lt;li&gt;dexpreopt&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;编译相关API&lt;/h1&gt;

&lt;h2&gt;可以使用的工具&lt;/h2&gt;

&lt;p&gt;在这方面, 整个工具体系主要是java相关的.&lt;/p&gt;

&lt;p&gt;没有了签名,align过程.&lt;/p&gt;

&lt;h2&gt;Java主要API&lt;/h2&gt;

&lt;h3&gt;SRC&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;java&lt;/li&gt;
&lt;li&gt;RenderScript&lt;/li&gt;
&lt;li&gt;Proto&lt;/li&gt;
&lt;li&gt;AIDL&lt;/li&gt;
&lt;li&gt;jni&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;上述过程已经变得简化, 目前涉及java的模块仅有一个static.
全部分析完后, 我们可以从前后关联上看看是如何实现依赖与继承的.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>养生与保健</title>
   <link href="http://www.5wpc.info/it/living/sport/2014/01/07/HealthKeep"/>
   <updated>2014-01-07T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/living/sport/2014/01/07/HealthKeep</id>
   <content type="html">&lt;h1&gt;按摩&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;搓面部:

&lt;ul&gt;
&lt;li&gt;在疲劳时搓一搓脸，不仅面部舒服，而且眼睛明亮，感觉神清气爽。搓脸的好处不仅仅舒展面神经和表情肌，更重要的是可防止面神经炎、视力减退、预防感冒。&lt;/li&gt;
&lt;li&gt;搓脸时的轻重以自己的感觉而定，但宜稍重一些；搓脸时的速度以每秒一次为宜。每日搓脸3～5次为宜，每次不少于5分钟，直到脸上有热烘烘的感觉为止。干性皮肤的人在搓脸时手法不要太重，速度也不要过快，以免搓伤皮肤。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;搓腰眼:

&lt;ul&gt;
&lt;li&gt;http://qjg-wiki.googlecode.com/files/LivingWaistPoint.jpg&lt;/li&gt;
&lt;li&gt;腰眼位于第三腰椎棘突下旁开3。5寸的凹陷处。中医认为，腰眼居“带脉”，为肾脏所在部位。肾喜温恶寒，常按摩腰眼能温煦肾阳、畅达气血。中医认为，用掌搓腰眼和尾闾，不仅可以疏通带脉和强壮腰脊，而且还能起到固精益肾和延年益寿的作用。&lt;/li&gt;
&lt;li&gt;按摩时，两手对搓发热，紧按腰眼处，稍停片刻，然后用力向下搓到尾闾部位（长强穴）。每次做50～100遍，每天早晚各做一次。搓外后两手轻握拳，用拳眼或拳背旋转按摩腰眼处，每次5分钟左右。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;搓脚心:

&lt;ul&gt;
&lt;li&gt;http://qjg-wiki.googlecode.com/files/LivingFootPoint.jpg&lt;/li&gt;
&lt;li&gt;人体在脚心上反射区较多，常搓脚心能起到补脑益肾、益智安神、活血通络的疗效，还可以防治健忘、失眠、消化不良、食欲减退、腹胀、便秘和心、肝、脾、胆等脏器病症。搓脚有干搓和湿搓两种。&lt;/li&gt;
&lt;li&gt;干搓时左手握住左脚背前部，用右手沿脚心上下搓100次，以使脚心发热；换用左手搓右脚脚心。搓的力度以自己舒适为宜。湿搓时把脚放在温水盆中，泡至脚发红，再按干搓的方法搓。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;食物与身体&lt;/h1&gt;

&lt;h2&gt;女生&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;http://pic.yupoo.com/qianjigui/E53ud2Az/medish.jpg&quot; alt=&quot;http://pic.yupoo.com/qianjigui/E53ud2Az/medish.jpg&quot; /&gt;&lt;/p&gt;

&lt;h2&gt;男生&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;http://pic.yupoo.com/qianjigui/E53uKEbQ/medish.jpg&quot; alt=&quot;http://pic.yupoo.com/qianjigui/E53uKEbQ/medish.jpg&quot; /&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>个人情商管理</title>
   <link href="http://www.5wpc.info/it/living/selfmanagement/2014/01/07/EQ"/>
   <updated>2014-01-07T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/living/selfmanagement/2014/01/07/EQ</id>
   <content type="html">&lt;h1&gt;情商培养与处事细节&lt;/h1&gt;

&lt;h2&gt;提高情商的方法&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://www.xuezhonghua.com/article.asp?id=340&quot;&gt;如何提高情商，提高情商的8种方法！&lt;/a&gt;:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;学会划定恰当的心理界限，这对每个人都有好处。&lt;/li&gt;
&lt;li&gt;你必须明白什么是别人可以和不可以对你做的。当别人侵犯了你的心理界限，告诉他，以求得改正。如果总是划不清心理界限，那么你就需要提高自己的认知水平。&lt;/li&gt;
&lt;li&gt;找一个适合自己的方法，在感觉快要失去理智时使自己平静下来，从而使血液留在大脑里，做出理智的行动。&lt;/li&gt;
&lt;li&gt;想抱怨时，停一下先自问：“我是想继续忍受这看起来无法改变的情形呢，还是想改变它呢？”&lt;/li&gt;
&lt;li&gt;扫除一切浪费精力的事物。&lt;/li&gt;
&lt;li&gt;找一个生活中鲜活的榜样。&lt;/li&gt;
&lt;li&gt;从难以相处的人身上学到东西。&lt;/li&gt;
&lt;li&gt;时不时尝试另一种完全不同的方式，你会拓宽视野，提高情商。&lt;/li&gt;
&lt;/ol&gt;


&lt;h3&gt;学会成长&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://www.mifengtd.cn/articles/grow-up.html&quot;&gt;学会成长&lt;/a&gt;:&lt;/p&gt;

&lt;p&gt;不成熟的特征:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;立即要回报

&lt;ul&gt;
&lt;li&gt;一定要懂得先付出！&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;不自律

&lt;ul&gt;
&lt;li&gt;不愿改变自己&lt;/li&gt;
&lt;li&gt;愿意背后议论别人&lt;/li&gt;
&lt;li&gt;消极，抱怨&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;经常被情绪所左右&lt;/li&gt;
&lt;li&gt;不愿学习，自以为是，没有归零心态&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;整体状态&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;高情商

&lt;ul&gt;
&lt;li&gt;尊重所有人的人权和人格尊严。&lt;/li&gt;
&lt;li&gt;不将自己的价值观强加于人。&lt;/li&gt;
&lt;li&gt;对自己有清醒的认识，能承受压力。&lt;/li&gt;
&lt;li&gt;自信而不自满。&lt;/li&gt;
&lt;li&gt;人际关系良好。&lt;/li&gt;
&lt;li&gt;善于处理生活中遇到的各方面的问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;较高情商

&lt;ul&gt;
&lt;li&gt;是负责任的“好”公民。&lt;/li&gt;
&lt;li&gt;自尊。&lt;/li&gt;
&lt;li&gt;有独立人格，但在一些情况下易受别人焦虑情绪的感染。&lt;/li&gt;
&lt;li&gt;比较自信而不自满。&lt;/li&gt;
&lt;li&gt;较好的人际关系。&lt;/li&gt;
&lt;li&gt;能应对大多数的问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;较低情商

&lt;ul&gt;
&lt;li&gt;易受他人影响，自己的目标不明确。&lt;/li&gt;
&lt;li&gt;比低情商者善于原谅，能控制大脑。&lt;/li&gt;
&lt;li&gt;能应付较轻的焦虑情绪。&lt;/li&gt;
&lt;li&gt;把自尊建立在他人认同的基础上。&lt;/li&gt;
&lt;li&gt;缺乏坚定的自我意识。&lt;/li&gt;
&lt;li&gt;人际关系较差。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;低情商

&lt;ul&gt;
&lt;li&gt;自我意识差。&lt;/li&gt;
&lt;li&gt;无确定的目标，也不打算付诸实践。&lt;/li&gt;
&lt;li&gt;严重依赖他人。&lt;/li&gt;
&lt;li&gt;处理人际关系能力差。&lt;/li&gt;
&lt;li&gt;应对焦虑能力差。&lt;/li&gt;
&lt;li&gt;生活无序。&lt;/li&gt;
&lt;li&gt;无责任感，爱抱怨。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;具体问题&lt;/h2&gt;

&lt;h3&gt;如何道歉可将往事一笔勾销&lt;/h3&gt;

&lt;p&gt;  &lt;a href=&quot;http://select.yeeyan.org/view/229384/201866&quot;&gt;如何道歉可将往事一笔勾销&lt;/a&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;主动承担导致关系破裂的责任&lt;/li&gt;
&lt;li&gt;如何从“糟糕”走向“更糟”:

&lt;ul&gt;
&lt;li&gt;太过强调孰是孰非。要记住我们对道歉的新定义。为关系的破裂承担责任。你是要挽救你的面子呢？还是要挽救你的恋情？&lt;/li&gt;
&lt;li&gt;缺乏诚意（只是象征性地安抚一下对方）。这对我们的恋情造成的伤害就像膝跳反应一样自然。请不要用“对不起，但是”接二连三地向对方开火。这只会火上浇油。&lt;/li&gt;
&lt;li&gt;指望，甚至要求对方完全原谅你。这个话题有点大，一会我们再来谈。&lt;/li&gt;
&lt;li&gt;指望对方承认其过错。使用“破镜重圆法”经常会发生对方承认“过错”的情况。但你不能指望这种情况的发生。要记住，你必须对关系破裂承担责任。这就意味着如果你的另一半发生了外遇，你也得承担责任。通常，他们也会承担起自己那部分责任。但再次提醒：如果你指望并/或要求对方承担他们那部分责任，这就大错特错了，就连“破镜重圆法”也帮不了你。&lt;/li&gt;
&lt;li&gt;过早道歉。犯的过错性质越严重，你等待道歉的时间就得越久。如果在被捉奸在床后的几分钟内就安慰性地跟对方道歉，就会显得很没诚意。有道理吧？&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;“破镜重圆法”:

&lt;ul&gt;
&lt;li&gt;心态——心态最重要。这是我们之前就已经谈过的问题。如果你的心态对了，你说的话就会自动发挥作用，问题就能迎刃而解。&lt;/li&gt;
&lt;li&gt;承认对方的感受！&lt;/li&gt;
&lt;li&gt;接下来，处理“为什么”的问题。&lt;/li&gt;
&lt;li&gt;让他们知道你也深受感动。重要提示：不是因为他们的所作所为……而是为你勇于承担责任。&lt;/li&gt;
&lt;li&gt;不作任何声辩，直接奉上你的道歉。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>Ubuntu 10.04 安装 VPN</title>
   <link href="http://www.5wpc.info/it/technical/pcmanage/2014/01/04/vpn"/>
   <updated>2014-01-04T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/technical/pcmanage/2014/01/04/vpn</id>
   <content type="html">&lt;h1&gt;企业 Cisco VPN 安装与配置使用&lt;/h1&gt;

&lt;h2&gt;基本步骤&lt;/h2&gt;

&lt;p&gt;整体分为多步：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;在企业中申请VPN&lt;/li&gt;
&lt;li&gt;安装Cisco VPN客户端，本文针对Cisco AnyConnect VPN&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;重启系统&lt;/em&gt;&lt;/p&gt;

&lt;p&gt; 开始调试了半天, 最后发现需要重新启动系统. 估计是涉及到驱动程序了需要重新load&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;添加VPN&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;配置VPN&lt;/li&gt;
&lt;li&gt;点击连接，输入username&amp;amp;password

&lt;ul&gt;
&lt;li&gt;添加特定IP的路由&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Connect &amp;amp; Use&lt;/li&gt;
&lt;/ol&gt;


&lt;h2&gt;具体使用&lt;/h2&gt;

&lt;p&gt;建议使用命令模式, 这样可以通过不同设备有选择性的访问网络.&lt;/p&gt;

&lt;h3&gt;图示&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://pic.yupoo.com/qianjigui/Dr6AnrCz/medish.jpg&quot; alt=&quot;Install APP&quot; /&gt;
&lt;img src=&quot;http://pic.yupoo.com/qianjigui/Dr6yOOGr/medish.jpg&quot; alt=&quot;Create VPN&quot; /&gt;
&lt;img src=&quot;http://pic.yupoo.com/qianjigui/Dr6AnTj9/medish.jpg&quot; alt=&quot;Setup VPN&quot; /&gt;
&lt;img src=&quot;http://pic.yupoo.com/qianjigui/Dr6Ao37w/medish.jpg&quot; alt=&quot;Connect&quot; /&gt;&lt;/p&gt;

&lt;h3&gt;命令行模式&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;# Connect to server by openconnect
sudo openconnect -u xxxx.xxx vpn.xxx-inc.com

# In other terminal

# list the network interface
ifconfig

# Add route for ip connect
#    route: connect to 10.x.x.x with tun0 device
sudo route add -net 10.0.0.0 netmask 255.0.0.0 dev tun0
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;P2P VPN&lt;/h1&gt;

&lt;p&gt;Ubuntu &lt;a href=&quot;http://ubuntuforums.org/showthread.php?p=7002673&quot;&gt;需要设置个把属性&lt;/a&gt;:
需要让PPTP拒绝EAP验证，而这个设置在VPN设置栏中没有。
需要通过手工进行处理:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;打开gconf-editor&lt;/li&gt;
&lt;li&gt;进入到 /system/networking/connections&lt;/li&gt;
&lt;li&gt;查看并找到VPN文件夹&lt;/li&gt;
&lt;li&gt;添加新的键值&lt;/li&gt;
&lt;li&gt;Name: refuse-eap&lt;/li&gt;
&lt;li&gt;Type: string&lt;/li&gt;
&lt;li&gt;Value: yes&lt;/li&gt;
&lt;li&gt;保存、退出并重新连接&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;日志信息，从错误到成功:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;pppd[5094]: pppd 2.4.5 started by root, uid 0
pppd[5094]: Using interface ppp0
pppd[5094]: Connect: ppp0 &amp;lt;--&amp;gt; /dev/pts/2
pppd[5094]: LCP terminated by peer (WM--^Al^@&amp;lt;M-Mt^@^@^CM-&quot;)
pppd[5094]: Connection terminated.
pppd[5094]: Modem hangup
pppd[5094]: Exit.
pppd[5238]: Plugin /usr/lib/pppd/2.4.5//nm-pptp-pppd-plugin.so loaded.
pppd[5238]: pppd 2.4.5 started by root, uid 0
pppd[5238]: Using interface ppp0
pppd[5238]: Connect: ppp0 &amp;lt;--&amp;gt; /dev/pts/2
pppd[5238]: LCP: timeout sending Config-Requests
pppd[5238]: Connection terminated.
pppd[5238]: Modem hangup
pppd[5238]: Exit.
pppd[5427]: Plugin /usr/lib/pppd/2.4.5//nm-pptp-pppd-plugin.so loaded.
pppd[5427]: pppd 2.4.5 started by root, uid 0
pppd[5427]: Using interface ppp0
pppd[5427]: Connect: ppp0 &amp;lt;--&amp;gt; /dev/pts/2
pppd[5427]: CHAP authentication succeeded
kernel: [20287.732748] PPP BSD Compression module registered
kernel: [20287.768881] PPP Deflate Compression module registered
pppd[5427]: local  IP address 172.0.0.18
pppd[5427]: remote IP address 172.0.0.1
pppd[5427]: primary   DNS address 20x.1x5.xxx.xxx
pppd[5427]: secondary DNS address 20x.1x5.xxx.xxx
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另外就是如果前端有个不怎么给力的路由器，请设置DMZ主机为后端VPN使用的PC机。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>减肥</title>
   <link href="http://www.5wpc.info/it/living/sport/2014/01/04/slim"/>
   <updated>2014-01-04T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/living/sport/2014/01/04/slim</id>
   <content type="html">&lt;h1&gt;饮食事项&lt;/h1&gt;

&lt;h2&gt;三餐重点&lt;/h2&gt;

&lt;h3&gt;全天务实设计&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;早餐

&lt;ul&gt;
&lt;li&gt;牛奶麦片鸡蛋粥&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;午餐

&lt;ul&gt;
&lt;li&gt;炒菜米饭&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;晚餐

&lt;ul&gt;
&lt;li&gt;苹果,全麦吐司&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;原始数据&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;早餐

&lt;ol&gt;
&lt;li&gt; 三明治 240Cal&lt;/li&gt;
&lt;li&gt; 豆浆&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;午餐

&lt;ol&gt;
&lt;li&gt; 米饭 1 碗&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;人均活动&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt; 运动             &lt;/th&gt;
&lt;th&gt;   能量 &lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt; 一天基本运动量   &lt;/td&gt;
&lt;td&gt; 1300Cal&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; 8km/h 跑步 40min &lt;/td&gt;
&lt;td&gt; 220Cal &lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;


&lt;h2&gt;主要食物&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt; 食物             &lt;/th&gt;
&lt;th&gt;   能量 &lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt; 100g cheese cake &lt;/td&gt;
&lt;td&gt; 350Cal &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; 1片吐司          &lt;/td&gt;
&lt;td&gt; 100Cal &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; 1片cheese        &lt;/td&gt;
&lt;td&gt;  80Cal &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; 1个鸡蛋          &lt;/td&gt;
&lt;td&gt;  40Cal &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; 1个orange        &lt;/td&gt;
&lt;td&gt;  50Cal &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; 1个banana        &lt;/td&gt;
&lt;td&gt; 113Cal &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; 1碗rice          &lt;/td&gt;
&lt;td&gt; 232Cal &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt; 1个鸡腿          &lt;/td&gt;
&lt;td&gt; 360Cal &lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;


&lt;h1&gt;21天计划&lt;/h1&gt;

&lt;p&gt;技术参考: http://www.douban.com/group/topic/47534715/&lt;/p&gt;

&lt;p&gt;具体如下:&lt;/p&gt;

&lt;h2&gt;每天注意&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;保持hotwater&lt;/li&gt;
&lt;li&gt;吃相关维生素&lt;/li&gt;
&lt;li&gt;多鼓励&lt;/li&gt;
&lt;li&gt;看不见食物&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;第一阶段&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;3天(1.5-1.7)&lt;/li&gt;
&lt;li&gt;清肠胃, 多喝hotwater, 少运动&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;第二阶段&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;8天(1.8-1.15)&lt;/li&gt;
&lt;li&gt;早上一个苹果, 中午一个橘子/蔬菜, 下午一个苹果&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;第三阶段&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;10天(1.16-1.25)&lt;/li&gt;
&lt;li&gt;早餐: 一杯盐水 + 一颗白煮蛋 + 一个包菜包子&lt;/li&gt;
&lt;li&gt;午餐: 小碗紫薯燕麦粥 + 四片卤干子&lt;/li&gt;
&lt;li&gt;下午: 爆掉啦！！！吃了好多饼干还有橘子- -整个人都很想吐&lt;/li&gt;
&lt;li&gt;晚餐: 无&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>Android 编译系统学习计划</title>
   <link href="http://www.5wpc.info/it/technical/os/android/build/2014/01/03/DetailStudyPlan"/>
   <updated>2014-01-03T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/technical/os/android/build/2014/01/03/DetailStudyPlan</id>
   <content type="html">&lt;h1&gt;学习环境&lt;/h1&gt;

&lt;p&gt;Android: android-4.2.2_r1.2&lt;/p&gt;

&lt;h1&gt;整体目标&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;将原先的功能学习通过demo串起来&lt;/li&gt;
&lt;li&gt;系统化整个demo运行过程中的问题&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;相关问题&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;APP 编译完整流程

&lt;ol&gt;
&lt;li&gt;中间产生物&lt;/li&gt;
&lt;li&gt;内置工具优化与整合: proguard, lint, signature&lt;/li&gt;
&lt;li&gt;对外提供的API&lt;/li&gt;
&lt;li&gt;一个完整的应用将所有参数进行使用&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;编译系统的整个工作过程

&lt;ol&gt;
&lt;li&gt;整体结构关系&lt;/li&gt;
&lt;li&gt;上下模块间关系与传递原理&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;PREBUILT dexpreopt&lt;/li&gt;
&lt;li&gt;apk去so化&lt;/li&gt;
&lt;li&gt;Hack编译系统,添加与修改相关变量&lt;/li&gt;
&lt;li&gt;面向对象化的编译系统模块设计&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;一般学习方法与策略&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;代码静态学习&lt;/li&gt;
&lt;li&gt;通过编译系统动态调试学习

&lt;ol&gt;
&lt;li&gt;准备一个完整的Opensource编译环境&lt;/li&gt;
&lt;li&gt;整体编译完成&lt;/li&gt;
&lt;li&gt;&lt;p&gt;通过单个模块进行分析:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;`shell&quot;&gt; # Add -d to make for debugging information
 mm -B -d | tee a.log
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;查看a.log&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;

</content>
 </entry>
 
 <entry>
   <title>Android APP 模块编译过程学习</title>
   <link href="http://www.5wpc.info/it/technical/os/android/build/2014/01/03/APP"/>
   <updated>2014-01-03T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/technical/os/android/build/2014/01/03/APP</id>
   <content type="html">&lt;h1&gt;学习环境&lt;/h1&gt;

&lt;p&gt;Android: android-4.2.2_r1.2&lt;/p&gt;

&lt;h1&gt;一个例子&lt;/h1&gt;

&lt;h2&gt;模块编译并明确需要分析的过程&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;以下是进入一个已经编译完成的项目, 项目环境要求:

&lt;ul&gt;
&lt;li&gt;PLATFORM_VERSION_CODENAME=REL&lt;/li&gt;
&lt;li&gt;PLATFORM_VERSION=4.2.2&lt;/li&gt;
&lt;li&gt;TARGET_PRODUCT=full_maguro&lt;/li&gt;
&lt;li&gt;TARGET_BUILD_VARIANT=userdebug&lt;/li&gt;
&lt;li&gt;TARGET_BUILD_TYPE=release&lt;/li&gt;
&lt;li&gt;TARGET_BUILD_APPS=&lt;/li&gt;
&lt;li&gt;TARGET_ARCH=arm&lt;/li&gt;
&lt;li&gt;TARGET_ARCH_VARIANT=armv7-a-neon&lt;/li&gt;
&lt;li&gt;HOST_ARCH=x86&lt;/li&gt;
&lt;li&gt;HOST_OS=linux&lt;/li&gt;
&lt;li&gt;HOST_OS_EXTRA=Linux-3.0.0-32-server-x86_64-with-Ubuntu-11.10-oneiric&lt;/li&gt;
&lt;li&gt;HOST_BUILD_TYPE=release&lt;/li&gt;
&lt;li&gt;BUILD_ID=JDQ39E&lt;/li&gt;
&lt;li&gt;OUT_DIR=out&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 其中,请注意需要使用userdebug版本,这样整个编译流程可以完全覆盖.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;进入我们需要进行编译的模块&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;` shell&quot;&gt; # Go to root
 croot
 # Go to Calculator which is a common module
 cd packages/apps/Calculator
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;删除我们不关心的模块编译过程&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;` diff&quot;&gt; diff --git a/Android.mk b/Android.mk
 index 90f5b5f..79b62a6 100644
 --- a/Android.mk
 +++ b/Android.mk
 @@ -28,12 +28,3 @@ LOCAL_SDK_VERSION := current
  LOCAL_PACKAGE_NAME := Calculator

  include $(BUILD_PACKAGE)
 -##################################################
 -include $(CLEAR_VARS)
 -
 -LOCAL_PREBUILT_STATIC_JAVA_LIBRARIES := libarity:arity-2.1.2.jar
 -
 -include $(BUILD_MULTI_PREBUILT)
 -
 -# Use the folloing include to make our test apk.
 -include $(call all-makefiles-under,$(LOCAL_PATH))
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;动态编译,获取中间结果&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;` shell&quot;&gt; mm -B --debug=b | tee basicdebug.log
 grep target basicdebug.log | grep Successfully
       Successfully remade target file `out/target/common/obj/APPS/Calculator_intermediates/src/R.stamp&#39;.
                   Successfully remade target file `out/target/common/obj/APPS/Calculator_intermediates/classes-full-debug.jar&#39;.
                 Successfully remade target file `out/target/common/obj/APPS/Calculator_intermediates/classes-jarjar.jar&#39;.
               Successfully remade target file `out/target/common/obj/APPS/Calculator_intermediates/emma_out/lib/classes-jarjar.jar&#39;.
             Successfully remade target file `out/target/common/obj/APPS/Calculator_intermediates/classes.jar&#39;.
           Successfully remade target file `out/target/common/obj/APPS/Calculator_intermediates/proguard.classes.jar&#39;.
         Successfully remade target file `out/target/common/obj/APPS/Calculator_intermediates/proguard.classes-with-local.dex&#39;.
       Successfully remade target file `out/target/common/obj/APPS/Calculator_intermediates/proguard.classes.dex&#39;.
     Successfully remade target file `out/target/product/maguro/obj/APPS/Calculator_intermediates/package.apk&#39;.
       Successfully remade target file `out/target/product/maguro/obj/NOTICE_FILES/src//system/app/Calculator.apk.txt&#39;.
     Successfully remade target file `out/target/product/maguro/system/app/Calculator.apk&#39;.
   Successfully remade target file `Calculator&#39;.
 Successfully remade target file `all_modules&#39;.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt; 从中,我们可以看到整个Calculator模块的编译涉及这些中间模块:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;out/target/common/obj/APPS/Calculator_intermediates/src/R.stamp&lt;/li&gt;
&lt;li&gt;out/target/common/obj/APPS/Calculator_intermediates/classes-full-debug.jar&lt;/li&gt;
&lt;li&gt;out/target/common/obj/APPS/Calculator_intermediates/classes-jarjar.jar&lt;/li&gt;
&lt;li&gt;out/target/common/obj/APPS/Calculator_intermediates/emma_out/lib/classes-jarjar.jar&lt;/li&gt;
&lt;li&gt;out/target/common/obj/APPS/Calculator_intermediates/classes.jar&lt;/li&gt;
&lt;li&gt;out/target/common/obj/APPS/Calculator_intermediates/proguard.classes.jar&lt;/li&gt;
&lt;li&gt;out/target/common/obj/APPS/Calculator_intermediates/proguard.classes-with-local.dex&lt;/li&gt;
&lt;li&gt;out/target/common/obj/APPS/Calculator_intermediates/proguard.classes.dex&lt;/li&gt;
&lt;li&gt;out/target/product/maguro/obj/APPS/Calculator_intermediates/package.apk&lt;/li&gt;
&lt;li&gt;out/target/product/maguro/obj/NOTICE_FILES/src//system/app/Calculator.apk.txt&lt;/li&gt;
&lt;li&gt;out/target/product/maguro/system/app/Calculator.apk&lt;/li&gt;
&lt;li&gt;Calculator&lt;/li&gt;
&lt;li&gt;all_modules&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h2&gt;过程分析&lt;/h2&gt;

&lt;p&gt;首先我们同样通过make系统动态获取编译的命令:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mm -B --debug=b -n | tee compilecmds.log
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面我们一个个分析各过程.&lt;/p&gt;

&lt;h3&gt;out/target/common/obj/APPS/Calculator_intermediates/src/R.stamp&lt;/h3&gt;

&lt;p&gt;通过aapt工具生成R.java,并cp成R.stamp&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;# 将资源进行编号,ID化
echo &quot;target R.java/Manifest.java: Calculator (out/target/common/obj/APPS/Calculator_intermediates/src/R.stamp)&quot;
# rm old R.stamp
rm -f out/target/common/obj/APPS/Calculator_intermediates/src/R.stamp
mkdir -p out/target/common/obj/APPS/Calculator_intermediates/src
mkdir -p out/target/common/obj/APPS/Calculator_intermediates/
# aapt for generating R.java, 注意生成了R.java
out/host/linux-x86/bin/aapt package -z -m  -J out/target/common/obj/APPS/Calculator_intermediates/src -M packages/apps/Calculator/AndroidManifest.xml -P out/target/common/obj/APPS/Calculator_intermediates/public_resources.xml -S packages/apps/Calculator/res  -I out/target/common/obj/APPS/framework-res_intermediates/package-export.apk -G out/target/common/obj/APPS/Calculator_intermediates/proguard_options --min-sdk-version 17 --target-sdk-version 17 --version-code 17 --version-name 4.2.2-eng.pengcheng.wang.20140103.172137--
# copy all Manifest.java to out/target/common/R/
for GENERATED_MANIFEST_FILE in `find out/target/common/obj/APPS/Calculator_intermediates/src \
&amp;gt;---&amp;gt;---&amp;gt;---&amp;gt;---&amp;gt;----name Manifest.java 2&amp;gt; /dev/null`; do \
&amp;gt;---&amp;gt;---dir=`awk &#39;/package/{gsub(/\./,&quot;/&quot;,$2);gsub(/;/,&quot;&quot;,$2);print $2;exit}&#39; $GENERATED_MANIFEST_FILE`; \
&amp;gt;---&amp;gt;---mkdir -p out/target/common/R/$dir; \
&amp;gt;---&amp;gt;---out/host/linux-x86/bin/acp -fp $GENERATED_MANIFEST_FILE out/target/common/R/$dir; \
&amp;gt;---done;
# copy all R.java to out/target/common/R/
#          copy R.java to R.stamp
for GENERATED_R_FILE in `find out/target/common/obj/APPS/Calculator_intermediates/src \
&amp;gt;---&amp;gt;---&amp;gt;---&amp;gt;---&amp;gt;----name R.java 2&amp;gt; /dev/null`; do \
&amp;gt;---&amp;gt;---dir=`awk &#39;/package/{gsub(/\./,&quot;/&quot;,$2);gsub(/;/,&quot;&quot;,$2);print $2;exit}&#39; $GENERATED_R_FILE`; \
&amp;gt;---&amp;gt;---mkdir -p out/target/common/R/$dir; \
&amp;gt;---&amp;gt;---out/host/linux-x86/bin/acp -fp $GENERATED_R_FILE out/target/common/R/$dir \
&amp;gt;---&amp;gt;---&amp;gt;---|| exit 31; \
&amp;gt;---&amp;gt;---out/host/linux-x86/bin/acp -fp $GENERATED_R_FILE out/target/common/obj/APPS/Calculator_intermediates/src/R.stamp || exit 32; \
&amp;gt;---done; \

      Successfully remade target file `out/target/common/obj/APPS/Calculator_intermediates/src/R.stamp&#39;.
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;out/target/common/obj/APPS/Calculator_intermediates/classes-full-debug.jar&lt;/h3&gt;

&lt;p&gt;基于R.java, 依赖包, 源代码编译成 classes-full-debug.jar&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;# 生成Java classes 保存为 classes-full-debug.jar
echo &quot;target Java: Calculator (out/target/common/obj/APPS/Calculator_intermediates/classes)&quot;
rm -f out/target/common/obj/APPS/Calculator_intermediates/classes-full-debug.jar
rm -rf out/target/common/obj/APPS/Calculator_intermediates/classes
mkdir -p out/target/common/obj/APPS/Calculator_intermediates/
mkdir -p out/target/common/obj/APPS/Calculator_intermediates/classes
# 检查该模块依赖的中间文件
for f in  out/target/common/obj/JAVA_LIBRARIES/libarity_intermediates/javalib.jar  out/target/common/obj/JAVA_LIBRARIES/android-support-v4_intermediates/javalib.jar  out/target/common/obj/JAVA_LIBRARIES/guava_intermediates/javalib.jar; do if [ ! -f $f ]; then echo Missing file $f; exit 1; fi; unzip -qo $f -d out/target/common/obj/APPS/Calculator_intermediates/classes; done ;rm -rf out/target/common/obj/APPS/Calculator_intermediates/classes/META-INF
# 保存一个中间的java源代码列表, 将列表进行保存便于去重与防止bash参数过长(getconf ARG_MAX)
rm -f out/target/common/obj/APPS/Calculator_intermediates/classes/java-source-list
echo -n &#39;packages/apps/Calculator/src/com/android/calculator2/ColorButton.java packages/apps/Calculator/src/com/android/calculator2/CalculatorEditable.java packages/apps/Calculator/src/com/android/calculator2/CalculatorEditText.java packages/apps/Calculator/src/com/android/calculator2/History.java packages/apps/Calculator/src/com/android/calculator2/EventListener.java packages/apps/Calculator/src/com/android/calculator2/Persist.java packages/apps/Calculator/src/com/android/calculator2/CalculatorDisplay.java packages/apps/Calculator/src/com/android/calculator2/Logic.java packages/apps/Calculator/src/com/android/calculator2/Calculator.java packages/apps/Calculator/src/com/android/calculator2/PanelSwitcher.java packages/apps/Calculator/src/com/android/calculator2/CalculatorViewPager.java packages/apps/Calculator/src/com/android/calculator2/HistoryEntry.java packages/apps/Calculator/src/com/android/calculator2/HistoryAdapter.java &#39; &amp;gt;&amp;gt; out/target/common/obj/APPS/Calculator_intermediates/classes/java-source-list
if [ -d &quot;out/target/common/obj/APPS/Calculator_intermediates/src&quot; ]; then find out/target/common/obj/APPS/Calculator_intermediates/src -name &#39;*.java&#39; &amp;gt;&amp;gt; out/target/common/obj/APPS/Calculator_intermediates/classes/java-source-list; fi
tr &#39; &#39; &#39;\n&#39; &amp;lt; out/target/common/obj/APPS/Calculator_intermediates/classes/java-source-list | sort -u &amp;gt; out/target/common/obj/APPS/Calculator_intermediates/classes/java-source-list-uniq
# javac 走起
if [ -s out/target/common/obj/APPS/Calculator_intermediates/classes/java-source-list-uniq ] ; then javac -J-Xmx512M -target 1.5 -Xmaxerrs 9999999 -encoding UTF-8 -g  -bootclasspath out/target/common/obj/JAVA_LIBRARIES/android_stubs_current_intermediates/classes.jar -classpath out/target/common/obj/JAVA_LIBRARIES/android_stubs_current_intermediates/classes.jar:out/target/common/obj/JAVA_LIBRARIES/libarity_intermediates/javalib.jar:out/target/common/obj/JAVA_LIBRARIES/android-support-v4_intermediates/javalib.jar:out/target/common/obj/JAVA_LIBRARIES/guava_intermediates/javalib.jar  -extdirs &quot;&quot; -d out/target/common/obj/APPS/Calculator_intermediates/classes  \@out/target/common/obj/APPS/Calculator_intermediates/classes/java-source-list-uniq || ( rm -rf out/target/common/obj/APPS/Calculator_intermediates/classes ; exit 41 ) fi
rm -f out/target/common/obj/APPS/Calculator_intermediates/classes/java-source-list
rm -f out/target/common/obj/APPS/Calculator_intermediates/classes/java-source-list-uniq
# jar 打包
jar -cf out/target/common/obj/APPS/Calculator_intermediates/classes-full-debug.jar  -C out/target/common/obj/APPS/Calculator_intermediates/classes .
                  Successfully remade target file `out/target/common/obj/APPS/Calculator_intermediates/classes-full-debug.jar&#39;.
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;out/target/common/obj/APPS/Calculator_intermediates/classes-jarjar.jar&lt;/h3&gt;

&lt;p&gt;cp classes-full-debug.jar intermediates/classes-jarjar.jar&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;# 生成classes-jarjar.jar
echo Copying: out/target/common/obj/APPS/Calculator_intermediates/classes-jarjar.jar
# acp: Android cp command
out/host/linux-x86/bin/acp -fp out/target/common/obj/APPS/Calculator_intermediates/classes-full-debug.jar out/target/common/obj/APPS/Calculator_intermediates/classes-jarjar.jar
                Successfully remade target file `out/target/common/obj/APPS/Calculator_intermediates/classes-jarjar.jar&#39;.
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;out/target/common/obj/APPS/Calculator_intermediates/emma_out/lib/classes-jarjar.jar&lt;/h3&gt;

&lt;p&gt;cp intermediates/classes-jarjar.jar emma_out/lib/classes-jarjar.jar&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;# 生成存放在emma_out下的classes-jarjar.jar
echo Copying: out/target/common/obj/APPS/Calculator_intermediates/emma_out/lib/classes-jarjar.jar
mkdir -p out/target/common/obj/APPS/Calculator_intermediates/emma_out/lib/
out/host/linux-x86/bin/acp -fp out/target/common/obj/APPS/Calculator_intermediates/classes-jarjar.jar out/target/common/obj/APPS/Calculator_intermediates/emma_out/lib/classes-jarjar.jar
              Successfully remade target file `out/target/common/obj/APPS/Calculator_intermediates/emma_out/lib/classes-jarjar.jar&#39;.
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;out/target/common/obj/APPS/Calculator_intermediates/classes.jar&lt;/h3&gt;

&lt;p&gt;cp intermediates/emma_out/lib/classes-jarjar.jar classes.jar&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;# 生成classes.jar
echo Copying: out/target/common/obj/APPS/Calculator_intermediates/classes.jar
out/host/linux-x86/bin/acp -fp out/target/common/obj/APPS/Calculator_intermediates/emma_out/lib/classes-jarjar.jar out/target/common/obj/APPS/Calculator_intermediates/classes.jar
            Successfully remade target file `out/target/common/obj/APPS/Calculator_intermediates/classes.jar&#39;.
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;out/target/common/obj/APPS/Calculator_intermediates/proguard.classes.jar&lt;/h3&gt;

&lt;p&gt;通过proguard.sh基于classes.jar生成proguard.classes.jar&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;echo Proguard: out/target/common/obj/APPS/Calculator_intermediates/proguard.classes.jar
external/proguard/bin/proguard.sh -injars out/target/common/obj/APPS/Calculator_intermediates/classes.jar -outjars out/target/common/obj/APPS/Calculator_intermediates/proguard.classes.jar -libraryjars out/target/common/obj/JAVA_LIBRARIES/android_stubs_current_intermediates/classes.jar -include build/core/proguard.flags -forceprocessing -printmapping out/target/common/obj/APPS/Calculator_intermediates/proguard_dictionary -include out/target/common/obj/APPS/Calculator_intermediates/proguard_options
---
          Successfully remade target file `out/target/common/obj/APPS/Calculator_intermediates/proguard.classes.jar&#39;.
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;out/target/common/obj/APPS/Calculator_intermediates/proguard.classes-with-local.dex&lt;/h3&gt;

&lt;p&gt;基于proguard.classes.jar通过dx生成proguard.classes-with-local.dex&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;echo &quot;target Dex: Calculator&quot;
mkdir -p out/target/common/obj/APPS/Calculator_intermediates/
out/host/linux-x86/bin/dx -JXms16M -JXmx2048M --dex --output=out/target/common/obj/APPS/Calculator_intermediates/proguard.classes-with-local.dex     out/target/common/obj/APPS/Calculator_intermediates/proguard.classes.jar
        Successfully remade target file `out/target/common/obj/APPS/Calculator_intermediates/proguard.classes-with-local.dex&#39;.
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;out/target/common/obj/APPS/Calculator_intermediates/proguard.classes.dex&lt;/h3&gt;

&lt;p&gt;cp proguard.classes-with-local.dex proguard.classes.dex&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;echo Copying: out/target/common/obj/APPS/Calculator_intermediates/proguard.classes.dex
out/host/linux-x86/bin/acp -fp out/target/common/obj/APPS/Calculator_intermediates/proguard.classes-with-local.dex out/target/common/obj/APPS/Calculator_intermediates/proguard.classes.dex
      Successfully remade target file `out/target/common/obj/APPS/Calculator_intermediates/proguard.classes.dex&#39;.
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;out/target/product/maguro/obj/APPS/Calculator_intermediates/package.apk&lt;/h3&gt;

&lt;p&gt;整体步骤:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;create a zip&lt;/li&gt;
&lt;li&gt;add resources to zip&lt;/li&gt;
&lt;li&gt;add dex to zip&lt;/li&gt;
&lt;li&gt;update zip by jar flags&lt;/li&gt;
&lt;li&gt;signature zip&lt;/li&gt;
&lt;li&gt;Alignment zip&lt;/li&gt;
&lt;/ol&gt;


&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;echo &quot;target Package: Calculator (out/target/product/maguro/obj/APPS/Calculator_intermediates/package.apk)&quot;
mkdir -p out/target/product/maguro/obj/APPS/Calculator_intermediates/
# make a empty file for create a zip
touch out/target/product/maguro/obj/APPS/Calculator_intermediates//dummy
(cd out/target/product/maguro/obj/APPS/Calculator_intermediates/ &amp;amp;&amp;amp; jar cf package.apk dummy)
# create a zip with empty dummy file
zip -qd out/target/product/maguro/obj/APPS/Calculator_intermediates/package.apk dummy
# rm dummy
rm out/target/product/maguro/obj/APPS/Calculator_intermediates//dummy
# Add resouces to zip
out/host/linux-x86/bin/aapt package -u -z -c en_US,en_US,cs_CZ,da_DK,de_AT,de_CH,de_DE,de_LI,el_GR,en_AU,en_CA,en_GB,en_NZ,en_SG,eo_EU,es_ES,fr_CA,fr_CH,fr_BE,fr_FR,it_CH,it_IT,ja_JP,ko_KR,nb_NO,nl_BE,nl_NL,pl_PL,pt_PT,ru_RU,sv_SE,tr_TR,zh_CN,zh_HK,zh_TW,am_ET,hi_IN,en_US,fr_FR,it_IT,es_ES,de_DE,nl_NL,cs_CZ,pl_PL,ja_JP,zh_TW,zh_CN,ru_RU,ko_KR,nb_NO,es_US,da_DK,el_GR,tr_TR,pt_PT,pt_BR,rm_CH,sv_SE,bg_BG,ca_ES,en_GB,fi_FI,hi_IN,hr_HR,hu_HU,in_ID,iw_IL,lt_LT,lv_LV,ro_RO,sk_SK,sl_SI,sr_RS,uk_UA,vi_VN,tl_PH,ar_EG,fa_IR,th_TH,sw_TZ,ms_MY,af_ZA,zu_ZA,am_ET,hi_IN,normal,hdpi,xhdpi,nodpi --preferred-configurations xhdpi -M packages/apps/Calculator/AndroidManifest.xml -S packages/apps/Calculator/res  -I out/target/common/obj/APPS/framework-res_intermediates/package-export.apk --min-sdk-version 17 --target-sdk-version 17 --product nosdcard --version-code 17 --version-name 4.2.2-eng.pengcheng.wang.20140103.172137   -F out/target/product/maguro/obj/APPS/Calculator_intermediates/package.apk
# add dex to zip
_adtp_classes_dex=out/target/common/obj/APPS/Calculator_intermediates/classes.dex; cp out/target/common/obj/APPS/Calculator_intermediates/proguard.classes.dex $_adtp_classes_dex &amp;amp;&amp;amp; out/host/linux-x86/bin/aapt add -k out/target/product/maguro/obj/APPS/Calculator_intermediates/package.apk $_adtp_classes_dex &amp;amp;&amp;amp; rm -f $_adtp_classes_dex
# update zip by jar flags
if [ -d out/target/common/obj/APPS/Calculator_intermediates/classes ] ; then java_res_jar_flags=$(find out/target/common/obj/APPS/Calculator_intermediates/classes -type f -a -not -name &quot;*.class&quot; | sed -e &quot;s?^out/target/common/obj/APPS/Calculator_intermediates/classes/? -C out/target/common/obj/APPS/Calculator_intermediates/classes ?&quot;); if [ -n &quot;$java_res_jar_flags&quot; ] ; then echo $java_res_jar_flags &amp;gt;out/target/product/maguro/obj/APPS/Calculator_intermediates/java_res_jar_flags; jar uf out/target/product/maguro/obj/APPS/Calculator_intermediates/package.apk $java_res_jar_flags; fi; fi
# Prepare for signature
mv out/target/product/maguro/obj/APPS/Calculator_intermediates/package.apk out/target/product/maguro/obj/APPS/Calculator_intermediates/package.apk.unsigned
# signature
java -jar out/host/linux-x86/framework/signapk.jar build/target/product/security/testkey.x509.pem build/target/product/security/testkey.pk8 out/target/product/maguro/obj/APPS/Calculator_intermediates/package.apk.unsigned out/target/product/maguro/obj/APPS/Calculator_intermediates/package.apk.signed
# Finish signature
mv out/target/product/maguro/obj/APPS/Calculator_intermediates/package.apk.signed out/target/product/maguro/obj/APPS/Calculator_intermediates/package.apk
# Prepare for Alignment
# Alignment must happen after all other zip operations.
mv out/target/product/maguro/obj/APPS/Calculator_intermediates/package.apk out/target/product/maguro/obj/APPS/Calculator_intermediates/package.apk.unaligned
# Alignment
out/host/linux-x86/bin/zipalign -f 4 out/target/product/maguro/obj/APPS/Calculator_intermediates/package.apk.unaligned out/target/product/maguro/obj/APPS/Calculator_intermediates/package.apk.aligned
# To apk
mv out/target/product/maguro/obj/APPS/Calculator_intermediates/package.apk.aligned out/target/product/maguro/obj/APPS/Calculator_intermediates/package.apk
    Successfully remade target file `out/target/product/maguro/obj/APPS/Calculator_intermediates/package.apk&#39;.
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;out/target/product/maguro/obj/NOTICE_FILES/src//system/app/Calculator.apk.txt&lt;/h3&gt;

&lt;p&gt;cp NOTICE to Calculator.apk.txt&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;echo Notice file: packages/apps/Calculator/NOTICE -- out/target/product/maguro/obj/NOTICE_FILES/src//system/app/Calculator.apk.txt
mkdir -p out/target/product/maguro/obj/NOTICE_FILES/src//system/app/
cat packages/apps/Calculator/NOTICE &amp;gt;&amp;gt; out/target/product/maguro/obj/NOTICE_FILES/src//system/app/Calculator.apk.txt
      Successfully remade target file `out/target/product/maguro/obj/NOTICE_FILES/src//system/app/Calculator.apk.txt&#39;.
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;out/target/product/maguro/system/app/Calculator.apk&lt;/h3&gt;

&lt;p&gt;cp package.apk Calculator.apk&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;echo &quot;Install: out/target/product/maguro/system/app/Calculator.apk&quot;
mkdir -p out/target/product/maguro/system/app/
out/host/linux-x86/bin/acp -fp out/target/product/maguro/obj/APPS/Calculator_intermediates/package.apk out/target/product/maguro/system/app/Calculator.apk
    Successfully remade target file `out/target/product/maguro/system/app/Calculator.apk&#39;.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;过程回顾&lt;/h2&gt;

&lt;h3&gt;从中看到的一般流程&lt;/h3&gt;

&lt;p&gt;来自&lt;a href=&quot;http://developer.android.com/tools/building/index.html#detailed-build&quot;&gt;Android官方&lt;/a&gt;的解释:
&lt;img src=&quot;http://developer.android.com/images/build.png&quot; alt=&quot;Android APK Build Steps&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The general process for a typical build is outlined below:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The Android Asset Packaging Tool (aapt) takes your application resource files, such as the AndroidManifest.xml file and the XML files for your Activities, and compiles them. An R.java is also produced so you can reference your resources from your Java code.&lt;/li&gt;
&lt;li&gt;The aidl tool converts any .aidl interfaces that you have into Java interfaces.&lt;/li&gt;
&lt;li&gt;All of your Java code, including the R.java and .aidl files, are compiled by the Java compiler and .class files are output.&lt;/li&gt;
&lt;li&gt;The dex tool converts the .class files to Dalvik byte code. Any 3rd party libraries and .class files that you have included in your project are also converted into .dex files so that they can be packaged into the final .apk file.&lt;/li&gt;
&lt;li&gt;All non-compiled resources (such as images), compiled resources, and the .dex files are sent to the apkbuilder tool to be packaged into an .apk file.&lt;/li&gt;
&lt;li&gt;Once the .apk is built, it must be signed with either a debug or release key before it can be installed to a device.&lt;/li&gt;
&lt;li&gt;Finally, if the application is being signed in release mode, you must align the .apk with the zipalign tool. Aligning the final .apk decreases memory usage when the application is running on a device.&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;整体分为如下过程:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;资源ID准备

&lt;ol&gt;
&lt;li&gt;aapt to R.java&lt;/li&gt;
&lt;li&gt;aidl to Java interfaces&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;运行时文件生成

&lt;ol&gt;
&lt;li&gt;javac to classes&lt;/li&gt;
&lt;li&gt;classes 级优化与包装

&lt;ol&gt;
&lt;li&gt;proguard&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;dx to dex&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;apk 组装

&lt;ol&gt;
&lt;li&gt;empty zip&lt;/li&gt;
&lt;li&gt;add resources&lt;/li&gt;
&lt;li&gt;add dex&lt;/li&gt;
&lt;li&gt;update zip

&lt;ol&gt;
&lt;li&gt;jar flags&lt;/li&gt;
&lt;li&gt;signature&lt;/li&gt;
&lt;li&gt;zipalign&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h3&gt;各个中间文件的作用&lt;/h3&gt;

&lt;p&gt;各模块在编译系统中的对应关系与具体作用:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;out/target/common/obj/APPS/Calculator_intermediates/src/R.stamp

&lt;ul&gt;
&lt;li&gt;R.java stub&lt;/li&gt;
&lt;li&gt;R_file_stamp&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;out/target/common/obj/APPS/Calculator_intermediates/classes-full-debug.jar

&lt;ul&gt;
&lt;li&gt;LOCAL_EMMA_INSTRUMENT == false&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.ibm.com/developerworks/cn/opensource/os-cn-emma&quot;&gt;emma 测试覆盖工具&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;full_classes_compiled_jar_leaf&lt;/li&gt;
&lt;li&gt;full_classes_compiled_jar&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;out/target/common/obj/APPS/Calculator_intermediates/classes-jarjar.jar

&lt;ul&gt;
&lt;li&gt;LOCAL_JARJAR_RULES != &#39;&#39;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.xinotes.org/notes/note/1468/&quot;&gt;A utility to repackage and embed Java libraries&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;可以重新指定类中的package引用名&lt;/li&gt;
&lt;li&gt;full_classes_jarjar_jar&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;out/target/common/obj/APPS/Calculator_intermediates/emma_out/lib/classes-jarjar.jar

&lt;ul&gt;
&lt;li&gt;full_classes_emma_jar&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;out/target/common/obj/APPS/Calculator_intermediates/classes.jar

&lt;ul&gt;
&lt;li&gt;full_classes_jar&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;out/target/common/obj/APPS/Calculator_intermediates/proguard.classes.jar

&lt;ul&gt;
&lt;li&gt;full_classes_proguard_jar&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;out/target/common/obj/APPS/Calculator_intermediates/proguard.classes-with-local.dex

&lt;ul&gt;
&lt;li&gt;LOCAL_EMMA_INSTRUMENT == false&lt;/li&gt;
&lt;li&gt;built_dex_intermediate&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;out/target/common/obj/APPS/Calculator_intermediates/proguard.classes.dex

&lt;ul&gt;
&lt;li&gt;built_dex&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;out/target/product/maguro/obj/APPS/Calculator_intermediates/package.apk

&lt;ul&gt;
&lt;li&gt;LOCAL_BUILT_MODULE_STEM&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;out/target/product/maguro/obj/NOTICE_FILES/src//system/app/Calculator.apk.txt&lt;/li&gt;
&lt;li&gt;out/target/product/maguro/system/app/Calculator.apk

&lt;ul&gt;
&lt;li&gt;LOCAL_BUILT_MODULE&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Calculator

&lt;ul&gt;
&lt;li&gt;LOCAL_PACKAGE_NAME&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;all_modules&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;中间整体加载的Makefile&lt;/h3&gt;

&lt;p&gt;完整的Makefile加载过程见下面的log:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;This program built for x86_64-pc-linux-gnu
Reading makefiles...
Reading makefile `Makefile&#39;...
Reading makefile `build/core/main.mk&#39; (search path) (no ~ expansion)...
Reading makefile `build/core/help.mk&#39; (search path) (no ~ expansion)...
Reading makefile `build/core/config.mk&#39; (search path) (no ~ expansion)...
Reading makefile `build/core/pathmap.mk&#39; (search path) (no ~ expansion)...
Reading makefile `cts/build/config.mk&#39; (search path) (don&#39;t care) (no ~ expansion)...
Reading makefile `buildspec.mk&#39; (search path) (don&#39;t care) (no ~ expansion)...
Reading makefile `build/core/envsetup.mk&#39; (search path) (no ~ expansion)...
Reading makefile `build/core/version_defaults.mk&#39; (search path) (no ~ expansion)...
Reading makefile `build/core/build_id.mk&#39; (search path) (no ~ expansion)...
Reading makefile `build/core/product_config.mk&#39; (search path) (no ~ expansion)...
Reading makefile `build/core/node_fns.mk&#39; (search path) (no ~ expansion)...
Reading makefile `build/core/product.mk&#39; (search path) (no ~ expansion)...
Reading makefile `build/core/device.mk&#39; (search path) (no ~ expansion)...
Reading makefile `device/lge/mako/AndroidProducts.mk&#39; (search path) (no ~ expansion)...
Reading makefile `device/generic/armv7-a-neon/AndroidProducts.mk&#39; (search path) (no ~ expansion)...
Reading makefile `device/generic/armv7-a/AndroidProducts.mk&#39; (search path) (no ~ expansion)...
Reading makefile `device/generic/x86/AndroidProducts.mk&#39; (search path) (no ~ expansion)...
Reading makefile `device/generic/mips/AndroidProducts.mk&#39; (search path) (no ~ expansion)...
Reading makefile `device/ti/panda/AndroidProducts.mk&#39; (search path) (no ~ expansion)...
Reading makefile `device/sample/products/AndroidProducts.mk&#39; (search path) (no ~ expansion)...
Reading makefile `device/asus/tilapia/AndroidProducts.mk&#39; (search path) (no ~ expansion)...
Reading makefile `device/asus/grouper/AndroidProducts.mk&#39; (search path) (no ~ expansion)...
Reading makefile `device/samsung/manta/AndroidProducts.mk&#39; (search path) (no ~ expansion)...
Reading makefile `device/samsung/tuna/AndroidProducts.mk&#39; (search path) (no ~ expansion)...
Reading makefile `device/samsung/toro/AndroidProducts.mk&#39; (search path) (no ~ expansion)...
Reading makefile `device/samsung/toroplus/AndroidProducts.mk&#39; (search path) (no ~ expansion)...
Reading makefile `device/samsung/maguro/AndroidProducts.mk&#39; (search path) (no ~ expansion)...
Reading makefile `build/target/product/AndroidProducts.mk&#39; (search path) (no ~ expansion)...
Reading makefile `device/samsung/maguro/full_maguro.mk&#39; (search path) (no ~ expansion)...
Reading makefile `build/target/product/full_base_telephony.mk&#39; (search path) (no ~ expansion)...
Reading makefile `build/target/product/full_base.mk&#39; (search path) (no ~ expansion)...
Reading makefile `build/target/product/generic_no_telephony.mk&#39; (search path) (no ~ expansion)...
Reading makefile `build/target/product/core.mk&#39; (search path) (no ~ expansion)...
Reading makefile `build/target/product/base.mk&#39; (search path) (no ~ expansion)...
Reading makefile `external/cibu-fonts/fonts.mk&#39; (search path) (no ~ expansion)...
Reading makefile `external/lohit-fonts/fonts.mk&#39; (search path) (no ~ expansion)...
Reading makefile `external/naver-fonts/fonts.mk&#39; (search path) (no ~ expansion)...
Reading makefile `frameworks/base/data/fonts/fonts.mk&#39; (search path) (no ~ expansion)...
Reading makefile `frameworks/base/data/keyboards/keyboards.mk&#39; (search path) (no ~ expansion)...
Reading makefile `frameworks/base/data/keyboards/common.mk&#39; (search path) (no ~ expansion)...
Reading makefile `build/target/product/locales_full.mk&#39; (search path) (no ~ expansion)...
Reading makefile `build/target/product/languages_full.mk&#39; (search path) (no ~ expansion)...
Reading makefile `external/svox/pico/lang/all_pico_languages.mk&#39; (search path) (no ~ expansion)...
Reading makefile `external/svox/pico/lang/PicoLangDeDeInSystem.mk&#39; (search path) (no ~ expansion)...
Reading makefile `external/svox/pico/lang/PicoLangEnGBInSystem.mk&#39; (search path) (no ~ expansion)...
Reading makefile `external/svox/pico/lang/PicoLangEnUsInSystem.mk&#39; (search path) (no ~ expansion)...
Reading makefile `external/svox/pico/lang/PicoLangEsEsInSystem.mk&#39; (search path) (no ~ expansion)...
Reading makefile `external/svox/pico/lang/PicoLangFrFrInSystem.mk&#39; (search path) (no ~ expansion)...
Reading makefile `external/svox/pico/lang/PicoLangItItInSystem.mk&#39; (search path) (no ~ expansion)...
Reading makefile `frameworks/base/data/sounds/AllAudio.mk&#39; (search path) (no ~ expansion)...
Reading makefile `frameworks/base/data/sounds/AudioPackage2.mk&#39; (search path) (no ~ expansion)...
Reading makefile `frameworks/base/data/sounds/AudioPackage3.mk&#39; (search path) (no ~ expansion)...
Reading makefile `frameworks/base/data/sounds/AudioPackage4.mk&#39; (search path) (no ~ expansion)...
Reading makefile `frameworks/base/data/sounds/AudioPackage5.mk&#39; (search path) (no ~ expansion)...
Reading makefile `frameworks/base/data/sounds/AudioPackage6.mk&#39; (search path) (no ~ expansion)...
Reading makefile `frameworks/base/data/sounds/AudioPackage7.mk&#39; (search path) (no ~ expansion)...
Reading makefile `frameworks/base/data/sounds/AudioPackage7alt.mk&#39; (search path) (no ~ expansion)...
Reading makefile `frameworks/base/data/sounds/OriginalAudio.mk&#39; (search path) (no ~ expansion)...
Reading makefile `build/target/product/telephony.mk&#39; (search path) (no ~ expansion)...
Reading makefile `device/samsung/maguro/device.mk&#39; (search path) (no ~ expansion)...
Reading makefile `device/samsung/tuna/device.mk&#39; (search path) (no ~ expansion)...
Reading makefile `frameworks/native/build/phone-xhdpi-1024-dalvik-heap.mk&#39; (search path) (no ~ expansion)...
Reading makefile `hardware/broadcom/wlan/bcmdhd/firmware/bcm4330/device-bcm.mk&#39; (search path) (no ~ expansion)...
Reading makefile `hardware/ti/omap4xxx/omap4.mk&#39; (search path) (no ~ expansion)...
Reading makefile `device/samsung/maguro/BoardConfig.mk&#39; (search path) (no ~ expansion)...
Reading makefile `vendor/samsung/maguro/BoardConfigVendor.mk&#39; (search path) (don&#39;t care) (no ~ expansion)...
Reading makefile `device/samsung/tuna/BoardConfig.mk&#39; (search path) (no ~ expansion)...
Reading makefile `vendor/samsung/tuna/BoardConfigVendor.mk&#39; (search path) (don&#39;t care) (no ~ expansion)...
Reading makefile `build/core/combo/select.mk&#39; (search path) (no ~ expansion)...
Reading makefile `build/core/combo/HOST_linux-x86.mk&#39; (search path) (no ~ expansion)...
Reading makefile `build/core/combo/select.mk&#39; (search path) (no ~ expansion)...
Reading makefile `build/core/combo/TARGET_linux-arm.mk&#39; (search path) (no ~ expansion)...
Reading makefile `build/core/combo/arch/arm/armv7-a-neon.mk&#39; (search path) (no ~ expansion)...
Reading makefile `build/core/combo/javac.mk&#39; (search path) (no ~ expansion)...
Reading makefile `build/core/llvm_config.mk&#39; (search path) (no ~ expansion)...
Reading makefile `build/core/dumpvar.mk&#39; (search path) (no ~ expansion)...
Reading makefile `build/core/cleanbuild.mk&#39; (search path) (no ~ expansion)...
Reading makefile `build/core/cleanspec.mk&#39; (search path) (no ~ expansion)...
Reading makefile `packages/apps/Calculator/CleanSpec.mk&#39; (search path) (no ~ expansion)...
Reading makefile `out/target/product/maguro/clean_steps.mk&#39; (search path) (don&#39;t care) (no ~ expansion)...
Reading makefile `out/target/product/maguro/previous_build_config.mk&#39; (search path) (don&#39;t care) (no ~ expansion)...
Reading makefile `out/versions_checked.mk&#39; (search path) (don&#39;t care) (no ~ expansion)...
Reading makefile `build/core/definitions.mk&#39; (search path) (no ~ expansion)...
Reading makefile `build/core/distdir.mk&#39; (search path) (no ~ expansion)...
Reading makefile `build/core/dex_preopt.mk&#39; (search path) (no ~ expansion)...
Reading makefile `build/core/pdk_config.mk&#39; (search path) (no ~ expansion)...
Reading makefile `packages/apps/Calculator/Android.mk&#39; (search path) (no ~ expansion)...
Reading makefile `build/core/clear_vars.mk&#39; (search path) (no ~ expansion)...
Reading makefile `build/core/package.mk&#39; (search path) (no ~ expansion)...
Reading makefile `build/core/java.mk&#39; (search path) (no ~ expansion)...
Reading makefile `build/core/base_rules.mk&#39; (search path) (no ~ expansion)...
Reading makefile `build/core/notice_files.mk&#39; (search path) (no ~ expansion)...
Reading makefile `build/core/post_clean.mk&#39; (search path) (no ~ expansion)...
Reading makefile `build/core/legacy_prebuilts.mk&#39; (search path) (no ~ expansion)...
Reading makefile `build/core/Makefile&#39; (search path) (no ~ expansion)...
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;编译脚本&lt;/h1&gt;

&lt;p&gt;目前先关注主要的Makefile过程,后续从整体上分析整个系统的结构.
例如后续从APPS入手,分析整个编译系统的功能分布与依赖继承关系.&lt;/p&gt;

&lt;h2&gt;Makefile加载的主要步骤&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Makefile

&lt;ul&gt;
&lt;li&gt;build/core/main.mk

&lt;ul&gt;
&lt;li&gt;packages/apps/Calculator/CleanSpec.mk&lt;/li&gt;
&lt;li&gt;packages/apps/Calculator/Android.mk

&lt;ul&gt;
&lt;li&gt;build/core/clear_vars.mk&lt;/li&gt;
&lt;li&gt;build/core/package.mk

&lt;ul&gt;
&lt;li&gt;build/core/java.mk

&lt;ul&gt;
&lt;li&gt;build/core/base_rules.mk&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;具体运行过程&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;mm
    M=packages/apps/Calculator/Android.mk
    T=TOPDIR/Makefile
    ONE_SHOT_MAKEFILE=$M make -C $T all_modules $@
        $T include build/core/main.mk
            build/core/main.mk include $(ONE_SHOT_MAKEFILE)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;各个过程的功能&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;mm 获取上下文与目标Android.mk后, 设置关键ONE_SHOT_MAKEFILE, 并进入make&lt;/li&gt;
&lt;li&gt;build/core/main.mk

&lt;ul&gt;
&lt;li&gt;设置系统环境&lt;/li&gt;
&lt;li&gt;定义目标&lt;/li&gt;
&lt;li&gt;packages/apps/Calculator/Android.mk

&lt;ul&gt;
&lt;li&gt;清理LOCAL_*变量&lt;/li&gt;
&lt;li&gt;定义编译模块相关的源代码等&lt;/li&gt;
&lt;li&gt;build/core/package.mk

&lt;ul&gt;
&lt;li&gt;AndroidManifest指定&lt;/li&gt;
&lt;li&gt;应用资源指定&lt;/li&gt;
&lt;li&gt;模块依赖

&lt;ul&gt;
&lt;li&gt;PROGUARD&lt;/li&gt;
&lt;li&gt;EMMA&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;build/core/java.mk&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;依赖模块定义(JAVA_LIBRARIES, STATIC_JAVA_LIBRARIES)&lt;/li&gt;
&lt;li&gt;PROGUARD&lt;/li&gt;
&lt;li&gt;renderscript&lt;/li&gt;
&lt;li&gt;base/core/base_rules.mk

&lt;ul&gt;
&lt;li&gt;相关模块的依赖关系定义(主要用于与具体模块无关的上下文关系定义, 并可以明确需要安装的具体模块)&lt;/li&gt;
&lt;li&gt;.aidl to java&lt;/li&gt;
&lt;li&gt;Add .logtags&lt;/li&gt;
&lt;li&gt;proto to java&lt;/li&gt;
&lt;li&gt;java to class&lt;/li&gt;
&lt;li&gt;定义make clean的具体任务&lt;/li&gt;
&lt;li&gt;Install 模块相关定义

&lt;ul&gt;
&lt;li&gt;do dexpreopt&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Register with ALL_MODULES&lt;/li&gt;
&lt;li&gt;NOTICE file target&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;定义中间模块产生的具体command&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;``shell&quot;&gt;  $(full_classes_compiled_jar): $(java_sources) $(java_resource_sources) $(full_java_lib_deps) $(jar_manifest_file) $(RenderScript_file_stamp) $(proto_java_sources_file_stamp)
     $(transform-java-to-classes.jar)
  $(full_classes_jarjar_jar): $(full_classes_compiled_jar)
     # 根据是否需要jarjar的不同采用不同的处理
     # JARJAR
  $(full_classes_emma_jar): $(full_classes_jarjar_jar)
     # 根据是否需要emma的不同采用不同的处理
     # EMMA
  $(full_classes_jar): $(full_classes_emma_jar) | $(ACP)
  $(full_classes_proguard_jar) : $(full_classes_jar) $(proguard_flag_files)
      # PROGUARD
  $(built_dex_intermediate): $(full_classes_proguard_jar) $(DX)
      # DEX
  $(built_dex): $(built_dex_intermediate) | $(ACP)
  $(findbugs_xml) : $(LOCAL_BUILT_MODULE)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;定义APP相关数据的生成&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;``shell&quot;&gt;  $(R_file_stamp): $(all_res_assets) $(full_android_manifest) $(RenderScript_file_stamp) $(AAPT) | $(ACP)
      # AAPT
  $(LOCAL_BUILT_MODULE): XXXXX
      # PACKAGE
      # signature
      # zipalign
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;lintall : lint-$(LOCAL_PACKAGE_NAME)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;开发者需要关注的API&lt;/h1&gt;

&lt;h2&gt;可以使用的工具&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;SRC

&lt;ol&gt;
&lt;li&gt;java&lt;/li&gt;
&lt;li&gt;RenderScript&lt;/li&gt;
&lt;li&gt;Proto&lt;/li&gt;
&lt;li&gt;AIDL&lt;/li&gt;
&lt;li&gt;jni&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;TOOLS

&lt;ol&gt;
&lt;li&gt;EMMC测试覆盖工具&lt;/li&gt;
&lt;li&gt;jarjar Java包批处理工具&lt;/li&gt;
&lt;li&gt;Proguard 系统优化工具&lt;/li&gt;
&lt;li&gt;系统级优化工具(需要以ROM的形式发布): preopt/odex&lt;/li&gt;
&lt;li&gt;lint bug分析工具&lt;/li&gt;
&lt;li&gt;signature&lt;/li&gt;
&lt;li&gt;zipalign&lt;/li&gt;
&lt;li&gt;findbugs 好像已经无法使用了&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h2&gt;编译控制参数&lt;/h2&gt;

&lt;p&gt;目前我们主要关注APP相关的控制参数.&lt;/p&gt;

&lt;h3&gt;主要的API&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;LOCAL_PACKAGE_NAME&lt;/li&gt;
&lt;li&gt;LOCAL_MODULE&lt;/li&gt;
&lt;li&gt;LOCAL_IS_HOST_MODULE

&lt;ul&gt;
&lt;li&gt;default value: false&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;LOCAL_MODULE_CLASS

&lt;ul&gt;
&lt;li&gt;default value: APPS&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;LOCAL_MODULE_TAGS&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;default value: optional&lt;/li&gt;
&lt;li&gt;可以是很多参数

&lt;ul&gt;
&lt;li&gt;debug eng tests optional samples shell_ash shell_mksh&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;具体参数可能的影响

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;tests&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;``makefile&quot;&gt;  LOCAL_AAPT_FLAGS := $(LOCAL_AAPT_FLAGS) -z
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Resources&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;LOCAL_MANIFEST_FILE

&lt;ul&gt;
&lt;li&gt;default value: AndroidManifest.xml&lt;/li&gt;
&lt;li&gt;LOCAL_PATH下用于指定MANIFEST&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;FULL_MANIFEST_FILE

&lt;ul&gt;
&lt;li&gt;default value: $(LOCAL_PATH)/$(LOCAL_MANIFEST_FILE)&lt;/li&gt;
&lt;li&gt;最终指定MANIFEST_FILE的地方&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;LOCAL_ASSET_DIR

&lt;ul&gt;
&lt;li&gt;default value: $(LOCAL_PATH)/assets&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;LOCAL_RESOURCE_DIR

&lt;ul&gt;
&lt;li&gt;default value: $(LOCAL_PATH)/res

&lt;ul&gt;
&lt;li&gt;add $(package_resource_overlays)

&lt;ul&gt;
&lt;li&gt;PRODUCT_PACKAGE_OVERLAYS&lt;/li&gt;
&lt;li&gt;DEVICE_PACKAGE_OVERLAYS&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;最后的整体结构是, 按先后编译应用的资源: 优先顺序是 PRODUCT, DEVICE, LOCAL&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;LOCAL_EXPORT_PACKAGE_RESOURCES&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;EMMA

&lt;ul&gt;
&lt;li&gt;LOCAL_EMMA_INSTRUMENT

&lt;ul&gt;
&lt;li&gt;default value:

&lt;ul&gt;
&lt;li&gt;$(LOCAL_MODULE_TAGS))$(LOCAL_INSTRUMENTATION_FOR) contain tests =&gt; true&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;会根据上下文自动添加emma的模块依赖&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;LOCAL_EMMA_COVERAGE_FILTER&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;PROGUARD

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;LOCAL_PROGUARD_ENABLED&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;default value:

&lt;ul&gt;
&lt;li&gt;TARGET_BUILD_VARIANT contains user,userdebug=&gt; full&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;value:

&lt;ul&gt;
&lt;li&gt;disabled: 关闭&lt;/li&gt;
&lt;li&gt;custom

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;!=&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;``makefile&quot;&gt;  proguard_options_file := $(package_expected_intermediates_COMMON)/proguard_options
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;LOCAL_PROGUARD_FLAGS&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;用于定义PROGUARD的相关参数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;LOCAL_INSTRUMENTATION_FOR&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;LOCAL_DEX_PREOPT

&lt;ul&gt;
&lt;li&gt;default value:

&lt;ul&gt;
&lt;li&gt;WITH_DEXPREOPT==true =&gt; true&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;LOCAL_SRC_FILES

&lt;ul&gt;
&lt;li&gt;源代码文件列表&lt;/li&gt;
&lt;li&gt;.java&lt;/li&gt;
&lt;li&gt;.aidl&lt;/li&gt;
&lt;li&gt;MODULE_LICENSE*&lt;/li&gt;
&lt;li&gt;.proto&lt;/li&gt;
&lt;li&gt;.logtags&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;LOCAL_JNI_SHARED_LIBRARIES&lt;/li&gt;
&lt;li&gt;LOCAL_CERTIFICATE

&lt;ul&gt;
&lt;li&gt;签名&lt;/li&gt;
&lt;li&gt;platform 等&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;LOCAL_STATIC_JAVA_LIBRARIES

&lt;ul&gt;
&lt;li&gt;静态依赖库, 最终会与应用一起打包&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;LOCAL_JAVA_LIBRARIES

&lt;ul&gt;
&lt;li&gt;动态依赖库&lt;/li&gt;
&lt;li&gt;会根据上下文添加SDK依赖, 系统模块依赖等&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;RENDERSCRIPT

&lt;ul&gt;
&lt;li&gt;LOCAL_RENDERSCRIPT_TARGET_API&lt;/li&gt;
&lt;li&gt;LOCAL_RENDERSCRIPT_CC&lt;/li&gt;
&lt;li&gt;LOCAL_RENDERSCRIPT_FLAGS&lt;/li&gt;
&lt;li&gt;LOCAL_RENDERSCRIPT_INCLUDES&lt;/li&gt;
&lt;li&gt;LOCAL_RENDERSCRIPT_INCLUDES_OVERRIDE: 会覆盖上述变量LOCAL_RENDERSCRIPT_INCLUDES&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;HACK时使用的API&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;LOCAL_MODULE_PATH

&lt;ul&gt;
&lt;li&gt;default value: system/app&lt;/li&gt;
&lt;li&gt;安装路径&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;LOCAL_NO_STANDARD_LIBRARIES&lt;/li&gt;
&lt;li&gt;&lt;p&gt;LOCAL_UNINSTALLABLE_MODULE&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;default value: false&lt;/li&gt;
&lt;li&gt;&lt;p&gt;起作用后主要是通过如下操作完成&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;``makefile&quot;&gt;  LOCAL_INSTALLED_MODULE := $(LOCAL_MODULE_PATH)/$(LOCAL_INSTALLED_MODULE_STEM)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;LOCAL_SDK_VERSION&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;LOCAL_BUILT_MODULE_STEM&lt;/li&gt;
&lt;li&gt;LOCAL_INTERMEDIATE_TARGETS

&lt;ul&gt;
&lt;li&gt;中间编译结果, 在添加新机制时可以使用. 一般&lt;em&gt;不要定义&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;LOCAL_SOURCE_FILES_ALL_GENERATED&lt;/li&gt;
&lt;li&gt;LOCAL_PROPRIETARY_MODULE

&lt;ul&gt;
&lt;li&gt;主要影响partition_tag&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;LOCAL_MODULE_STEM

&lt;ul&gt;
&lt;li&gt;default value: LOCAL_MODULE&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;LOCAL_MODULE_SUFFIX

&lt;ul&gt;
&lt;li&gt;default value: .apk&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;LOCAL_AIDL_INCLUDES&lt;/li&gt;
&lt;li&gt;LOCAL_PROTOC_OPTIMIZE_TYPE&lt;/li&gt;
&lt;li&gt;LOCAL_JAVA_RESOURCE_DIRS&lt;/li&gt;
&lt;li&gt;LOCAL_JAR_MANIFEST&lt;/li&gt;
&lt;li&gt;LOCAL_AAPT_FLAGS&lt;/li&gt;
&lt;li&gt;findbugs.xml&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;分析后的感觉&lt;/h1&gt;

&lt;p&gt;不得不说, Makefile能够变成OO化的东西, 确实不容易.
整体编译系统中,我们可以看到Google在工程化上的强大, 将开发, 集成, 发布, 测试, 代码开源许可证等大量工程流程化的工作进行了一体化的封装与管理.&lt;/p&gt;

&lt;p&gt;后续我准备按模块地将这些OO化的东西进行学习.&lt;/p&gt;

&lt;h2&gt;具体使用中的问题&lt;/h2&gt;

&lt;h3&gt;内置工具优化与整合&lt;/h3&gt;

&lt;h4&gt;proguard&lt;/h4&gt;

&lt;p&gt;官方文档&lt;a href=&quot;http://developer.android.com/tools/help/proguard.html&quot;&gt;proguard&lt;/a&gt;&lt;/p&gt;

&lt;h4&gt;lint&lt;/h4&gt;

&lt;p&gt;官方文档&lt;a href=&quot;http://developer.android.com/tools/help/lint.html&quot;&gt;lint&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;mm lintall
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;java_library 是如何起作用的&lt;/h3&gt;

&lt;p&gt;通过变量LOCAL_JAVA_LIBRARIES:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;###################
# @ base_rules.mk
###################

# out/target/common/obj/xxx/xxx_intermediates/classes.jar
# 在编译时的依赖.class
full_java_libs := $(call java-lib-files,$(LOCAL_JAVA_LIBRARIES),$(LOCAL_IS_HOST_MODULE))

# out/target/common/obj/xxx/xxx_intermediates/javalib.jar
# 在设备上的依赖.dex
full_java_lib_deps := $(call java-lib-deps,$(LOCAL_JAVA_LIBRARIES),$(LOCAL_IS_HOST_MODULE))

PRIVATE_ALL_JAVA_LIBRARIES:= $(full_java_libs)

###################
# @ definitions.mk
###################
compile-java
    javac -classpath $(PRIVATE_ALL_JAVA_LIBRARIES)
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>心灵提醒与反馈</title>
   <link href="http://www.5wpc.info/it/living/life/2014/01/01/HeartPoint"/>
   <updated>2014-01-01T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/living/life/2014/01/01/HeartPoint</id>
   <content type="html">&lt;h1&gt;个人习惯与性格&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;自爱, 爱人&lt;/li&gt;
&lt;li&gt;不逃避, 勇面对&lt;/li&gt;
&lt;li&gt;重质量, 再数量&lt;/li&gt;
&lt;li&gt;管住自己的好奇心&lt;/li&gt;
&lt;/ol&gt;


&lt;h2&gt;Reading &amp;amp; Study&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Reading Notes

&lt;ol&gt;
&lt;li&gt;@blog 具体解释与例子&lt;/li&gt;
&lt;li&gt;@douban 简单联想与扩展&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;News

&lt;ol&gt;
&lt;li&gt;整体了解&lt;/li&gt;
&lt;li&gt;Technial

&lt;ol&gt;
&lt;li&gt;Make a Demo&lt;/li&gt;
&lt;li&gt;To blog&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h2&gt;Plan &amp;amp; Summary&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Plan @ Wiki

&lt;ol&gt;
&lt;li&gt;2 weeks&lt;/li&gt;
&lt;li&gt;1 month&lt;/li&gt;
&lt;li&gt;3 monthes&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Summary

&lt;ol&gt;
&lt;li&gt;blog to wiki&lt;/li&gt;
&lt;li&gt;After every plan &lt;em&gt;time end&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;涓滴列表&lt;/h1&gt;

&lt;h2&gt;2014&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Day

&lt;ul&gt;
&lt;li&gt;Life

&lt;ul&gt;
&lt;li&gt;Sport

&lt;ul&gt;
&lt;li&gt;Run&lt;/li&gt;
&lt;li&gt;Energy&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Music&lt;/li&gt;
&lt;li&gt;Use Time Right?

&lt;ul&gt;
&lt;li&gt;On Time&lt;/li&gt;
&lt;li&gt;Computer Time&lt;/li&gt;
&lt;li&gt;Happy Time&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Read

&lt;ul&gt;
&lt;li&gt;Technial

&lt;ul&gt;
&lt;li&gt;ATA&lt;/li&gt;
&lt;li&gt;BBS&lt;/li&gt;
&lt;li&gt;News&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Book&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Review

&lt;ul&gt;
&lt;li&gt;Blog&lt;/li&gt;
&lt;li&gt;Life&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Week

&lt;ul&gt;
&lt;li&gt;Wiki&lt;/li&gt;
&lt;li&gt;Project&lt;/li&gt;
&lt;li&gt;Interpersonal

&lt;ul&gt;
&lt;li&gt;Family&lt;/li&gt;
&lt;li&gt;Friends&lt;/li&gt;
&lt;li&gt;Work Team&lt;/li&gt;
&lt;li&gt;Technical&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Life

&lt;ul&gt;
&lt;li&gt;Movie&lt;/li&gt;
&lt;li&gt;SPA&lt;/li&gt;
&lt;li&gt;Clean house&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h2&gt;2013&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Day

&lt;ul&gt;
&lt;li&gt;Interpersonal

&lt;ul&gt;
&lt;li&gt;Family&lt;/li&gt;
&lt;li&gt;Friends&lt;/li&gt;
&lt;li&gt;Work Team&lt;/li&gt;
&lt;li&gt;Technical Team&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Sports

&lt;ul&gt;
&lt;li&gt;Run&lt;/li&gt;
&lt;li&gt;Energy&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Music&lt;/li&gt;
&lt;li&gt;Review&lt;/li&gt;
&lt;li&gt;Read

&lt;ul&gt;
&lt;li&gt;Technical&lt;/li&gt;
&lt;li&gt;Android Training&lt;/li&gt;
&lt;li&gt;News&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Week

&lt;ul&gt;
&lt;li&gt;Blog&lt;/li&gt;
&lt;li&gt;Project&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;

</content>
 </entry>
 
 <entry>
   <title>Android Build System</title>
   <link href="http://www.5wpc.info/it/technical/os/android/2013/12/15/BuildSystem"/>
   <updated>2013-12-15T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/technical/os/android/2013/12/15/BuildSystem</id>
   <content type="html">&lt;h1&gt;Android Build System&lt;/h1&gt;

&lt;h2&gt;Global Structure&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;main.mk

&lt;ul&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;help.mk&lt;/li&gt;
&lt;li&gt;make help&lt;/li&gt;
&lt;li&gt;make out&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;config.mk&lt;/li&gt;
&lt;li&gt;全局常量定义

&lt;ul&gt;
&lt;li&gt;compile

&lt;ul&gt;
&lt;li&gt;tools&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;2.1 cts/build/config.mk&lt;/li&gt;
&lt;li&gt;2.2 build/buildspec.mk&lt;/li&gt;
&lt;li&gt;2.3 envsetup.mk

&lt;ul&gt;
&lt;li&gt;2.3.1 version_defaults.mk&lt;/li&gt;
&lt;li&gt;主要是系统环境设置

&lt;ul&gt;
&lt;li&gt;arch

&lt;ul&gt;
&lt;li&gt;arm&lt;/li&gt;
&lt;li&gt;x86&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;platform

&lt;ul&gt;
&lt;li&gt;windows&lt;/li&gt;
&lt;li&gt;linux&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;output directory

&lt;ul&gt;
&lt;li&gt;out/target...&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;2.3.2 product_config.mk

&lt;ul&gt;
&lt;li&gt;2.3.2.2 product.mk

&lt;ul&gt;
&lt;li&gt;var PRODUCT_PACKAGES&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;2.3.2.3 device.mk&lt;/li&gt;
&lt;li&gt;2.3.2.4 product/AndroidProducts.mk

&lt;ul&gt;
&lt;li&gt;define PRODUCT_PACKAGES&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;cleanbuild.mk&lt;/li&gt;
&lt;li&gt;make clean&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt; definitions.mk&lt;/li&gt;
&lt;li&gt;define helper functions, vars&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt; dex_preopt.mk&lt;/li&gt;
&lt;li&gt;Dex preopt&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt; pdk_config.mk&lt;/li&gt;
&lt;li&gt;The pdk (Platform Development Kit) build&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt; ONE_SHOT_MAKEFILE&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt; post_clean.mk&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;mm&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;ONE_SHOT_MAKEFILE=$M $DRV make -C $T -f build/core/main.mk all_modules $@

&lt;ul&gt;
&lt;li&gt;注意这个命令的结构：最前面是个赋值语句(ONE_SHOT_MAKEFILE=xxx/Android.mk) 后面是一个包装make的运行调用

&lt;ul&gt;
&lt;li&gt;$DRV make -C $T -f build/core/main.mk all_modules $@ ONE_SHOT_MAKEFIKE=xxx/Android.mk&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;参数作用

&lt;ul&gt;
&lt;li&gt;$M: 相对根目录的Android.mk文件路径&lt;/li&gt;
&lt;li&gt;$DRV: 运行后面命令的封装程序

&lt;ul&gt;
&lt;li&gt;scan-build: running the analyzer from the command line&lt;/li&gt;
&lt;li&gt;一般只是简单的调用后面参数中的命令&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;-C 在Android根目录运行&lt;/li&gt;
&lt;li&gt;-f 目标makefile文件&lt;/li&gt;
&lt;li&gt;all_modules 运行目标&lt;/li&gt;
&lt;li&gt;$@ 后面的传入参数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;all_modules

&lt;ul&gt;
&lt;li&gt;define @ base_rules.mk&lt;/li&gt;
&lt;li&gt;LOCAL_MODULE&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;BUILD_PREBUILT&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;main.mk&lt;/li&gt;
&lt;li&gt;prebuilt.mk&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;tags: Make&lt;/h2&gt;
</content>
 </entry>
 
 <entry>
   <title>SystemStartup</title>
   <link href="http://www.5wpc.info/it/technical/os/android/2013/11/23/SystemStartup"/>
   <updated>2013-11-23T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/technical/os/android/2013/11/23/SystemStartup</id>
   <content type="html">&lt;h1&gt;SystemStartup&lt;/h1&gt;

&lt;h2&gt;1. 上电&lt;/h2&gt;

&lt;h2&gt;2. Chip&lt;/h2&gt;

&lt;h2&gt;3. 存储区固定区域Load&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;MBR&lt;/li&gt;
&lt;li&gt;SF/MMC/NAND Area

&lt;ul&gt;
&lt;li&gt;fastboot&lt;/li&gt;
&lt;li&gt;bootargs&lt;/li&gt;
&lt;li&gt;recovery&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;以HISI3716CV100为例

&lt;ul&gt;
&lt;li&gt;spi

&lt;ul&gt;
&lt;li&gt;fastboot&lt;/li&gt;
&lt;li&gt;bootargs&lt;/li&gt;
&lt;li&gt;recovery&lt;/li&gt;
&lt;li&gt;deviceinfo&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;nand

&lt;ul&gt;
&lt;li&gt;misc&lt;/li&gt;
&lt;li&gt;kernel&lt;/li&gt;
&lt;li&gt;system&lt;/li&gt;
&lt;li&gt;userdata&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;4. long jump to uboot&lt;/h2&gt;

&lt;h2&gt;5. uboot/fastboot&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;bootargs&lt;/li&gt;
&lt;li&gt;bootcmd

&lt;ul&gt;
&lt;li&gt;load kernel from NAND to MEMORY&lt;/li&gt;
&lt;li&gt;bootm @MEMORY&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;recoveryargs&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;6. Kernel Mode&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;System Init

&lt;ul&gt;
&lt;li&gt;Memory&lt;/li&gt;
&lt;li&gt;Device load&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Linux mode&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;7. Linux Mode&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Parse init.rc

&lt;ul&gt;
&lt;li&gt;default service&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;app_process

&lt;ul&gt;
&lt;li&gt;Android loading&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;8. Android Mode&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Zygote&lt;/li&gt;
&lt;li&gt;System_server

&lt;ul&gt;
&lt;li&gt;service ready

&lt;ul&gt;
&lt;li&gt;ActivityManager&lt;/li&gt;
&lt;li&gt;WindowManager&lt;/li&gt;
&lt;li&gt;PowerManager&lt;/li&gt;
&lt;li&gt;PackageManager&lt;/li&gt;
&lt;li&gt;InputManager&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Lauch App&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>DesignPatternsForEmbeddedSystemsInC</title>
   <link href="http://www.5wpc.info/it/technical/design/2013/09/10/DesignPatternsForEmbeddedSystemsInC"/>
   <updated>2013-09-10T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/technical/design/2013/09/10/DesignPatternsForEmbeddedSystemsInC</id>
   <content type="html">&lt;h1&gt;DesignPatternsForEmbeddedSystemsInC&lt;/h1&gt;

&lt;h2&gt;tags: Embedded&lt;/h2&gt;

&lt;h2&gt;访问硬件&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;硬件代理模式

&lt;ul&gt;
&lt;li&gt;将硬件封装到类或结构体中&lt;/li&gt;
&lt;li&gt;Proxy&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Adapter&lt;/li&gt;
&lt;li&gt;中介者模式

&lt;ul&gt;
&lt;li&gt;协调复杂的交互&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Observer

&lt;ul&gt;
&lt;li&gt;支持高效传感器数据分页&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;去抖模式

&lt;ul&gt;
&lt;li&gt;抑制间歇硬件信号&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;中断模式

&lt;ul&gt;
&lt;li&gt;处理高紧急硬件信号&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;轮询模式

&lt;ul&gt;
&lt;li&gt;定期检查新的传感器数据&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;嵌入并发和资源管理&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;循环执行模式

&lt;ul&gt;
&lt;li&gt;在无限循环内调试线程&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;静态优先级模式

&lt;ul&gt;
&lt;li&gt;通过优先级调试线程&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;临界区模式

&lt;ul&gt;
&lt;li&gt;通过禁用任务转换保护资源&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;守卫调用模式

&lt;ul&gt;
&lt;li&gt;通过互斥信号量保护资源&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;队列模式

&lt;ul&gt;
&lt;li&gt;通过消息排队序列化访问&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;汇合模式

&lt;ul&gt;
&lt;li&gt;协调复杂任务同步&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;同时锁定模式

&lt;ul&gt;
&lt;li&gt;通过同时锁定资源以避免死锁&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;排序锁定模式

&lt;ul&gt;
&lt;li&gt;通过以特定顺序锁定资源以避免死锁&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;状态机&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;单事件接收器模式

&lt;ul&gt;
&lt;li&gt;通过单个事件接收器实现状态机&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;多事件接收器模式

&lt;ul&gt;
&lt;li&gt;通过多个事件接收器实现状态机&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;状态表模式

&lt;ul&gt;
&lt;li&gt;实现表驱动的状态机&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;状态设计模式

&lt;ul&gt;
&lt;li&gt;通过创建状态对象实现状态机&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;分解与状态模式

&lt;ul&gt;
&lt;li&gt;通过分解复合状态实现与(and)状态&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;安全和可靠性模式&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;二进制反码&lt;/li&gt;
&lt;li&gt;CRC&lt;/li&gt;
&lt;li&gt;智能数据

&lt;ul&gt;
&lt;li&gt;对数据添加行为来确保满足数据的前置条件和約束&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;通道&lt;/li&gt;
&lt;li&gt;保护单通道&lt;/li&gt;
&lt;li&gt;双通道&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>VM-Group-Discuss</title>
   <link href="http://www.5wpc.info/it/technical/vm/2013/09/06/VMGroupDiscuss"/>
   <updated>2013-09-06T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/technical/vm/2013/09/06/VMGroupDiscuss</id>
   <content type="html">&lt;h1&gt;VM-Group-Discuss&lt;/h1&gt;

&lt;h2&gt;Memory&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Heap

&lt;ul&gt;
&lt;li&gt;ConstPool

&lt;ul&gt;
&lt;li&gt;StaticField

&lt;ul&gt;
&lt;li&gt;Direct reference

&lt;ul&gt;
&lt;li&gt;object&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Reflect

&lt;ul&gt;
&lt;li&gt;ClassObject&lt;/li&gt;
&lt;li&gt;java.lang.reflect.Field&lt;/li&gt;
&lt;li&gt;Other

&lt;ul&gt;
&lt;li&gt;GC&lt;/li&gt;
&lt;li&gt;Relink&lt;/li&gt;
&lt;li&gt;Reinit&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;eg: http://hllvm.group.iteye.com/group/topic/34986&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;G1@java7u4

&lt;ul&gt;
&lt;li&gt;https://oracleus.activeevents.com/connect/sessionDetail.ww?SESSION_ID=6583&lt;/li&gt;
&lt;li&gt;http://www.infoq.com/cn/articles/jdk7-garbage-first-collector

&lt;ul&gt;
&lt;li&gt;特点

&lt;ul&gt;
&lt;li&gt;并行

&lt;ul&gt;
&lt;li&gt;ScanMark run with other app threads&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;并发

&lt;ul&gt;
&lt;li&gt;Remark step run in multi threads&lt;/li&gt;
&lt;li&gt;Clean step run in multi threads&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;分代&lt;/li&gt;
&lt;li&gt;空间整合

&lt;ul&gt;
&lt;li&gt;Multi Regions&lt;/li&gt;
&lt;li&gt;Region Level Clean

&lt;ul&gt;
&lt;li&gt;Reference set loging linking from other region(write barrier)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;可以预测的停顿

&lt;ul&gt;
&lt;li&gt;Clean some regions by its needing time&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Running

&lt;ul&gt;
&lt;li&gt;&lt;img src=&quot;http://www.infoq.com/resource/articles/jdk7-garbage-first-collector/zh/resources/image1.jpg&quot; alt=&quot;Steps&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Native

&lt;ul&gt;
&lt;li&gt;NIO-directMemory

&lt;ul&gt;
&lt;li&gt;http://hllvm.group.iteye.com/group/topic/35271&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ByteBuffer.allocateDirect&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;JavaByteCode&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Class Static Scope Codes

&lt;ul&gt;
&lt;li&gt;Generate &lt;cinit&gt;{}

&lt;ul&gt;
&lt;li&gt;只能作为类加载过程的一部分由JVM直接调用&lt;/li&gt;
&lt;li&gt;http://hllvm.group.iteye.com/group/topic/35224&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;JVMDebug&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;为什么 Java 会 Crash？

&lt;ul&gt;
&lt;li&gt;http://www.linuxeden.com/html/softuse/20120506/123909.html&lt;/li&gt;
&lt;li&gt;Problems

&lt;ul&gt;
&lt;li&gt;JVM bug&lt;/li&gt;
&lt;li&gt;Native library bug&lt;/li&gt;
&lt;li&gt;Java code bug&lt;/li&gt;
&lt;li&gt;Native memory left NONE&lt;/li&gt;
&lt;li&gt;Environment effect

&lt;ul&gt;
&lt;li&gt;OOM Killer&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Crash

&lt;ul&gt;
&lt;li&gt;JVM意外消失&lt;/li&gt;
&lt;li&gt;crash log

&lt;ul&gt;
&lt;li&gt;core.pid&lt;/li&gt;
&lt;li&gt;core dump&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;tools

&lt;ul&gt;
&lt;li&gt;jstack/gdb&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>AndroidDebugger</title>
   <link href="http://www.5wpc.info/it/technical/os/android/2013/09/06/AndroidDebugger"/>
   <updated>2013-09-06T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/technical/os/android/2013/09/06/AndroidDebugger</id>
   <content type="html">&lt;h1&gt;AndroidDebugger&lt;/h1&gt;

&lt;h2&gt;Android Development Environment&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;ADT

&lt;ul&gt;
&lt;li&gt;DDMS

&lt;ul&gt;
&lt;li&gt;Profile&lt;/li&gt;
&lt;li&gt;Heap&lt;/li&gt;
&lt;li&gt;Thread&lt;/li&gt;
&lt;li&gt;UI&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;CodeDebug

&lt;ul&gt;
&lt;li&gt;App Code Level

&lt;ul&gt;
&lt;li&gt;ADT Debug&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Smali Code level

&lt;ul&gt;
&lt;li&gt;apktool

&lt;ul&gt;
&lt;li&gt;https://code.google.com/p/android-apktool/&lt;/li&gt;
&lt;li&gt;Convert smali with debug info&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ADT Debug

&lt;ul&gt;
&lt;li&gt;JDWP&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Log

&lt;ul&gt;
&lt;li&gt;logcat

&lt;ul&gt;
&lt;li&gt;radio&lt;/li&gt;
&lt;li&gt;event&lt;/li&gt;
&lt;li&gt;debug&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;dmesg&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;lint&lt;/li&gt;
&lt;li&gt;traceview&lt;/li&gt;
&lt;li&gt;dmtracedump&lt;/li&gt;
&lt;li&gt;systrace&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;Linux&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;getevent&lt;/li&gt;
&lt;li&gt;ps&lt;/li&gt;
&lt;li&gt;top&lt;/li&gt;
&lt;li&gt;procrank&lt;/li&gt;
&lt;li&gt;map&lt;/li&gt;
&lt;li&gt;smaps&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;Global Status&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;bugreport&lt;/li&gt;
&lt;li&gt;dumpsys&lt;/li&gt;
&lt;li&gt;dumpstate&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;tags: Debug&lt;/h2&gt;
</content>
 </entry>
 
 <entry>
   <title>APIChecker</title>
   <link href="http://www.5wpc.info/it/technical/os/android/2013/09/06/APIChecker"/>
   <updated>2013-09-06T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/technical/os/android/2013/09/06/APIChecker</id>
   <content type="html">&lt;h1&gt;APIChecker&lt;/h1&gt;

&lt;h2&gt;AndroidSystem&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Droidcore

&lt;ul&gt;
&lt;li&gt;checkapi&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;3rd Tools&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;tattletale&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;Module&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Dependence

&lt;ul&gt;
&lt;li&gt;By Config

&lt;ul&gt;
&lt;li&gt;LOCAL_STATIC_LIBRARY&lt;/li&gt;
&lt;li&gt;LOCAL_PACKAGE&lt;/li&gt;
&lt;li&gt;LOCAL_SHARED_LIBRARY&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;tags: SoftwareEngineering&lt;/h2&gt;
</content>
 </entry>
 
 <entry>
   <title>Android 事件处理系统</title>
   <link href="http://www.5wpc.info/it/technical/os/android/2013/05/27/InputEventSystem"/>
   <updated>2013-05-27T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/technical/os/android/2013/05/27/InputEventSystem</id>
   <content type="html">&lt;h1&gt;主要参考&lt;/h1&gt;

&lt;p&gt;http://blog.csdn.net/myarrow/article/details/7091061&lt;/p&gt;

&lt;h1&gt;Source Code view@Android 4.2&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Focus Activity

&lt;ul&gt;
&lt;li&gt;ActivityManagerService.java::setFocusedActivity&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Input System

&lt;ul&gt;
&lt;li&gt;Window Manager Service

&lt;ul&gt;
&lt;li&gt;com_android_server_KeyInputQueue.cpp::readEvent&lt;/li&gt;
&lt;li&gt;WindowMangerService.java::KeyQ&lt;/li&gt;
&lt;li&gt;KeyInputQueue.java::KeyInputQ&lt;/li&gt;
&lt;li&gt;WindowMangerService.java::InputDispatcherThread&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Client

&lt;ul&gt;
&lt;li&gt;ViewRoot.java::IWindow&lt;/li&gt;
&lt;li&gt;ViewRoot.java::ViewRoot&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;事件输入与分发&lt;/h2&gt;

&lt;h3&gt;主体结构&lt;/h3&gt;

&lt;h4&gt;事件表示与管理&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;EventHub.h

&lt;ul&gt;
&lt;li&gt;RawEvent

&lt;ul&gt;
&lt;li&gt;when&lt;/li&gt;
&lt;li&gt;deviceId&lt;/li&gt;
&lt;li&gt;type&lt;/li&gt;
&lt;li&gt;code&lt;/li&gt;
&lt;li&gt;value&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;RawAbsoluteAxisInfo&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;它是系统中所有事件的中央处理站。它管理所有系统中可以识别的输入设备的输入事件，此外，当设备增加或删除时，EventHub将产生相应的输入事件给系统。&lt;/p&gt;

&lt;p&gt;EventHub通过getEvents函数，给系统提供一个输入事件流。
它也支持查询输入设备当前的状态（如哪些键当前被按下）。
而且EventHub还跟踪每个输入调入的能力，比如输入设备的类别，输入设备支持哪些按键。&lt;/p&gt;

&lt;h4&gt;InputReader&lt;/h4&gt;

&lt;p&gt;InputReader从EventHub中读取原始事件数据(RawEvent)，并由各个InputMapper处理之后输入对应的input listener.&lt;/p&gt;

&lt;p&gt;InputReader拥有一个InputMapper集合。
它做的大部分工作在InputReader线程中完成，但是InputReader可以接受任意线程的查询。
为了可管理性，InputReader使用一个简单的Mutex来保护它的状态。&lt;/p&gt;

&lt;p&gt;InputReader拥有一个EventHub对象，但这个对象不是它创建的，而是在创建InputReader时作为参数传入的。&lt;/p&gt;

&lt;h4&gt;InputDispatcher&lt;/h4&gt;

&lt;p&gt;InputDispatcher负责把事件分发给输入目标，其中的一些功能（如识别输入目标）由独立的policy对象控制。&lt;/p&gt;

&lt;h4&gt;InputManager&lt;/h4&gt;

&lt;p&gt;InputManager是系统事件处理的核心，它虽然不做具体的事，但管理工作还是要做的，比如接受我们客户的投诉和索赔要求，或者老板的出所筒。&lt;/p&gt;

&lt;p&gt;InputManager使用两个线程：
1. InputReaderThread叫做&quot;InputReader&quot;线程，它负责读取并预处理RawEvent，applies policy并且把消息送入DispatcherThead管理的队列中。
1. InputDispatcherThread叫做&quot;InputDispatcher&quot;线程，它在队列上等待新的输入事件，并且异步地把这些事件分发给应用程序。&lt;/p&gt;

&lt;p&gt;InputReaderThread类与InputDispatcherThread类不共享内部状态，所有的通信都是单向的，从InputReaderThread到InputDispatcherThread。两个类可以通过InputDispatchPolicy进行交互。&lt;/p&gt;

&lt;p&gt;InputManager类从不与Java交互，而InputDispatchPolicy负责执行所有与系统的外部交互，包括调用DVM业务。&lt;/p&gt;

&lt;h3&gt;创建与启动流程&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;com_android_server_input_InputManagerService.cpp::nativeInit

&lt;ol&gt;
&lt;li&gt;获取一个messageQueue&lt;/li&gt;
&lt;li&gt;im &amp;lt;- new NativeInputManager

&lt;ol&gt;
&lt;li&gt;mInputManage &amp;lt;- new InputManager(new EventHub())

&lt;ol&gt;
&lt;li&gt;mDispatcher &amp;lt;- new InputDispatcher(dispatcherPolicy);&lt;/li&gt;
&lt;li&gt;mReader &amp;lt;- new InputReader(eventHub, readerPolicy, mDispatcher);&lt;/li&gt;
&lt;li&gt;mReaderThread &amp;lt;- new InputReaderThread(mReader);&lt;/li&gt;
&lt;li&gt;mDispatcherThread &amp;lt;- new InputDispatcherThread(mDispatcher);&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;com_android_server_input_InputManagerService.cpp::nativeStart

&lt;ol&gt;
&lt;li&gt;mReader-&gt;loopOnce (InputReader.cpp)&lt;/li&gt;
&lt;li&gt;mDispatcher -&gt; dispatchOnce (InputDispatcher.cpp)&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;SystemServer

&lt;ol&gt;
&lt;li&gt;Create InputManager&lt;/li&gt;
&lt;li&gt;WindowManagerService.main 创建一个WindowManagerService对象，作为inputManager的回调&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h2&gt;事件反馈&lt;/h2&gt;

&lt;p&gt;由InputDispatcher进行事件的分发处理:
    * mDispatcher
        * dispatchOnce
            * dispatchOnceInnerLocked
                * Check EventType
                    1. TYPE_CONFIGURATION_CHANGED: dispatchConfigurationChangedLocked
                    1. TYPE_DEVICE_RESET: dispatchDeviceResetLocked
                    1. TYPE_KEY: dispatchKeyLocked
                    1. TYPE_MOTION: dispatchMotionLocked
                        * findFocusedWindowTargetsLocked
                        * dispatchEventLocked
                            * prepareDispatchCycleLocked
                                * enqueueDispatchEntriesLocked
                                    * startDispatchCycleLocked
                                        * connection-&gt;inputPublisher.publishMotionEvent
                                            * mChannel -&gt; sendMessage()
            * poll
                * pollInter
                    * handler -&gt; handleMessage(message)&lt;/p&gt;

&lt;h3&gt;InputManagerService::handleMessage&lt;/h3&gt;

&lt;p&gt;InputManagerHandler::handleMessage&lt;/p&gt;

&lt;h3&gt;WindowManagerService::handleMessage&lt;/h3&gt;

&lt;h3&gt;ViewRootImpl::ViewRootHandler::handleMessage&lt;/h3&gt;

&lt;p&gt;case MSG_PROCESS_INPUT_EVENTS:
    * doProcessInputEvents
        * deliverInputEvent
            * deliverPointerEvent
                * mView.dispatchPointerEvent
                    * dispatchTouchEvent
                        * onTouchEvent&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>死亡之旅笔记</title>
   <link href="http://www.5wpc.info/it/technical/softwareengineering/2013/05/21/DeathMarch"/>
   <updated>2013-05-21T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/technical/softwareengineering/2013/05/21/DeathMarch</id>
   <content type="html">&lt;h1&gt;第1章 绪论&lt;/h1&gt;

&lt;h2&gt;1.1 死亡之旅的定义&lt;/h2&gt;

&lt;h2&gt;1.2 死亡之旅项目的分类&lt;/h2&gt;

&lt;h2&gt;1.3 为何会出现死亡之旅项目&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;政治，政治，还是政治&lt;/li&gt;
&lt;li&gt;市场人员、高级管理人员、缺乏经验的项目经理等人所做出的幼稚承诺&lt;/li&gt;
&lt;li&gt;年轻人天真的乐观主义：“我们周末能完成它！”&lt;/li&gt;
&lt;li&gt;新公司的创业心理&lt;/li&gt;
&lt;li&gt;海军陆战队精神：真正的程序员无需睡眠&lt;/li&gt;
&lt;li&gt;市场全球化所导致的残酷竞争&lt;/li&gt;
&lt;li&gt;由于出现新技术而引发的激烈竞争&lt;/li&gt;
&lt;li&gt;不可预期的政府法令所导致的巨大压力&lt;/li&gt;
&lt;li&gt;出乎意料和/或未经计划的危机&lt;/li&gt;
&lt;/ol&gt;


&lt;h2&gt;1.4 人们为什么参加死亡之旅项目&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;虽然风险很高，但回报也很高&lt;/li&gt;
&lt;li&gt;珠峰综合征&lt;/li&gt;
&lt;li&gt;年轻人的天真和乐观&lt;/li&gt;
&lt;li&gt;不做就要失业&lt;/li&gt;
&lt;li&gt;未来获得提升的必要条件&lt;/li&gt;
&lt;li&gt;不做就要面临破产或其他不幸&lt;/li&gt;
&lt;li&gt;一个突破旧条条框框的机会&lt;/li&gt;
&lt;li&gt;报复&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;第2章 政治&lt;/h1&gt;

&lt;h2&gt;2.1 确定项目所涉及的政治&quot;玩家&quot;&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;业主&lt;/li&gt;
&lt;li&gt;用户&lt;/li&gt;
&lt;li&gt;持股人&lt;/li&gt;
&lt;li&gt;干系人&lt;/li&gt;
&lt;li&gt;支持者&lt;/li&gt;
&lt;/ol&gt;


&lt;h2&gt;2.2 确定项目的基本类型&lt;/h2&gt;

&lt;h2&gt;2.3 项目参与者的承诺程度&lt;/h2&gt;

&lt;h2&gt;2.4 导致政治争执的关键问题&lt;/h2&gt;

&lt;h1&gt;第3章 谈判&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;理智的谈判&lt;/li&gt;
&lt;li&gt;识别可接受的折中&lt;/li&gt;
&lt;li&gt;谈判游戏&lt;/li&gt;
&lt;li&gt;谈判策略&lt;/li&gt;
&lt;li&gt;谈判失败后应该做什么&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;第4章 死亡之旅项目中的人员&lt;/h1&gt;

&lt;h2&gt;4.1 雇用和人员配备问题&lt;/h2&gt;

&lt;h2&gt;4.2 忠诚、承诺、激励和奖赏&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;奖励项目团队成员&lt;/li&gt;
&lt;li&gt;加班问题&lt;/li&gt;
&lt;/ol&gt;


&lt;h2&gt;4.3 沟通的重要性&lt;/h2&gt;

&lt;h2&gt;4.4 团队建设问题&lt;/h2&gt;

&lt;h2&gt;4.5 死亡之旅项目的工作场所条件&lt;/h2&gt;

&lt;h1&gt;第5章 死亡之旅的过程&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;分类概念&lt;/li&gt;
&lt;li&gt;需求管理的重要性&lt;/li&gt;
&lt;li&gt;sei、iso—9000、形式化过程与非形式化过程&lt;/li&gt;
&lt;li&gt;&quot;足够好&quot;的软件&lt;/li&gt;
&lt;li&gt;最佳实践和最差实践&lt;/li&gt;
&lt;li&gt;当死亡之旅遭遇xp&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;第6章 动态的过程&lt;/h1&gt;

&lt;h2&gt;6.1 软件开发过程模型&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;思维模型&lt;/li&gt;
&lt;li&gt;电子表格模型&lt;/li&gt;
&lt;li&gt;静态模型与动态模型&lt;/li&gt;
&lt;/ol&gt;


&lt;h2&gt;6.2 可视化模型&lt;/h2&gt;

&lt;h1&gt;第7章 关键链进度排定和约束理论&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;介绍&lt;/li&gt;
&lt;li&gt;什么样的组织行为是紊乱的&lt;/li&gt;
&lt;li&gt;如何才能改变紊乱的组织行为&lt;/li&gt;
&lt;li&gt;理智世界中的行为&lt;/li&gt;
&lt;li&gt;关键链进度排定&lt;/li&gt;
&lt;li&gt;小结&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;第8章 时间管理&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;企业文化对时间管理的影响&lt;/li&gt;
&lt;li&gt;股东争执所浪费的时间&lt;/li&gt;
&lt;li&gt;帮助项目团队更好地利用时间&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;第9章 管理和控制项目进展&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;&quot;天做&quot;概念:CI&lt;/li&gt;
&lt;li&gt;风险管理&lt;/li&gt;
&lt;li&gt;对进展监控的额外建议：里程碑评审&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;第10章 工具和技术&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;最小工具集&lt;/li&gt;
&lt;li&gt;工具和过程&lt;/li&gt;
&lt;li&gt;选择新工具的风险&lt;/li&gt;
&lt;/ol&gt;

</content>
 </entry>
 
 <entry>
   <title>C语言发生问题产生log并crash dump</title>
   <link href="http://www.5wpc.info/it/technical/language/c/2013/05/04/SigCatchAndDump"/>
   <updated>2013-05-04T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/technical/language/c/2013/05/04/SigCatchAndDump</id>
   <content type="html">&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;/* This is the crash handler.
 * Does a best effort at logging and calls _exit to terminate
 * the process immediately (without atexit handlers, etc.) */
void __stack_chk_fail(void)
{
    struct sigaction sa;
    sigset_t sigmask;
    static const char message[] = &quot;stack corruption detected: aborted&quot;;
    char path[PATH_MAX];
    int count;

    /* Immediately block all (but SIGABRT) signal handlers from running code */
    sigfillset(&amp;amp;sigmask);
    sigdelset(&amp;amp;sigmask, SIGABRT);
    sigprocmask(SIG_BLOCK, &amp;amp;sigmask, NULL);

    /* temporary, so deliver SIGSEGV can be caught by debuggerd */
    sigemptyset(&amp;amp;sigmask);
    sigaddset(&amp;amp;sigmask, SIGSEGV);
    sigprocmask(SIG_UNBLOCK, &amp;amp;sigmask, NULL);

    /* Use /proc/self/exe link to obtain the program name for logging
     * purposes. If it&#39;s not available, we set it to &quot;&amp;lt;unknown&amp;gt;&quot; */
    if ((count = readlink(&quot;/proc/self/exe&quot;, path, sizeof(path) - 1)) == -1) {
        strlcpy(path, &quot;&amp;lt;unknown&amp;gt;&quot;, sizeof(path));
    } else {
        path[count] = &#39;\0&#39;;
    }

    /* Do a best effort at logging. This ends up calling writev(2) */
    __libc_android_log_print(ANDROID_LOG_FATAL, path, message);

    /* Make sure there is no default action for SIGABRT */
    bzero(&amp;amp;sa, sizeof(struct sigaction));
    sigemptyset(&amp;amp;sa.sa_mask);
    sa.sa_flags = 0;
    sa.sa_handler = SIG_DFL;
    sigaction(SIGABRT, &amp;amp;sa, NULL);

    /* temporary, so stack overflow case can be caught */
    *((long*)0xdead2aed) = 0xaed;
    /* Terminate the process and exit immediately */
    kill(getpid(), SIGABRT);

    _exit(127);
}
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>HowToDebug</title>
   <link href="http://www.5wpc.info/it/technical/debug/2013/04/21/HowToDebug"/>
   <updated>2013-04-21T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/technical/debug/2013/04/21/HowToDebug</id>
   <content type="html">&lt;h1&gt;HowToDebug&lt;/h1&gt;

&lt;h2&gt;tags: Method&lt;/h2&gt;

&lt;h2&gt;问题的核心&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;山重水复疑无路(One Main Method)

&lt;ul&gt;
&lt;li&gt;调试不仅是排除缺陷

&lt;ul&gt;
&lt;li&gt;Steps

&lt;ul&gt;
&lt;li&gt;弄清楚软件为什么会运行有问题&lt;/li&gt;
&lt;li&gt;修复问题&lt;/li&gt;
&lt;li&gt;避免破坏其他部分&lt;/li&gt;
&lt;li&gt;保持或者提高代码的总体质量

&lt;ul&gt;
&lt;li&gt;可读性&lt;/li&gt;
&lt;li&gt;架构&lt;/li&gt;
&lt;li&gt;测试覆盖比率&lt;/li&gt;
&lt;li&gt;性能&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;确保同样的问题不会在其他地方发生，也不会再次发生&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Important

&lt;ul&gt;
&lt;li&gt;查明问题的根本原因&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;实证方法

&lt;ul&gt;
&lt;li&gt;构建实验，观察結果&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;核心调试过程

&lt;ul&gt;
&lt;li&gt;问题重现

&lt;ul&gt;
&lt;li&gt;找一个可靠并简洁的方式来按需求重现问题&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;问题诊断

&lt;ul&gt;
&lt;li&gt;提出假设，并通过实验来测试它们，直到找出引起缺陷的潜在原因&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;缺陷修复

&lt;ul&gt;
&lt;li&gt;设计和进行一些修改来修复问题，不要引入回归问题，保持和提高软件的整体质量&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;反思

&lt;ul&gt;
&lt;li&gt;吸取教训

&lt;ul&gt;
&lt;li&gt;哪里出了问题&lt;/li&gt;
&lt;li&gt;是否还有其他类似问题&lt;/li&gt;
&lt;li&gt;如何才能确保同样的问题不再发生&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;调试是一个反复的过程&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Before you debug

&lt;ul&gt;
&lt;li&gt;需要明白的问题

&lt;ul&gt;
&lt;li&gt;需要知道要找的是什么

&lt;ul&gt;
&lt;li&gt;发生了什么，应该发生什么&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;一次一个问题&lt;/li&gt;
&lt;li&gt;先检查简单的事情&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;HowToDo

&lt;ul&gt;
&lt;li&gt;一定需要做到

&lt;ul&gt;
&lt;li&gt;找到软件运行异常的原因&lt;/li&gt;
&lt;li&gt;修复问题&lt;/li&gt;
&lt;li&gt;避免破坏其他程序&lt;/li&gt;
&lt;li&gt;保持或提高软件的整体质量&lt;/li&gt;
&lt;li&gt;确保不在其他地方发生同样的问题，确保这种问题不重复发生&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;利用软件自身来告诉你发生了什么&lt;/li&gt;
&lt;li&gt;每次解决一个问题&lt;/li&gt;
&lt;li&gt;确保你知道自己要找的是什么

&lt;ul&gt;
&lt;li&gt;正在发生什么&lt;/li&gt;
&lt;li&gt;应该发生什么&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;重现问题&lt;/li&gt;
&lt;li&gt;重现第一，提问第二

&lt;ul&gt;
&lt;li&gt;明确开始要做的事&lt;/li&gt;
&lt;li&gt;抓住重点

&lt;ul&gt;
&lt;li&gt;软件本身&lt;/li&gt;
&lt;li&gt;软件的运行环境&lt;/li&gt;
&lt;li&gt;提供的输入&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;控制软件

&lt;ul&gt;
&lt;li&gt;自动化构建&lt;/li&gt;
&lt;li&gt;版本正确&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;控制环境

&lt;ul&gt;
&lt;li&gt;影响软件运行的各种要素&lt;/li&gt;
&lt;li&gt;Tools

&lt;ul&gt;
&lt;li&gt;硬件抽象&lt;/li&gt;
&lt;li&gt;虚拟机&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;控制输入

&lt;ul&gt;
&lt;li&gt;推測可能的输入

&lt;ul&gt;
&lt;li&gt;回溯工作&lt;/li&gt;
&lt;li&gt;探测可能的输入

&lt;ul&gt;
&lt;li&gt;边界值分析&lt;/li&gt;
&lt;li&gt;分支覆盖&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;利用错误的条件&lt;/li&gt;
&lt;li&gt;引入随机性

&lt;ul&gt;
&lt;li&gt;生成模糊器&lt;/li&gt;
&lt;li&gt;变异模糊器&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;记录输入值

&lt;ul&gt;
&lt;li&gt;Log&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;负载与压力

&lt;ul&gt;
&lt;li&gt;Log&lt;/li&gt;
&lt;li&gt;负载测试工具&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;改进问题的重现

&lt;ul&gt;
&lt;li&gt;最小化反馈周期

&lt;ul&gt;
&lt;li&gt;目标：快速地运行大量的实验&lt;/li&gt;
&lt;li&gt;尽可能简单&lt;/li&gt;
&lt;li&gt;最大限度地减小所需的时间&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;将不确定的缺陷变为确定的

&lt;ul&gt;
&lt;li&gt;开始于不可知的初始状态

&lt;ul&gt;
&lt;li&gt;AllocTool&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;与外部系统进行交互

&lt;ul&gt;
&lt;li&gt;精确控制从外部系统接收了什么

&lt;ul&gt;
&lt;li&gt;Log&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;故意使用随机性

&lt;ul&gt;
&lt;li&gt;Log&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;多线程&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;自动化

&lt;ul&gt;
&lt;li&gt;Test&lt;/li&gt;
&lt;li&gt;Log&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;迭代

&lt;ul&gt;
&lt;li&gt;改进重现&lt;/li&gt;
&lt;li&gt;&lt;img src=&quot;http://pic.yupoo.com/qianjigui/CNPWDYCM/medish.jpg&quot; alt=&quot;http://pic.yupoo.com/qianjigui/CNPWDYCM/medish.jpg&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;如果真的不能重现问题该怎么办

&lt;ul&gt;
&lt;li&gt;缺陷真的存在吗

&lt;ul&gt;
&lt;li&gt;与提出问题的成员交流&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;在相同的区域解决不同的问题&lt;/li&gt;
&lt;li&gt;让其他人参与其中&lt;/li&gt;
&lt;li&gt;充分利用用户群体&lt;/li&gt;
&lt;li&gt;推测法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;HowToDo

&lt;ul&gt;
&lt;li&gt;在做任何事情前找到问题重现的方法&lt;/li&gt;
&lt;li&gt;确认你运行的版本和提出缺陷的版本是相同的&lt;/li&gt;
&lt;li&gt;复制报告缺陷时使用的环境&lt;/li&gt;
&lt;li&gt;确定重现缺陷需要的输入数据

&lt;ul&gt;
&lt;li&gt;推測数据&lt;/li&gt;
&lt;li&gt;log&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;通过反复优化确保你重现问题的程序既方便又可靠

&lt;ul&gt;
&lt;li&gt;减少运行步骤、数据量或需要的时间&lt;/li&gt;
&lt;li&gt;去除不确定性&lt;/li&gt;
&lt;li&gt;自动化&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;诊断&lt;/li&gt;
&lt;li&gt;不要急于动手——试试科学的方法

&lt;ul&gt;
&lt;li&gt;兼顾创造性与严密性&lt;/li&gt;
&lt;li&gt;不同类型的实验

&lt;ul&gt;
&lt;li&gt;检查软件内部状态的某个方面

&lt;ul&gt;
&lt;li&gt;Run&lt;/li&gt;
&lt;li&gt;Run by debug&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;改变软件运行的某个方式

&lt;ul&gt;
&lt;li&gt;IO&lt;/li&gt;
&lt;li&gt;Arguments&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;改变软件本身编码的逻辑&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;实验必须起到验证的作用&lt;/li&gt;
&lt;li&gt;每次只做一个修改&lt;/li&gt;
&lt;li&gt;记录所做的调试

&lt;ul&gt;
&lt;li&gt;定期回顾已经尝试的实验和学到的东西&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;不要忽略任何细节&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;相关策略

&lt;ul&gt;
&lt;li&gt;插桩

&lt;ul&gt;
&lt;li&gt;log&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;分而治之&lt;/li&gt;
&lt;li&gt;利用源代码控制工具&lt;/li&gt;
&lt;li&gt;聚焦差异&lt;/li&gt;
&lt;li&gt;向他人学习&lt;/li&gt;
&lt;li&gt;奥卡姆的剃刀

&lt;ul&gt;
&lt;li&gt;其它条件相同的情况下，最简单的解释是最好的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;调试器&lt;/li&gt;
&lt;li&gt;陷阱

&lt;ul&gt;
&lt;li&gt;你做的修改是正确的吗&lt;/li&gt;
&lt;li&gt;验证假设&lt;/li&gt;
&lt;li&gt;多重原因&lt;/li&gt;
&lt;li&gt;流沙

&lt;ul&gt;
&lt;li&gt;面对一个不断变化的系统，停下手头工作并弄清楚是什么在变化，为什么变化&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;思维游戏

&lt;ul&gt;
&lt;li&gt;旁观调试法

&lt;ul&gt;
&lt;li&gt;解释问题会帮助你理清思路&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;角色扮演&lt;/li&gt;
&lt;li&gt;换换脑筋

&lt;ul&gt;
&lt;li&gt;让潜意识帮助你&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;做些改变，什么改变都行&lt;/li&gt;
&lt;li&gt;福尔摩斯原则

&lt;ul&gt;
&lt;li&gt;当你排除了一切不可能后，无论结论是什么，它也一定是真相&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;坚持&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;验证诊断

&lt;ul&gt;
&lt;li&gt;向其他人解释你的诊断。&lt;/li&gt;
&lt;li&gt;检查源代码的原始副本&lt;/li&gt;
&lt;li&gt;用其它方式验证你的诊断&lt;/li&gt;
&lt;li&gt;多和他人讨论&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;HowToDo

&lt;ul&gt;
&lt;li&gt;构建假设，并用实验来测试它们

&lt;ul&gt;
&lt;li&gt;确保自己明白你的实验要说明什么&lt;/li&gt;
&lt;li&gt;每次只做一个修改&lt;/li&gt;
&lt;li&gt;把你尝试的工作记录下来&lt;/li&gt;
&lt;li&gt;不要忽略任何事物&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;当事情并不顺利的时候

&lt;ul&gt;
&lt;li&gt;如果你做的修改似乎没有产生效果，那么你没有改到点子上&lt;/li&gt;
&lt;li&gt;验证你的假设&lt;/li&gt;
&lt;li&gt;你是否面临多个有内存联系的原因或一个不断变化的基本系统&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;验证你的诊断&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;修复缺陷&lt;/li&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;清除障碍&lt;/li&gt;
&lt;li&gt;从一个干净的代码树开始&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;测试&lt;/li&gt;
&lt;li&gt;首先确保所有的测试都是通过的&lt;/li&gt;
&lt;li&gt;在设计你的修复前，确保你已经知道如何进行测试了&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;修复问题产生的原因，而非修复现&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;重构&lt;/li&gt;
&lt;li&gt;修改与重构不要同时进行&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;签入&lt;/li&gt;
&lt;li&gt;一次逻辑修改只做一次签入&lt;/li&gt;
&lt;li&gt;在checkin前进行比较&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;审查代码&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;HowToDo

&lt;ul&gt;
&lt;li&gt;缺陷修复的目标

&lt;ul&gt;
&lt;li&gt;修复问题&lt;/li&gt;
&lt;li&gt;避免引入回归&lt;/li&gt;
&lt;li&gt;维持或提高代码的整体质量&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;从一个干净的源代码树开始&lt;/li&gt;
&lt;li&gt;确保通过测试后再做修改&lt;/li&gt;
&lt;li&gt;明确在做出更改前如何进行测试&lt;/li&gt;
&lt;li&gt;针对缺陷的原因而不是现象进行修复&lt;/li&gt;
&lt;li&gt;要做重构，但不要与功能修改同时进行&lt;/li&gt;
&lt;li&gt;一次逻辑修改只做一次签入&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;反思&lt;/li&gt;
&lt;li&gt;这到底是怎么搞的&lt;/li&gt;
&lt;li&gt;哪里出了问题

&lt;ul&gt;
&lt;li&gt;我们已经做到了吗&lt;/li&gt;
&lt;li&gt;根本原因分析

&lt;ul&gt;
&lt;li&gt;原因归属

&lt;ul&gt;
&lt;li&gt;需求&lt;/li&gt;
&lt;li&gt;架构和设计&lt;/li&gt;
&lt;li&gt;测试&lt;/li&gt;
&lt;li&gt;构造

&lt;ul&gt;
&lt;li&gt;Code&lt;/li&gt;
&lt;li&gt;library使用&lt;/li&gt;
&lt;li&gt;工具使用

&lt;ul&gt;
&lt;li&gt;IDE&lt;/li&gt;
&lt;li&gt;Compiler&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;它不会再发生了

&lt;ul&gt;
&lt;li&gt;自动验证&lt;/li&gt;
&lt;li&gt;重构&lt;/li&gt;
&lt;li&gt;过程&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;关闭循环

&lt;ul&gt;
&lt;li&gt;反馈问题&lt;/li&gt;
&lt;li&gt;记录备案&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;HowToDo

&lt;ul&gt;
&lt;li&gt;花时间进行根本原因分析

&lt;ul&gt;
&lt;li&gt;在过程的哪个点上产生了错误&lt;/li&gt;
&lt;li&gt;出什么错了&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;确保同样的问题不会再发生

&lt;ul&gt;
&lt;li&gt;自动检查是否存在问题&lt;/li&gt;
&lt;li&gt;重构代码以避免不当使用&lt;/li&gt;
&lt;li&gt;和同事交谈，适当修改进程&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;多方反馈，与其他利益相关者形成闭环&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;从大局看调试&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;发现代码存在问题

&lt;ul&gt;
&lt;li&gt;追踪缺陷

&lt;ul&gt;
&lt;li&gt;缺陷追踪系统&lt;/li&gt;
&lt;li&gt;怎样才能写出一份出色的缺陷报告

&lt;ul&gt;
&lt;li&gt;具体、明确、详细&lt;/li&gt;
&lt;li&gt;最小化的、唯一的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;环境和配置报告

&lt;ul&gt;
&lt;li&gt;AutoGain&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;与用户合作

&lt;ul&gt;
&lt;li&gt;简化流程

&lt;ul&gt;
&lt;li&gt;明确说明如何报告一个流程&lt;/li&gt;
&lt;li&gt;自动化&lt;/li&gt;
&lt;li&gt;提供多种选择

&lt;ul&gt;
&lt;li&gt;Email&lt;/li&gt;
&lt;li&gt;Talk&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;要尽量简单&lt;/li&gt;
&lt;li&gt;模板不要太死板&lt;/li&gt;
&lt;li&gt;尊重用户的隐私&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;有效的沟通

&lt;ul&gt;
&lt;li&gt;心智模式

&lt;ul&gt;
&lt;li&gt;从用户的角度去沟通&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;和非技术人员沟通&lt;/li&gt;
&lt;li&gt;发布你的缺陷数据库&lt;/li&gt;
&lt;li&gt;提供反馈&lt;/li&gt;
&lt;li&gt;与用户交流&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;与支持人员协同工作&lt;/li&gt;
&lt;li&gt;HowToDo

&lt;ul&gt;
&lt;li&gt;充分利用缺陷跟踪系统

&lt;ul&gt;
&lt;li&gt;复杂度要适中，根据具体情况作出选择&lt;/li&gt;
&lt;li&gt;直接面向用户&lt;/li&gt;
&lt;li&gt;自动化环境和配置报告，以确保报告的准确性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;缺陷报告要达到如下目标

&lt;ul&gt;
&lt;li&gt;具体的&lt;/li&gt;
&lt;li&gt;明确的&lt;/li&gt;
&lt;li&gt;详细的&lt;/li&gt;
&lt;li&gt;最小化的&lt;/li&gt;
&lt;li&gt;独特的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;与用户合作时

&lt;ul&gt;
&lt;li&gt;尽可能地简化缺陷报告流程&lt;/li&gt;
&lt;li&gt;沟通是关键，多为用户着想&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;与客户支持和QA团队搞好关系，以便在缺陷修复的过程中得到帮助&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;务实的零容忍策略

&lt;ul&gt;
&lt;li&gt;缺陷优先

&lt;ul&gt;
&lt;li&gt;早期缺陷修复可以大大降低软件运行的不确定性&lt;/li&gt;
&lt;li&gt;没有破窗户&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;调试的思维模式

&lt;ul&gt;
&lt;li&gt;需要完美也要实用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;自己来解决质量问题

&lt;ul&gt;
&lt;li&gt;这里没有“灵丹妙药”&lt;/li&gt;
&lt;li&gt;停止开发那些有缺陷的程序

&lt;ul&gt;
&lt;li&gt;SCM&lt;/li&gt;
&lt;li&gt;AutoBuild&lt;/li&gt;
&lt;li&gt;AutoTest&lt;/li&gt;
&lt;li&gt;CI&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;从“不干净”的代码中将“干净”的代码分离出来

&lt;ul&gt;
&lt;li&gt;Refactor&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;错误分类

&lt;ul&gt;
&lt;li&gt;错误分级&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;缺陷闪电战&lt;/li&gt;
&lt;li&gt;专项小组&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;HowToDo

&lt;ul&gt;
&lt;li&gt;尽早地检测缺陷，在它们刚刚出现的时候进行修复&lt;/li&gt;
&lt;li&gt;把实现无缺陷的软件当成是可以实现的目标，依此而行动，但是在要求完美的同时也要实用&lt;/li&gt;
&lt;li&gt;如果你面对的是一个很差的代码库，你需要

&lt;ul&gt;
&lt;li&gt;认识到没有灵丹妙药&lt;/li&gt;
&lt;li&gt;确保基本的要素已就绪&lt;/li&gt;
&lt;li&gt;从“不干净”的代码中将“干净”的代码分离出来，并保持干净&lt;/li&gt;
&lt;li&gt;使用缺陷分类，以确保你对缺陷数据库的控制&lt;/li&gt;
&lt;li&gt;通过添加测试和进行代码重构来一步一步优化质量低下的代码&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;深入调试技术&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;特殊案例

&lt;ul&gt;
&lt;li&gt;修补已经发布的软件

&lt;ul&gt;
&lt;li&gt;需要集中精力减少风险&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;向后兼容

&lt;ul&gt;
&lt;li&gt;确定你的代码有问题&lt;/li&gt;
&lt;li&gt;解决兼容性问题

&lt;ul&gt;
&lt;li&gt;提供迁移方法&lt;/li&gt;
&lt;li&gt;实现一个兼容模式&lt;/li&gt;
&lt;li&gt;提供预警&lt;/li&gt;
&lt;li&gt;不修复缺陷&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;并发

&lt;ul&gt;
&lt;li&gt;简单与控制&lt;/li&gt;
&lt;li&gt;修复并发缺陷&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;海森堡缺陷

&lt;ul&gt;
&lt;li&gt;一个当你开始寻找的时候就会&quot;消失&quot;的缺陷&lt;/li&gt;
&lt;li&gt;减少信息收集对系统的影响&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;性能缺陷

&lt;ul&gt;
&lt;li&gt;寻找瓶颈

&lt;ul&gt;
&lt;li&gt;Profile&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;准确的性能分析

&lt;ul&gt;
&lt;li&gt;版本一致&lt;/li&gt;
&lt;li&gt;运行环境一致&lt;/li&gt;
&lt;li&gt;测试数据具有典型性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;嵌入式软件

&lt;ul&gt;
&lt;li&gt;嵌入式调试工具

&lt;ul&gt;
&lt;li&gt;仿真&lt;/li&gt;
&lt;li&gt;远程调试&lt;/li&gt;
&lt;li&gt;开发硬件&lt;/li&gt;
&lt;li&gt;ICE&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;提取信息的痛苦路程&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;第三方软件的缺陷

&lt;ul&gt;
&lt;li&gt;不要太快去指责

&lt;ul&gt;
&lt;li&gt;首先怀疑自己的代码&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;处理第三方代码的缺陷&lt;/li&gt;
&lt;li&gt;开源代码&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;HowToDo

&lt;ul&gt;
&lt;li&gt;在修补已经发布的软件的时候，要集中精力减少风险&lt;/li&gt;
&lt;li&gt;在修复缺陷的过程中不断监测兼容性问题&lt;/li&gt;
&lt;li&gt;确保你已经完全关闭计时窗口，而不仅仅是缩小尺寸&lt;/li&gt;
&lt;li&gt;当遇到海森堡缺陷时，尽量降低收集信息的副作用&lt;/li&gt;
&lt;li&gt;修复性能缺陷往往始于准确的特征描述&lt;/li&gt;
&lt;li&gt;即使是最有限的沟通渠道，也足以提取你所需要的信息了&lt;/li&gt;
&lt;li&gt;面对第三方代码，先怀疑自己的代码&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;理想的调试环境

&lt;ul&gt;
&lt;li&gt;自动化测试

&lt;ul&gt;
&lt;li&gt;有效的自动化测试

&lt;ul&gt;
&lt;li&gt;明确说明测试結果通过与否&lt;/li&gt;
&lt;li&gt;独立&lt;/li&gt;
&lt;li&gt;运行简单&lt;/li&gt;
&lt;li&gt;全面覆盖&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;自动化测试可以作为调试的辅助&lt;/li&gt;
&lt;li&gt;模拟测试、桩测试以及其他的代替测试技术&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;源程序控制

&lt;ul&gt;
&lt;li&gt;稳定性&lt;/li&gt;
&lt;li&gt;可维护性&lt;/li&gt;
&lt;li&gt;与分支相关的问题&lt;/li&gt;
&lt;li&gt;控制分支&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;自动构建

&lt;ul&gt;
&lt;li&gt;一键构建&lt;/li&gt;
&lt;li&gt;构建机器&lt;/li&gt;
&lt;li&gt;持续集成&lt;/li&gt;
&lt;li&gt;创建版本

&lt;ul&gt;
&lt;li&gt;不同的源代码，不同的版本号&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;静态分析&lt;/li&gt;
&lt;li&gt;使用静态分析&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;HowToDo

&lt;ul&gt;
&lt;li&gt;自动化你的测试

&lt;ul&gt;
&lt;li&gt;明确说明测试結果通过与否&lt;/li&gt;
&lt;li&gt;独立&lt;/li&gt;
&lt;li&gt;运行简单&lt;/li&gt;
&lt;li&gt;全面覆盖&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;在源代码控制中，谨慎地使用分支&lt;/li&gt;
&lt;li&gt;自动化你的构建过程

&lt;ul&gt;
&lt;li&gt;每当软件变化时，都进行构建和测试&lt;/li&gt;
&lt;li&gt;在每次构建中都集成静态分析&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;让软件学会自己寻找缺陷

&lt;ul&gt;
&lt;li&gt;假设和断言

&lt;ul&gt;
&lt;li&gt;一个例子&lt;/li&gt;
&lt;li&gt;等一下——刚才发生了什么&lt;/li&gt;
&lt;li&gt;例子，第二幕&lt;/li&gt;
&lt;li&gt;契约，先决条件，后置条件和不变量&lt;/li&gt;
&lt;li&gt;开启或关闭断言&lt;/li&gt;
&lt;li&gt;防错性程序设计&lt;/li&gt;
&lt;li&gt;断言滥用

&lt;ul&gt;
&lt;li&gt;断言不是一个错误处理机制&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;调试版本

&lt;ul&gt;
&lt;li&gt;编译器选项

&lt;ul&gt;
&lt;li&gt;优化

&lt;ul&gt;
&lt;li&gt;-O3&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;调试信息

&lt;ul&gt;
&lt;li&gt;-g&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;边界检查&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;调试子系统

&lt;ul&gt;
&lt;li&gt;GUI&lt;/li&gt;
&lt;li&gt;MemoryAlloc&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;内置控制

&lt;ul&gt;
&lt;li&gt;禁用相关功能&lt;/li&gt;
&lt;li&gt;提供其他实现&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;资源泄漏和异常处理

&lt;ul&gt;
&lt;li&gt;在测试中自动抛出异常&lt;/li&gt;
&lt;li&gt;一个例子&lt;/li&gt;
&lt;li&gt;测试框架&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;HowToDo

&lt;ul&gt;
&lt;li&gt;使用断言做

&lt;ul&gt;
&lt;li&gt;记录和自动验证假设&lt;/li&gt;
&lt;li&gt;在产品发布的时候需有鲁棒性，在调试期間要确保软件是脆弱的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;创建这样一个调试版本

&lt;ul&gt;
&lt;li&gt;以调试友好的方式进行编译&lt;/li&gt;
&lt;li&gt;允许关键子系统被等价的调试代码取代&lt;/li&gt;
&lt;li&gt;内嵌在诊断阶段非常有用的可控性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;在问题出现前检测系统问题，例如资源泄漏和异常处理问题&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;反模式

&lt;ul&gt;
&lt;li&gt;夸大优先级&lt;/li&gt;
&lt;li&gt;超级巨星&lt;/li&gt;
&lt;li&gt;维护团队&lt;/li&gt;
&lt;li&gt;救火模式&lt;/li&gt;
&lt;li&gt;重写&lt;/li&gt;
&lt;li&gt;没有代码所有权&lt;/li&gt;
&lt;li&gt;魔法&lt;/li&gt;
&lt;li&gt;HowToDo

&lt;ul&gt;
&lt;li&gt;控制缺陷数据库，确保它准确地反映了缺陷的优先级&lt;/li&gt;
&lt;li&gt;自负自责，任何人在完成当前任务前都不允许转向其他任务。如果在他们的工作中出现了缺陷，让他们自己来修复&lt;/li&gt;
&lt;li&gt;从最初的构思到最終布署的整个过程以及以后的维护都要一个团队完成&lt;/li&gt;
&lt;li&gt;救火模式永远不会修复质量问题。花些时间找出并修复根本原因&lt;/li&gt;
&lt;li&gt;避免彻头彻尾重写&lt;/li&gt;
&lt;li&gt;确保你的代码策略是清晰的&lt;/li&gt;
&lt;li&gt;将不理解的任何事物都当作缺陷&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;资源&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;SCM

&lt;ul&gt;
&lt;li&gt;CVS&lt;/li&gt;
&lt;li&gt;svn&lt;/li&gt;
&lt;li&gt;git&lt;/li&gt;
&lt;li&gt;mercurial&lt;/li&gt;
&lt;li&gt;bazaar&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;BugTracker

&lt;ul&gt;
&lt;li&gt;bugzilla&lt;/li&gt;
&lt;li&gt;Trac&lt;/li&gt;
&lt;li&gt;Redmine&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Code

&lt;ul&gt;
&lt;li&gt;sourceforge&lt;/li&gt;
&lt;li&gt;github&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Build

&lt;ul&gt;
&lt;li&gt;Make&lt;/li&gt;
&lt;li&gt;autoconf&lt;/li&gt;
&lt;li&gt;Jam&lt;/li&gt;
&lt;li&gt;Boost.Build&lt;/li&gt;
&lt;li&gt;SCons&lt;/li&gt;
&lt;li&gt;Ant&lt;/li&gt;
&lt;li&gt;Maven&lt;/li&gt;
&lt;li&gt;Capistrano&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;CI

&lt;ul&gt;
&lt;li&gt;CruiseControl&lt;/li&gt;
&lt;li&gt;Hudson&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Libraries

&lt;ul&gt;
&lt;li&gt;Test

&lt;ul&gt;
&lt;li&gt;JUnit&lt;/li&gt;
&lt;li&gt;TestNG&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Memory Allocator

&lt;ul&gt;
&lt;li&gt;libcwd&lt;/li&gt;
&lt;li&gt;VC&lt;/li&gt;
&lt;li&gt;Mudflap&lt;/li&gt;
&lt;li&gt;Dinkumware&lt;/li&gt;
&lt;li&gt;ElectricFence&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Log

&lt;ul&gt;
&lt;li&gt;log4j&lt;/li&gt;
&lt;li&gt;Logback&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Tools

&lt;ul&gt;
&lt;li&gt;Test

&lt;ul&gt;
&lt;li&gt;FitNesse&lt;/li&gt;
&lt;li&gt;Watir&lt;/li&gt;
&lt;li&gt;Selenium&lt;/li&gt;
&lt;li&gt;Sahi&lt;/li&gt;
&lt;li&gt;The Grinder&lt;/li&gt;
&lt;li&gt;JMeter&lt;/li&gt;
&lt;li&gt;QuickTest Professional LoadRunner&lt;/li&gt;
&lt;li&gt;Peach Fuzzing Platform&lt;/li&gt;
&lt;li&gt;RFuzz&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Running Analysis

&lt;ul&gt;
&lt;li&gt;Valgrind

&lt;ul&gt;
&lt;li&gt;Memory&lt;/li&gt;
&lt;li&gt;Performance Profile&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;BoundsChecker

&lt;ul&gt;
&lt;li&gt;Memory&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Purify

&lt;ul&gt;
&lt;li&gt;Memory&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;DTrace&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Network

&lt;ul&gt;
&lt;li&gt;TCPDUMP&lt;/li&gt;
&lt;li&gt;Wireshark&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Debug Proxy

&lt;ul&gt;
&lt;li&gt;Charies&lt;/li&gt;
&lt;li&gt;Fiddler&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Debug

&lt;ul&gt;
&lt;li&gt;gdb&lt;/li&gt;
&lt;li&gt;firebug&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>持续集成(CI)</title>
   <link href="http://www.5wpc.info/it/technical/continuousintegration/2013/04/14/ContinuousIntegration"/>
   <updated>2013-04-14T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/technical/continuousintegration/2013/04/14/ContinuousIntegration</id>
   <content type="html">&lt;h1&gt;持续集成(CI)&lt;/h1&gt;

&lt;h2&gt;工具与资源&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;CI工具/产品资源

&lt;ul&gt;
&lt;li&gt;AnthillPro; Apache Continuum; Bamboo; BuildForge; Continuous Integration Server Matrix; CruiseControl; CruiseControl.NET; Draco.NET; Gauntlet; Luntbuild;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;构建脚本

&lt;ul&gt;
&lt;li&gt;Ant&lt;/li&gt;
&lt;li&gt;Make&lt;/li&gt;
&lt;li&gt;Groovy&lt;/li&gt;
&lt;li&gt;Maven&lt;/li&gt;
&lt;li&gt;Rake&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;版本控制

&lt;ul&gt;
&lt;li&gt;ClearCase&lt;/li&gt;
&lt;li&gt;CVS&lt;/li&gt;
&lt;li&gt;Git&lt;/li&gt;
&lt;li&gt;svn&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;数据库

&lt;ul&gt;
&lt;li&gt;MySQL&lt;/li&gt;
&lt;li&gt;SQlite&lt;/li&gt;
&lt;li&gt;Postgre SQL&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;测试

&lt;ul&gt;
&lt;li&gt;Agitator&lt;/li&gt;
&lt;li&gt;DbUnit&lt;/li&gt;
&lt;li&gt;Fit&lt;/li&gt;
&lt;li&gt;xUnit&lt;/li&gt;
&lt;li&gt;Agitator; DbUnit; Fit; FitNesse; Floyd; HtmlUnit; JUnit; JWebUnit; NDbUnit; NUnit; Selenium; SQLUnit; TestEarly.com; TestNG; utPLSQL; Watir; xUnit Test Patterns&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;AutoCheck

&lt;ul&gt;
&lt;li&gt;Checkstyle; Clover; Cobertura; EMMA; FindBugs; FxCop; JavaNCSS; JDepend; NCover;NDepend; PMD; Simian; SourceMonitor.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;部署

&lt;ul&gt;
&lt;li&gt;Capistrano&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;反馈

&lt;ul&gt;
&lt;li&gt;Ambient Devices; Google Talk; Jabber; X10; Lava Lamps&lt;/li&gt;
&lt;li&gt;Bug&lt;/li&gt;
&lt;li&gt;User response&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;文档

&lt;ul&gt;
&lt;li&gt;Doxygen; Javadoc; NDoc&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;评估工具&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;构建

&lt;ul&gt;
&lt;li&gt;基本功能

&lt;ul&gt;
&lt;li&gt;代码编译&lt;/li&gt;
&lt;li&gt;组件打包&lt;/li&gt;
&lt;li&gt;程序执行&lt;/li&gt;
&lt;li&gt;文件操作&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;扩展功能

&lt;ul&gt;
&lt;li&gt;执行开发者测试&lt;/li&gt;
&lt;li&gt;版本控制工具集成&lt;/li&gt;
&lt;li&gt;文件集成&lt;/li&gt;
&lt;li&gt;部署功能&lt;/li&gt;
&lt;li&gt;代码品质分析&lt;/li&gt;
&lt;li&gt;可扩展性&lt;/li&gt;
&lt;li&gt;多平台构建&lt;/li&gt;
&lt;li&gt;加速构建&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;构建计划安排工具

&lt;ul&gt;
&lt;li&gt;基本功能

&lt;ul&gt;
&lt;li&gt;构建执行&lt;/li&gt;
&lt;li&gt;版本控制集成&lt;/li&gt;
&lt;li&gt;构建工具集成&lt;/li&gt;
&lt;li&gt;反馈&lt;/li&gt;
&lt;li&gt;为构建打上标签&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;扩展功能

&lt;ul&gt;
&lt;li&gt;项目间依赖关系&lt;/li&gt;
&lt;li&gt;用户界面&lt;/li&gt;
&lt;li&gt;制品发布&lt;/li&gt;
&lt;li&gt;安全&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;工具与软件开发过程的其他要素集成的程度

&lt;ul&gt;
&lt;li&gt;该工具是否支持您目前的构建配置？&lt;/li&gt;
&lt;li&gt;该工具是否需要安装其他软件才能运行？&lt;/li&gt;
&lt;li&gt;该工具是否与您的项目使用同一种语言编写？&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;可靠性：工具的成熟度。&lt;/li&gt;
&lt;li&gt;寿命：考虑工具的将来，要在健康的用户群和开发团队中寻找证据。&lt;/li&gt;
&lt;li&gt;易用性：工具配置和使用起来越容易，它就越好。&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;tags:Tool&lt;/h2&gt;
</content>
 </entry>
 
 <entry>
   <title>SystemServer</title>
   <link href="http://www.5wpc.info/it/technical/os/android/2013/03/31/SystemServer"/>
   <updated>2013-03-31T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/technical/os/android/2013/03/31/SystemServer</id>
   <content type="html">&lt;h1&gt;SystemServer&lt;/h1&gt;

&lt;h2&gt;PackageManagerService&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;http://blog.sina.com.cn/s/blog_3e3fcadd01014678.html

&lt;ul&gt;
&lt;li&gt;PackageManger&lt;/li&gt;
&lt;li&gt;Permission&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Main Tasks

&lt;ul&gt;
&lt;li&gt;建立installer与installd的socket连接&lt;/li&gt;
&lt;li&gt;建立PackageHandler消息循环: 用于处理外部的apk安装等请求&lt;/li&gt;
&lt;li&gt;解析/system/etc/permissionsetc/permissions/&quot;（一般就是/system/etc/permissions）下的各个.xml文件中读取系统的基本permissions，而且文件platform.xml在最后读，表明其优先级最高

&lt;ul&gt;
&lt;li&gt;Android的基本permission、Linux gid(s)、以及它们的对应关系 -- mSettings.mPermissions， mGlobalGids&lt;/li&gt;
&lt;li&gt;为Android permission指定的Linux uid   --  mSystemPermissions&lt;/li&gt;
&lt;li&gt;为Android所增加的应用需要链接的java库的名称和全路径  --  mSharedLibraries&lt;/li&gt;
&lt;li&gt;系统所支持的各种硬件模块的feature(未见具体实例，据代码可知，这只是一个名字) -- mAvailableFeatures&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;解析/data/system/packages.xml文件&lt;/li&gt;
&lt;li&gt;对jar进行dexopt优化&lt;/li&gt;
&lt;li&gt;通过ScanDirLI()扫描并解析当前已存在的apk&lt;/li&gt;
&lt;li&gt;将解析/安装的.apk信息保存到/data/system/packages.xml和/data/system/packages.lst文件以备查询&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;HowToStart&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;RuntimeInit.zygoteInit

&lt;ul&gt;
&lt;li&gt;调用 com.android.server.SystemServer类的main函数

&lt;ul&gt;
&lt;li&gt;init1

&lt;ul&gt;
&lt;li&gt;system_init(System_init.cpp)

&lt;ul&gt;
&lt;li&gt;Start Surface Flinger&lt;/li&gt;
&lt;li&gt;Start Sensor Service&lt;/li&gt;
&lt;li&gt;com/android/server/SystemServer::init2

&lt;ul&gt;
&lt;li&gt;Thread thr = new ServerThread();&lt;/li&gt;
&lt;li&gt;thr.start&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ProcessState::self()-&gt;startThreadPool();&lt;/li&gt;
&lt;li&gt;IPCThreadState::self()-&gt;joinThreadPool();&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;thr.start

&lt;ul&gt;
&lt;li&gt;ServerThread::run

&lt;ul&gt;
&lt;li&gt;Start Services

&lt;ul&gt;
&lt;li&gt;Watchdog

&lt;ul&gt;
&lt;li&gt;battery&lt;/li&gt;
&lt;li&gt;power&lt;/li&gt;
&lt;li&gt;alarm&lt;/li&gt;
&lt;li&gt;activity&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Input Manager

&lt;ul&gt;
&lt;li&gt;start&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;windowmanager

&lt;ul&gt;
&lt;li&gt;main&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ready

&lt;ul&gt;
&lt;li&gt;wm

&lt;ul&gt;
&lt;li&gt;displayReady&lt;/li&gt;
&lt;li&gt;systemReady&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;Debug&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Crash

&lt;ul&gt;
&lt;li&gt;System server fault

&lt;ul&gt;
&lt;li&gt;Zygote会重新启动SystemServer&lt;/li&gt;
&lt;li&gt;主要原因

&lt;ul&gt;
&lt;li&gt;Watchdog

&lt;ul&gt;
&lt;li&gt;killed a system_server process because of deadlock in of services it&#39;s running&lt;/li&gt;
&lt;li&gt;In rare cases watchdog can be timed out because of high memory and CPU usage.&lt;/li&gt;
&lt;li&gt;存在形式

&lt;ul&gt;
&lt;li&gt;system_process thread

&lt;ul&gt;
&lt;li&gt;watchdog

&lt;ul&gt;
&lt;li&gt;com.android.server.Watchdog.run&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Fatal exception occured in one of system services

&lt;ul&gt;
&lt;li&gt;a hardware issue&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Kernel panic

&lt;ul&gt;
&lt;li&gt;Device reboot&lt;/li&gt;
&lt;li&gt;dmesg&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>ThinkingInJavaFromVM</title>
   <link href="http://www.5wpc.info/it/technical/language/java/2013/03/24/ThinkingInJavaFromVM"/>
   <updated>2013-03-24T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/technical/language/java/2013/03/24/ThinkingInJavaFromVM</id>
   <content type="html">&lt;h1&gt;ThinkingInJavaFromVM&lt;/h1&gt;

&lt;h2&gt;tags: VM&lt;/h2&gt;

&lt;h2&gt;创建和销毁对象&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;考虑用静态工厂方法代替构造器

&lt;ul&gt;
&lt;li&gt;命名与创建更有意义&lt;/li&gt;
&lt;li&gt;工厂模式

&lt;ul&gt;
&lt;li&gt;Meaning&lt;/li&gt;
&lt;li&gt;集中管理&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Constructor

&lt;ul&gt;
&lt;li&gt;javac

&lt;ul&gt;
&lt;li&gt;&lt;init&gt;&lt;/li&gt;
&lt;li&gt;&lt;cinit&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;VM

&lt;ul&gt;
&lt;li&gt;类信息布局与管理

&lt;ul&gt;
&lt;li&gt;Structure

&lt;ul&gt;
&lt;li&gt;Methods&lt;/li&gt;
&lt;li&gt;Fields&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;LinearAlloc

&lt;ul&gt;
&lt;li&gt;For native&lt;/li&gt;
&lt;li&gt;Methods&lt;/li&gt;
&lt;li&gt;Fields&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ClassObject In Heap

&lt;ul&gt;
&lt;li&gt;reference to LinearAlloc data&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;遇到多个构造器参数时要考虑用构建器

&lt;ul&gt;
&lt;li&gt;不要简单通过参数进行控制&lt;/li&gt;
&lt;li&gt;工厂&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;用私有构造器或者枚举类型强化Singleton属性

&lt;ul&gt;
&lt;li&gt;保证单一性&lt;/li&gt;
&lt;li&gt;单例模式

&lt;ul&gt;
&lt;li&gt;sync&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;VM

&lt;ul&gt;
&lt;li&gt;访问控制&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;通过私有构造器强化不可实例化的能力

&lt;ul&gt;
&lt;li&gt;VM

&lt;ul&gt;
&lt;li&gt;访问控制&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;避免创建不必要的对象

&lt;ul&gt;
&lt;li&gt;内存与单一性

&lt;ul&gt;
&lt;li&gt;for ==&lt;/li&gt;
&lt;li&gt;Not equals&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;API

&lt;ul&gt;
&lt;li&gt;String.intern&lt;/li&gt;
&lt;li&gt;工厂模式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;消除过期的对象引用

&lt;ul&gt;
&lt;li&gt;static field&lt;/li&gt;
&lt;li&gt;GC&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;避免使用终结方法

&lt;ul&gt;
&lt;li&gt;finalize的调用不可预期&lt;/li&gt;
&lt;li&gt;Dalvik

&lt;ul&gt;
&lt;li&gt;libcore reference support

&lt;ul&gt;
&lt;li&gt;Reference Class

&lt;ul&gt;
&lt;li&gt;VM internal field

&lt;ul&gt;
&lt;li&gt;queueNext

&lt;ul&gt;
&lt;li&gt;相关类型对象的单链表用于记录&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;pendingNext

&lt;ul&gt;
&lt;li&gt;进行处理的表&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;MarkSteps

&lt;ul&gt;
&lt;li&gt;Check Prevserve SoftReference

&lt;ul&gt;
&lt;li&gt;Mark SoftReference Objects&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;clearWhiteReference

&lt;ul&gt;
&lt;li&gt;softReference&lt;/li&gt;
&lt;li&gt;weakReference&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;enqueueFinalizerReferences

&lt;ul&gt;
&lt;li&gt;Enqueues finalizer references with white referents&lt;/li&gt;
&lt;li&gt;White referents are blackened, moved to the zombie field&lt;/li&gt;
&lt;li&gt;the referent field is cleared&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;clearWhiteReference

&lt;ul&gt;
&lt;li&gt;softReference&lt;/li&gt;
&lt;li&gt;weakReference&lt;/li&gt;
&lt;li&gt;phantomReferences&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;Thinking Pattern&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Tip

&lt;ul&gt;
&lt;li&gt;Project&lt;/li&gt;
&lt;li&gt;Design Patterns&lt;/li&gt;
&lt;li&gt;VM&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;对于所有对象都通用的方法&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;覆盖equals时请遵守通用约定

&lt;ul&gt;
&lt;li&gt;if(x!=NULL) x==x true&lt;/li&gt;
&lt;li&gt;x and y are not NULL, x==y if and only if y==x&lt;/li&gt;
&lt;li&gt;x,y,z NOT NULL, x==y y==z =&gt; x==z&lt;/li&gt;
&lt;li&gt;if(x!=NULL) x==NULL return false&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;覆盖equals时总要覆盖hashCode

&lt;ul&gt;
&lt;li&gt;Dalvik

&lt;ul&gt;
&lt;li&gt;MarkSweep GC

&lt;ul&gt;
&lt;li&gt;Object hashcode==object addr&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Copying GC

&lt;ul&gt;
&lt;li&gt;Object hashcode is saved in the object&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;始终要覆盖toString

&lt;ul&gt;
&lt;li&gt;For Debug&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;谨慎地覆盖clone&lt;/li&gt;
&lt;li&gt;考虑实现Comparable接口&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;类和接口&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;使类和成员的可访问性最小化&lt;/li&gt;
&lt;li&gt;在公有类中使用访问方法而非公有域

&lt;ul&gt;
&lt;li&gt;Getter and Setter&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;使可变性最小化

&lt;ul&gt;
&lt;li&gt;Clone argument in constructor&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;复合优先于继承&lt;/li&gt;
&lt;li&gt;要么为继承而设计，并提供文档说明，要么就禁止继承&lt;/li&gt;
&lt;li&gt;接口优于抽象类&lt;/li&gt;
&lt;li&gt;接口只用于定义类型&lt;/li&gt;
&lt;li&gt;类层次优于标签类&lt;/li&gt;
&lt;li&gt;用函数对象表示策略&lt;/li&gt;
&lt;li&gt;优先考虑静态成员类&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;方法&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;检查参数的有效性

&lt;ul&gt;
&lt;li&gt;assert&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;必要时进行保护性拷贝

&lt;ul&gt;
&lt;li&gt;For construcor with object argument&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;谨慎设计方法签名&lt;/li&gt;
&lt;li&gt;慎用重载&lt;/li&gt;
&lt;li&gt;慎用可变参数&lt;/li&gt;
&lt;li&gt;返回零长度的数组或者集合，而不是：null&lt;/li&gt;
&lt;li&gt;为所有导出的API元素编写文档注释&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;通用程序设计&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;将局部变量的作用域最小化

&lt;ul&gt;
&lt;li&gt;Dalvik dex

&lt;ul&gt;
&lt;li&gt;Share stack Vars

&lt;ul&gt;
&lt;li&gt;by javac&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;for-each循环优先于传统的for循环

&lt;ul&gt;
&lt;li&gt;by javac&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;了解和使用类库

&lt;ul&gt;
&lt;li&gt;java.lang.*&lt;/li&gt;
&lt;li&gt;java.util.*&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;如果需要精确的答案，请避免使用float和double

&lt;ul&gt;
&lt;li&gt;BigDecimal&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;基本类型优先于装箱基本类型

&lt;ul&gt;
&lt;li&gt;final field for value&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;如果其他类型更适合，则尽量避免使用字符串&lt;/li&gt;
&lt;li&gt;当心字符串连接的性能

&lt;ul&gt;
&lt;li&gt;StringBuffer&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;通过接口引用对象&lt;/li&gt;
&lt;li&gt;接口优先于反射机制

&lt;ul&gt;
&lt;li&gt;Dalvik

&lt;ul&gt;
&lt;li&gt;Reflect

&lt;ul&gt;
&lt;li&gt;By JNI&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;谨慎地使用本地方法

&lt;ul&gt;
&lt;li&gt;JNI

&lt;ul&gt;
&lt;li&gt;Dalvik

&lt;ul&gt;
&lt;li&gt;Native stack is managed by coder

&lt;ul&gt;
&lt;li&gt;Local Reference&lt;/li&gt;
&lt;li&gt;Global Reference&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;谨慎地进行优化

&lt;ul&gt;
&lt;li&gt;By profile&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;遵守普遍接受的命名惯例&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;异常&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;只针对异常的情况才使用异常

&lt;ul&gt;
&lt;li&gt;空间局部性

&lt;ul&gt;
&lt;li&gt;Dalvik

&lt;ul&gt;
&lt;li&gt;Try-Catch

&lt;ul&gt;
&lt;li&gt;Check Have exception&lt;/li&gt;
&lt;li&gt;Find Catch area

&lt;ul&gt;
&lt;li&gt;Jump in Stacks&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Run&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;对可恢复的情况使用受检异常，对编程错误使用运行时异常&lt;/li&gt;
&lt;li&gt;避免不必要地使用受检的异常&lt;/li&gt;
&lt;li&gt;优先使用标准的异常&lt;/li&gt;
&lt;li&gt;抛出与抽象相对应的异常&lt;/li&gt;
&lt;li&gt;每个方法抛出的异常都要有文档&lt;/li&gt;
&lt;li&gt;在细节消息中包含能捕获失败的信息&lt;/li&gt;
&lt;li&gt;努力使失败保持原子性&lt;/li&gt;
&lt;li&gt;不要忽略异常&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>AndroidOSMemory分析</title>
   <link href="http://www.5wpc.info/it/technical/os/android/2013/03/24/MemoryAnalysis"/>
   <updated>2013-03-24T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/technical/os/android/2013/03/24/MemoryAnalysis</id>
   <content type="html">&lt;h1&gt;AndroidOSMemory分析&lt;/h1&gt;

&lt;h2&gt;内存使用分析&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;DDMS

&lt;ul&gt;
&lt;li&gt;Heap

&lt;ul&gt;
&lt;li&gt;Hprof

&lt;ul&gt;
&lt;li&gt;MAT

&lt;ul&gt;
&lt;li&gt;OQL

&lt;ul&gt;
&lt;li&gt;http://qianjigui.iteye.com/blog/1706898&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;http://qianjigui.iteye.com/blog/1706773&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Heap Info&lt;/li&gt;
&lt;li&gt;Alloc Tracker&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Linux Tools

&lt;ul&gt;
&lt;li&gt;procrank&lt;/li&gt;
&lt;li&gt;ps&lt;/li&gt;
&lt;li&gt;smaps

&lt;ul&gt;
&lt;li&gt;http://qianjigui.iteye.com/blog/1479109&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;meminfo&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Native Malloc

&lt;ul&gt;
&lt;li&gt;Malloc-Debugger&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;OS Strategy&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Android OOM Strategy

&lt;ul&gt;
&lt;li&gt;OOM Killer

&lt;ul&gt;
&lt;li&gt;Six Levels

&lt;ul&gt;
&lt;li&gt;FOREGROUND_APP — The application you are currently using&lt;/li&gt;
&lt;li&gt;VISIBLE_APP — An application that is visible but not in the foreground&lt;/li&gt;
&lt;li&gt;SECONDAY_SERVER — A process providing services&lt;/li&gt;
&lt;li&gt;HIDDEN_APP — A process that is hidden, but may be needed by a running program&lt;/li&gt;
&lt;li&gt;CONTENT_PROVIDER — Apps that provide data to the system (for example, synchronizing with the Market)&lt;/li&gt;
&lt;li&gt;EMPTY_APP — An application you were using, but is not currently active&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Strategy

&lt;ul&gt;
&lt;li&gt;http://blog.csdn.net/wuhengde/article/details/8104029&lt;/li&gt;
&lt;li&gt;ProcessList.java&lt;/li&gt;
&lt;li&gt;ActivityManagerServer.java&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;CopyOnWrite

&lt;ul&gt;
&lt;li&gt;Zygote fork

&lt;ul&gt;
&lt;li&gt;Preload

&lt;ul&gt;
&lt;li&gt;classes&lt;/li&gt;
&lt;li&gt;Resources&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;IPC

&lt;ul&gt;
&lt;li&gt;Binder&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;App Strategy&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;对象的组合

&lt;ul&gt;
&lt;li&gt;生命周期

&lt;ul&gt;
&lt;li&gt;相近的最好一起申请&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;设计

&lt;ul&gt;
&lt;li&gt;早清空

&lt;ul&gt;
&lt;li&gt;static&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;finalize少使用&lt;/li&gt;
&lt;li&gt;SoftReference

&lt;ul&gt;
&lt;li&gt;处理资源

&lt;ul&gt;
&lt;li&gt;image&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;String.intern&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;整体结构

&lt;ul&gt;
&lt;li&gt;模块化，可分批load&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;API

&lt;ul&gt;
&lt;li&gt;Preload&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;tags: GC Memory&lt;/h2&gt;

&lt;h2&gt;系统级内存分析的一般方法&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;系统级

&lt;ul&gt;
&lt;li&gt;meminfo&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;程序级

&lt;ul&gt;
&lt;li&gt;procrank&lt;/li&gt;
&lt;li&gt;ps&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;程序内部级

&lt;ul&gt;
&lt;li&gt;smaps&lt;/li&gt;
&lt;li&gt;Java_heap

&lt;ul&gt;
&lt;li&gt;DDMS&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Native Heap

&lt;ul&gt;
&lt;li&gt;Malloc Debugger&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;StrictMode

&lt;ul&gt;
&lt;li&gt;http://www.androidlearner.net/use-strictmode.html&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>SP8与我的生活</title>
   <link href="http://www.5wpc.info/it/living/interest/2013/03/06/bike"/>
   <updated>2013-03-06T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/living/interest/2013/03/06/bike</id>
   <content type="html">&lt;h1&gt;SP8&lt;/h1&gt;

&lt;h2&gt;装备调整&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;自行车刹车调整超详细图解
** http://danche.xout.cn/sdc/45428.html&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>SmallMemorySoftwarePatternsForSystemWithLimitedMemory</title>
   <link href="http://www.5wpc.info/it/technical/design/memory/2013/02/23/SmallMemorySoftwarePatternsForSystemWithLimitedMemory"/>
   <updated>2013-02-23T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/technical/design/memory/2013/02/23/SmallMemorySoftwarePatternsForSystemWithLimitedMemory</id>
   <content type="html">&lt;h1&gt;SmallMemorySoftwarePatternsForSystemWithLimitedMemory&lt;/h1&gt;

&lt;h2&gt;tags: System Memory GC&lt;/h2&gt;

&lt;h2&gt;SmallArchitecture(小容量体系结构)&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Problem

&lt;ul&gt;
&lt;li&gt;Questions

&lt;ul&gt;
&lt;li&gt;如何管理整个系统使用的内存&lt;/li&gt;
&lt;li&gt;Environment

&lt;ul&gt;
&lt;li&gt;肉眼数据如果受到限制，会束缚整个系统&lt;/li&gt;
&lt;li&gt;组件的内存需求量会动态改变&lt;/li&gt;
&lt;li&gt;各个组件可由开发团队完成&lt;/li&gt;
&lt;li&gt;系统由多个组件构成&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Way

&lt;ul&gt;
&lt;li&gt;让每个组件管理自己的内存运用状态&lt;/li&gt;
&lt;li&gt;Idea

&lt;ul&gt;
&lt;li&gt;明确组件内存规格、作为一个标准&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Consequences(結果)

&lt;ul&gt;
&lt;li&gt;可以降低程序的内存需求&lt;/li&gt;
&lt;li&gt;提高程序的内存用量可预测性&lt;/li&gt;
&lt;li&gt;Maybe 使程序的伸缩性更好、可用性更强&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;But

&lt;ul&gt;
&lt;li&gt;需要程序员更高的素养&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Implementation(实现)

&lt;ul&gt;
&lt;li&gt;Methods

&lt;ul&gt;
&lt;li&gt;理念

&lt;ul&gt;
&lt;li&gt;一致性&lt;/li&gt;
&lt;li&gt;责任&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;将系统分解为独立的组件，开发时可以一块一块的设计、构造系统；借助统一的内存策略，开发时可以确保发展出来的各部分能够高效率的协同工作&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;关键

&lt;ul&gt;
&lt;li&gt;可剪裁性(Tailorability)

&lt;ul&gt;
&lt;li&gt;Different context, Different memory using&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;让客户负责管理组件的内存分配

&lt;ul&gt;
&lt;li&gt;Programming

&lt;ul&gt;
&lt;li&gt;利用Callbacks管理内存&lt;/li&gt;
&lt;li&gt;利用统一接口进行内存使用的封装(Memory Strategy)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Specialzation Patterns (特化模式)

&lt;ul&gt;
&lt;li&gt;Memory Limit(内存限额)

&lt;ul&gt;
&lt;li&gt;Question

&lt;ul&gt;
&lt;li&gt;如何在多个相互竞争的组件间分配内存&lt;/li&gt;
&lt;li&gt;Environemnt

&lt;ul&gt;
&lt;li&gt;系统中包含多个组件，每个组件有各自的内存需求&lt;/li&gt;
&lt;li&gt;组件的内存需求随着系统的运行而动态变化&lt;/li&gt;
&lt;li&gt;一个组件使用内存过多会影响到其他组件&lt;/li&gt;
&lt;li&gt;你可以为每个任务设置一个合理的内存上限&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Way

&lt;ul&gt;
&lt;li&gt;为每个组件设置限额，对于超出限额的分配請求，应予以拒绝&lt;/li&gt;
&lt;li&gt;Steps

&lt;ul&gt;
&lt;li&gt;记录当前每个组件分配的内存数量&lt;/li&gt;
&lt;li&gt;确保组件分配的内存数量不超过分配限额&lt;/li&gt;
&lt;li&gt;理想状态下应当通过“试验、检视内存用量”的方式为每个组件设定限额&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Implementation

&lt;ul&gt;
&lt;li&gt;在内存管理操作前后注入&lt;/li&gt;
&lt;li&gt;各组件管理各自的heap&lt;/li&gt;
&lt;li&gt;分享进程&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Small Interfaces

&lt;ul&gt;
&lt;li&gt;Question

&lt;ul&gt;
&lt;li&gt;如何减少组件接口带来的内存额外开销&lt;/li&gt;
&lt;li&gt;Environment

&lt;ul&gt;
&lt;li&gt;各个组件管理各自的内存&lt;/li&gt;
&lt;li&gt;组件间通过显式的接口相互通信&lt;/li&gt;
&lt;li&gt;组件间通信需要额外内存&lt;/li&gt;
&lt;li&gt;可复用接口需要泛化接口&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Way

&lt;ul&gt;
&lt;li&gt;设计出让客户可以控制数据传输的接口&lt;/li&gt;
&lt;li&gt;Steps

&lt;ul&gt;
&lt;li&gt;将接口间的数据传输量最小化&lt;/li&gt;
&lt;li&gt;决定数据传输的质量程度&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Implementation

&lt;ul&gt;
&lt;li&gt;传值vs传地址&lt;/li&gt;
&lt;li&gt;注意组件间交換内存

&lt;ul&gt;
&lt;li&gt;策略

&lt;ul&gt;
&lt;li&gt;出借

&lt;ul&gt;
&lt;li&gt;客户调用“提供服务的组件”期間，由客户出借一些内存给服务提供者&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;借入

&lt;ul&gt;
&lt;li&gt;客户获得服务供应者拥有对象的访问权&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;窃取

&lt;ul&gt;
&lt;li&gt;客户接收服务供应者分配的对象，并负责归还该对象&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;步进式接口

&lt;ul&gt;
&lt;li&gt;客户进行多次调用&lt;/li&gt;
&lt;li&gt;通过iterator传送数据&lt;/li&gt;
&lt;li&gt;通过writable iterator返回数据&lt;/li&gt;
&lt;li&gt;通过return iterator返回数据&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Partial Failure(局部Crash,降格求全)

&lt;ul&gt;
&lt;li&gt;Question

&lt;ul&gt;
&lt;li&gt;如何处理不可预见的内存需求&lt;/li&gt;
&lt;li&gt;Environment

&lt;ul&gt;
&lt;li&gt;No enough memory for running system&lt;/li&gt;
&lt;li&gt;宁可在非关键任务中fail,也不要简单放弃关键任务&lt;/li&gt;
&lt;li&gt;持续不断的运行

&lt;ul&gt;
&lt;li&gt;比始终完善地运行重要&lt;/li&gt;
&lt;li&gt;比系统crash重要&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Way

&lt;ul&gt;
&lt;li&gt;请确保内存用完，也要让系统处于安全状态&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Implementation

&lt;ul&gt;
&lt;li&gt;侦测内存耗尽&lt;/li&gt;
&lt;li&gt;到达安全状态&lt;/li&gt;
&lt;li&gt;释放资源&lt;/li&gt;
&lt;li&gt;降级模式&lt;/li&gt;
&lt;li&gt;未雨绸缪&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Captain Oates(牺牲小我)

&lt;ul&gt;
&lt;li&gt;Question

&lt;ul&gt;
&lt;li&gt;如何满足对内存的最重要需求&lt;/li&gt;
&lt;li&gt;Environment

&lt;ul&gt;
&lt;li&gt;许多系统都有运行在后台的组件&lt;/li&gt;
&lt;li&gt;许多系统为了提高性能，会以高速缓冲的方式存放数据&lt;/li&gt;
&lt;li&gt;与后台活动相比，用户更关心自己的工作&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Way

&lt;ul&gt;
&lt;li&gt;应该牺牲非绝对必要的组件使用的内存，以免抗拒重要的任务&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Implementation

&lt;ul&gt;
&lt;li&gt;侦测内存耗尽&lt;/li&gt;
&lt;li&gt;处理内存不足&lt;/li&gt;
&lt;li&gt;良民&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Read-Only Memory

&lt;ul&gt;
&lt;li&gt;Question

&lt;ul&gt;
&lt;li&gt;如何处置只读的代码和数据&lt;/li&gt;
&lt;li&gt;Environment

&lt;ul&gt;
&lt;li&gt;系统提供只读内存与可写内存&lt;/li&gt;
&lt;li&gt;只读内存成本更低&lt;/li&gt;
&lt;li&gt;程序通常并不修改executable code&lt;/li&gt;
&lt;li&gt;程序不修改资源文件、查找表、以及其他预初始化的数据&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Way

&lt;ul&gt;
&lt;li&gt;最好将只读的代码与数据存储在只读内存&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Implementation

&lt;ul&gt;
&lt;li&gt;存储代码&lt;/li&gt;
&lt;li&gt;在代码中包含数据&lt;/li&gt;
&lt;li&gt;将静态数据结构放入ROM

&lt;ul&gt;
&lt;li&gt;DES相关数据&lt;/li&gt;
&lt;li&gt;sin,cos&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;只读文件系统&lt;/li&gt;
&lt;li&gt;版本控制&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Hooks(挂钩)

&lt;ul&gt;
&lt;li&gt;Question

&lt;ul&gt;
&lt;li&gt;如何更改只读存储器内在信息&lt;/li&gt;
&lt;li&gt;Environment

&lt;ul&gt;
&lt;li&gt;正在使用ROM&lt;/li&gt;
&lt;li&gt;无法修改ROM&lt;/li&gt;
&lt;li&gt;ROM中的数据需要维护与升级&lt;/li&gt;
&lt;li&gt;进行较小的修改&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Way

&lt;ul&gt;
&lt;li&gt;在RAM中，通过hooks访问只读信息，通过更改hook,以产生信息更改的假象&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Implementation

&lt;ul&gt;
&lt;li&gt;从ROM中，调用RAM&lt;/li&gt;
&lt;li&gt;Extand

&lt;ul&gt;
&lt;li&gt;ROM objects&lt;/li&gt;
&lt;li&gt;ROM Datas&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;Secondary Storage(辅助存储设备)&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Problem

&lt;ul&gt;
&lt;li&gt;Question

&lt;ul&gt;
&lt;li&gt;一旦你用光主内存，接下来如何处理&lt;/li&gt;
&lt;li&gt;Environment

&lt;ul&gt;
&lt;li&gt;primary storage无法满足内存需求&lt;/li&gt;
&lt;li&gt;无法降低系统的内存需求&lt;/li&gt;
&lt;li&gt;可以将辅助存储设备添加到“running system”设备上&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Way

&lt;ul&gt;
&lt;li&gt;把辅助存储设备当作运行时间的额外内存&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Implementation

&lt;ul&gt;
&lt;li&gt;高效使用辅助内存

&lt;ul&gt;
&lt;li&gt;设计时需要分割什么？

&lt;ul&gt;
&lt;li&gt;Execute code&lt;/li&gt;
&lt;li&gt;data&lt;/li&gt;
&lt;li&gt;configuration information&lt;/li&gt;
&lt;li&gt;Or other mix-parts&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;哪个层次进行分割

&lt;ul&gt;
&lt;li&gt;Coder&lt;/li&gt;
&lt;li&gt;System&lt;/li&gt;
&lt;li&gt;User&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Who do loading and unloading

&lt;ul&gt;
&lt;li&gt;Coder&lt;/li&gt;
&lt;li&gt;System&lt;/li&gt;
&lt;li&gt;User&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;When do loading/unloading&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Specialzation Patterns

&lt;ul&gt;
&lt;li&gt;Application Switching(任务转换)

&lt;ul&gt;
&lt;li&gt;Question

&lt;ul&gt;
&lt;li&gt;面对提供许多不同功能的系统，如何降低其内存需求&lt;/li&gt;
&lt;li&gt;Environment

&lt;ul&gt;
&lt;li&gt;系统太庞大，主内存无法容纳全部代码与数据&lt;/li&gt;
&lt;li&gt;用户经常一次只需要运行一项任务&lt;/li&gt;
&lt;li&gt;单一任务只需要自己的代码和数据就能运行，其他代码和数据可以存放在辅助存储设备内&lt;/li&gt;
&lt;li&gt;一次只编写一组相关任务更容易&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Way

&lt;ul&gt;
&lt;li&gt;把系统分割成独立模块，每次只运行一个&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Implementation

&lt;ul&gt;
&lt;li&gt;关键问题

&lt;ul&gt;
&lt;li&gt;进程间的通信&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Rules

&lt;ul&gt;
&lt;li&gt;进程间的控制流必须简单&lt;/li&gt;
&lt;li&gt;进程间尽量不传递短暂性数据&lt;/li&gt;
&lt;li&gt;分割必须对用户有意义&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Methods

&lt;ul&gt;
&lt;li&gt;程序链(Program chaining)

&lt;ul&gt;
&lt;li&gt;程序间转换方便&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Master Program(主控程序)&lt;/li&gt;
&lt;li&gt;进程间通信(InterProcess Communication, IPC)&lt;/li&gt;
&lt;li&gt;管理数据&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Data Files(纯数据文件)

&lt;ul&gt;
&lt;li&gt;Question

&lt;ul&gt;
&lt;li&gt;主内存无法容纳全部数据&lt;/li&gt;
&lt;li&gt;Way

&lt;ul&gt;
&lt;li&gt;一次只处理一部分数据&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Implementation

&lt;ul&gt;
&lt;li&gt;主要操作

&lt;ul&gt;
&lt;li&gt;简单循序输入(依次读取各章)&lt;/li&gt;
&lt;li&gt;简单循序输出(依次写入文件)&lt;/li&gt;
&lt;li&gt;随机访问(读取交叉参考文件)&lt;/li&gt;
&lt;li&gt;循序输出至数个文件(利用临时文件)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Methods

&lt;ul&gt;
&lt;li&gt;增量式处理&lt;/li&gt;
&lt;li&gt;子文件处理&lt;/li&gt;
&lt;li&gt;随机访问

&lt;ul&gt;
&lt;li&gt;利用索引&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Resource Files(纯资源文件)

&lt;ul&gt;
&lt;li&gt;Question

&lt;ul&gt;
&lt;li&gt;如何管理为数众多的配置数据&lt;/li&gt;
&lt;li&gt;Environment

&lt;ul&gt;
&lt;li&gt;很多程序数据是一些只读配置信息，程序不可更改&lt;/li&gt;
&lt;li&gt;配置数据通常比代码变化频繁&lt;/li&gt;
&lt;li&gt;数据可能被程序的不同phases取用&lt;/li&gt;
&lt;li&gt;任何时候你都只需要少数数据&lt;/li&gt;
&lt;li&gt;文件系统支持随机访问&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Way

&lt;ul&gt;
&lt;li&gt;在辅助存储设备内保存配置数据，必要时才load/unload其中一项&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Implementation

&lt;ul&gt;
&lt;li&gt;必须让程序员得以轻松运用&lt;/li&gt;
&lt;li&gt;运用资源文件，节约内存&lt;/li&gt;
&lt;li&gt;字体文件&lt;/li&gt;
&lt;li&gt;实现一个资源文件系统&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Packages(封包)

&lt;ul&gt;
&lt;li&gt;Question

&lt;ul&gt;
&lt;li&gt;如何管理有许多可选组件的大型程序&lt;/li&gt;
&lt;li&gt;Environment

&lt;ul&gt;
&lt;li&gt;内存有限&lt;/li&gt;
&lt;li&gt;功能不会全部用到&lt;/li&gt;
&lt;li&gt;不同功能组合使用&lt;/li&gt;
&lt;li&gt;组件相互有分隔，发展更顺利&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Way

&lt;ul&gt;
&lt;li&gt;把程序分解为多个packages,只在系统需要具体的package时才装载&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Implementation

&lt;ul&gt;
&lt;li&gt;Need

&lt;ul&gt;
&lt;li&gt;需要一个能够装载组件的系统&lt;/li&gt;
&lt;li&gt;系统可以分割成模块，分别运行&lt;/li&gt;
&lt;li&gt;可动态装载&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Methods

&lt;ul&gt;
&lt;li&gt;把进程视为packages&lt;/li&gt;
&lt;li&gt;利用动态链接库&lt;/li&gt;
&lt;li&gt;功能代码分块&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Paging(分页)

&lt;ul&gt;
&lt;li&gt;Question

&lt;ul&gt;
&lt;li&gt;如何制造出内存数量无限的幻象&lt;/li&gt;
&lt;li&gt;Way

&lt;ul&gt;
&lt;li&gt;分页内存&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Implementation

&lt;ul&gt;
&lt;li&gt;在内存操作处拦截

&lt;ul&gt;
&lt;li&gt;MMU&lt;/li&gt;
&lt;li&gt;Interpreter&lt;/li&gt;
&lt;li&gt;Process Swap&lt;/li&gt;
&lt;li&gt;Data Manager&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;页面替换&lt;/li&gt;
&lt;li&gt;工作集大小&lt;/li&gt;
&lt;li&gt;分页控制&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;Compression(压缩)&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Implementation

&lt;ul&gt;
&lt;li&gt;机械冗余&lt;/li&gt;
&lt;li&gt;语义冗余&lt;/li&gt;
&lt;li&gt;有损压缩&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Ｍethod

&lt;ul&gt;
&lt;li&gt;表格压缩

&lt;ul&gt;
&lt;li&gt;Simple Coding&lt;/li&gt;
&lt;li&gt;Huffman coding&lt;/li&gt;
&lt;li&gt;Other coding&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;差分编码

&lt;ul&gt;
&lt;li&gt;根据相临两个数据间的差异来表现序列

&lt;ul&gt;
&lt;li&gt;Delta coding&lt;/li&gt;
&lt;li&gt;Run-length coding&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;自省式压缩

&lt;ul&gt;
&lt;li&gt;MTF&lt;/li&gt;
&lt;li&gt;LZ&lt;/li&gt;
&lt;li&gt;zlib&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;SmallDataStructures小型数据结构&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;PackedData

&lt;ul&gt;
&lt;li&gt;Union&lt;/li&gt;
&lt;li&gt;Bit Packing&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Sharing&lt;/li&gt;
&lt;li&gt;Copy OnWrite&lt;/li&gt;
&lt;li&gt;EmbeddedPointers&lt;/li&gt;
&lt;li&gt;Mix&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;MemoryAllocation&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Fixed Allocation

&lt;ul&gt;
&lt;li&gt;StaticAlloc&lt;/li&gt;
&lt;li&gt;PreAlloc&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Variable Allocation

&lt;ul&gt;
&lt;li&gt;DynamicAlloc&lt;/li&gt;
&lt;li&gt;Heap&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Memory Discard

&lt;ul&gt;
&lt;li&gt;Stack Alloc&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Pooled Alloc&lt;/li&gt;
&lt;li&gt;Compaction&lt;/li&gt;
&lt;li&gt;Reference Counting&lt;/li&gt;
&lt;li&gt;GC&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;&lt;img src=&quot;http://pic.yupoo.com/qianjigui/CM2ddHDD/medish.jpg&quot; alt=&quot;http://pic.yupoo.com/qianjigui/CM2ddHDD/medish.jpg&quot; /&gt;&lt;/h2&gt;

&lt;h2&gt;&lt;img src=&quot;/assets/svgfiles/SmallMemorySoftwarePatternsForSystemWithLimitedMemorryGlobalView.svg&quot; alt=&quot;LowRamStuctureView&quot; /&gt;&lt;/h2&gt;
</content>
 </entry>
 
 <entry>
   <title>Reading Note for Rails Recipes</title>
   <link href="http://www.5wpc.info/it/technical/language/ruby/2013/01/30/RailsRecipes"/>
   <updated>2013-01-30T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/technical/language/ruby/2013/01/30/RailsRecipes</id>
   <content type="html">&lt;p&gt;对于目录的翻译整理，方便以后查阅。&lt;/p&gt;

&lt;h1&gt;Introduction&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;What Makes a Good Recipe Book?&lt;/li&gt;
&lt;li&gt;Who’s It For?&lt;/li&gt;
&lt;li&gt;Rails Version&lt;/li&gt;
&lt;li&gt;Resources&lt;/li&gt;
&lt;li&gt;Acknowledgments&lt;/li&gt;
&lt;li&gt;Tags and Thumbtabs&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Part I—User Interface Recipes&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;   In-Place Form Editing
   原地Ajax表单编辑&lt;/li&gt;
&lt;li&gt;   Making Your Own JavaScript Helper
   制作方便自己使用的JS生成方法&lt;/li&gt;
&lt;li&gt;   Live Preview
   实时编辑查看结果显示&lt;/li&gt;
&lt;li&gt;   Live Search
   实时搜索结果显示&lt;/li&gt;
&lt;li&gt;   Creating a Drag-and-Drop Sortable List
   创建可以拖动的排序列表&lt;/li&gt;
&lt;li&gt;   Update Multiple Page Elements With One Ajax Request
   通过一个Ajax请求更新多个页面的元素&lt;/li&gt;
&lt;li&gt;   Lightning-Fast JavaScript Auto-completion
   快速的JS自动补全&lt;/li&gt;
&lt;li&gt;   Cheap and Easy Theme Support
   页面主题变更支持&lt;/li&gt;
&lt;li&gt;   Use Ajax To Trim Fat, Static Pages
   利用Ajax修剪复杂的页面&lt;/li&gt;
&lt;li&gt;   Smart Pluralization
   通过工具实现I18N&lt;/li&gt;
&lt;li&gt;   Debugging Ajax
   调试Ajax&lt;/li&gt;
&lt;li&gt;   Creating a Custom Form Builder
   自定义表单生成&lt;/li&gt;
&lt;li&gt;   Make Pretty Graphs
   生成漂亮的图像&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Part II—Database Recipes&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;   Rails Without A Database
   不用DB&lt;/li&gt;
&lt;li&gt;   Connecting to Multiple Databases
   同时连接使用过个DB&lt;/li&gt;
&lt;li&gt;   Integrating with Legacy Databases
   集成废弃的DB&lt;/li&gt;
&lt;li&gt;   DRY Up Your Database Configuration
   做通用的DB配置&lt;/li&gt;
&lt;li&gt;   Self-referential Many-to-Many Relationships
   Model自身的多对多关系实现&lt;/li&gt;
&lt;li&gt;   Tagging
   文本数据打Tag&lt;/li&gt;
&lt;li&gt;   Versioning Your ActiveRecord Models
   版本控制用户编辑的数据Model(类似于草稿)&lt;/li&gt;
&lt;li&gt;   Convert an Existing Application to Migrations
   对存在的应用做迁移&lt;/li&gt;
&lt;li&gt;   Many to Many Relationships Where the Relationship Itself Has Data
   多对多关系中，关系表中存在私有数据&lt;/li&gt;
&lt;li&gt;   Polymorphic Associations - has_many :whatevers
   一对多关系中同时对应多个Model&lt;/li&gt;
&lt;li&gt;   Adding Behavior to Your ActiveRecord Associations
   在关联中添加行为，方便在关联获取时添加搜索条件约束&lt;/li&gt;
&lt;li&gt;   Dynamic Database Config
   动态DB配置:类似于ERB&lt;/li&gt;
&lt;li&gt;   Use ActiveRecord Outside of Rails
   将ActiveRecord模型抽取出来单独使用&lt;/li&gt;
&lt;li&gt;   Perform Calculations on Yor Model Data
   检测Model的性能&lt;/li&gt;
&lt;li&gt;   DRY Up Your ActiveRecord Code With Scoping
   使Scoping不重复&lt;/li&gt;
&lt;li&gt;   Make Dumb Data Smart with composed_of
   将一个复杂的对象映射到DB表中的一个表项&lt;/li&gt;
&lt;li&gt;   Safely Use Models in Migrations
   在Model迁移中注意一致性&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Part III—Controller Recipes&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;   Authentication
   验证&lt;/li&gt;
&lt;li&gt;   Role-Based Authorization
   基于规则的验证&lt;/li&gt;
&lt;li&gt;   Cleaning Up Controllers with Postback Actions
   去掉冗余的action&lt;/li&gt;
&lt;li&gt;   Keep An Eye On Your Session Expiry
   注意session有效期&lt;/li&gt;
&lt;li&gt;   Rendering Comma Separated Values From Your Actions
   将返回数据格式化:Json, xml, cvs&lt;/li&gt;
&lt;li&gt;   Make your URLs Meaningful (and pretty)
   使URL有意义&lt;/li&gt;
&lt;li&gt;   Stub Out Authentication
   将验证作为过滤器的一部分&lt;/li&gt;
&lt;li&gt;   Convert Your Sessions To ActiveRecord
   将session放入DB&lt;/li&gt;
&lt;li&gt;   Write Code That Writes Code
   制作代码生成器&lt;/li&gt;
&lt;li&gt;   Manage a Static Site With Rails
   利用Rails管理静态网站&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Part IV—Testing Recipes&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;   Creating Dynamic Test Fixtures
   制作动态测试数据&lt;/li&gt;
&lt;li&gt;   Extracting Test Fixtures From Live Data
   从实际数据中抽取测试数据&lt;/li&gt;
&lt;li&gt;   Testing Across Multiple Controllers
   测试多请求访问&lt;/li&gt;
&lt;li&gt;   Write Tests for Your Helpers
   为辅助方法做测试&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Part V—Big Picture Recipes&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;   Automating Development With Your Own Generators
   制作自己的生成器&lt;/li&gt;
&lt;li&gt;   Continuous Integration
   持续集成&lt;/li&gt;
&lt;li&gt;   Getting Notified of Unhandled Exceptions
   捕获异常&lt;/li&gt;
&lt;li&gt;   Creating Your Own Rake Tasks
   制作自己的Rake任务&lt;/li&gt;
&lt;li&gt;   Dealing With Time-zones
   解决时区问题&lt;/li&gt;
&lt;li&gt;   Living On The Edge (of Rails Development)
   跟紧各种更新&lt;/li&gt;
&lt;li&gt;   Syndicate Your Site With RSS
   将数据RSS化&lt;/li&gt;
&lt;li&gt;   Making Your Own Rails Plugins
   制作自己的插件&lt;/li&gt;
&lt;li&gt;   Secret URLs
   带有验证信息的URL,需要在URL携带身份信息的处理方法&lt;/li&gt;
&lt;li&gt;   Quickly Inspect Your Sessions’ Contents
   访问本地的session保护&lt;/li&gt;
&lt;li&gt;   Sharing Models Between Your Applications
   通过链接等方式共享Model&lt;/li&gt;
&lt;li&gt;   Generate Documentation For Your Application
   利用Rdoc&lt;/li&gt;
&lt;li&gt;   Processing Uploaded Images
   处理上传的图片&lt;/li&gt;
&lt;li&gt;   Easily Group Lists of Things
   对List做处理的API&lt;/li&gt;
&lt;li&gt;   Keeping Track of Who Did What
   对信息做标注，记录操作用户&lt;/li&gt;
&lt;li&gt;   Distributing Your Application As One Directory Tree
   利用目录树机制实现应用的分布式&lt;/li&gt;
&lt;li&gt;   Adding Support for Localization
   L10N&lt;/li&gt;
&lt;li&gt;   The Console Is Your Friend
   充分利用Console&lt;/li&gt;
&lt;li&gt;   Automatically Save a Draft of a Form
   自动表单保存&lt;/li&gt;
&lt;li&gt;   Validating Non-ActiveRecord Objects
   对非ActiveRecord对象做验证&lt;/li&gt;
&lt;li&gt;   Easy HTML Whitelists
   对HTML敏感字符做过滤&lt;/li&gt;
&lt;li&gt;   Adding Simple Web Services To Your Actions
   添加WebServices到Action&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Part VI—E-Mail Recipes&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;   Send Gracefully Degrading Rich-Content Emails
   发送富文本邮件(例如颜色什么的)&lt;/li&gt;
&lt;li&gt;   Testing Incoming Email
   检查收到的邮件&lt;/li&gt;
&lt;li&gt;   Sending Email With Attachments
   发送带有附件的邮件&lt;/li&gt;
&lt;li&gt;   Handling Bounced Email
   搜集邮件失败信息的反馈邮件&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Part VII—Appendix&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;Resources

&lt;ol&gt;
&lt;li&gt;Bibliography&lt;/li&gt;
&lt;li&gt;Source Code&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;

</content>
 </entry>
 
 <entry>
   <title>Programming Eralng</title>
   <link href="http://www.5wpc.info/it/technical/language/erlang/2013/01/30/ProgrammingErlang"/>
   <updated>2013-01-30T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/technical/language/erlang/2013/01/30/ProgrammingErlang</id>
   <content type="html">&lt;h1&gt;整体介绍&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Paperback: 536 pages&lt;/li&gt;
&lt;li&gt;Publisher: Pragmatic Bookshelf; 1 edition (11 July 2007)&lt;/li&gt;
&lt;li&gt;Language English&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;网络上总结的读书笔记&lt;/h2&gt;

&lt;p&gt;http://www.javaeye.com/wiki/erlang?category_id=91&lt;/p&gt;

&lt;h2&gt;内容简介&lt;/h2&gt;

&lt;p&gt;《Erlang程序设计》是讲述下一代编程语言Erlang 的权威著作，主要涵盖顺序型编程、异常处理、编译和运行代码、并发编程、并发编程中的错误处理、分布式编程、多核编程等内容。《Erlang程序设计》将 帮助读者在消息传递的基础上构建分布式的并发系统，免去锁与互斥技术的羁绊，使程序在多核CPU 上高效运行。《Erlang程序设计》讲述的各种设计方法和行为将成为设计容错与分布式系统中的利器。&lt;/p&gt;

&lt;h2&gt;编辑推荐&lt;/h2&gt;

&lt;p&gt;《Erlang程序设计》由Erlang之父Joe Armstrong编写，是毋庸置疑的经典著作。书中兼顾了顺序编程、并发编程和分布式编程，较深入地讨论了开发Erlang应用中至关重要的文件和网络 编程、OTP、MNesia、Ets和Dets等主题，更为精彩的是，大师亲自操刀，构建了MapReduce实例和多人聊天实例，一定让你大呼过瘾。&lt;/p&gt;

&lt;p&gt;在多核、并发、分布为王的时代，谁将成为下一个主流编程语言？来自全世界的众多专家都认为，Erlang最有可能在竞争中胜出。&lt;/p&gt;

&lt;p&gt;Erlang 开源语言系出名门，通信巨头爱立信公司用它开发出了可靠性惊人的交换机系统AXD301。它天生就是面向并发、分布和高容错的，兼有函数式语言和脚本语言 的各种优点，而且已经用于商业开发多年，具有稳定性极高的虚拟机和平台库。有了这些天时地利，无怪乎Erlang能够迅速成为热门的开发语言，除了广泛应 用于通信行业之外，它已经进入了各个领域：Facebook用它实现了聊天系统，Yahoo用它重写了Delicious，Amazon用它开发了云计算 数据服务SimpleDB，还有多人游戏、测试工具、电子支付、数据采集与监控、企业消息、电子邮件、空中交通管制。&lt;/p&gt;

&lt;h2&gt;目录&lt;/h2&gt;

&lt;p&gt;第1章　引言　1
1.1　路线图　1
1.2　正式起航　3
1.3　致谢　3&lt;/p&gt;

&lt;p&gt;第2章　入门　5
2.1　概览　5
2.1.1　阶段1：茫然无绪　5
2.1.2　阶段2：初窥门径　5
2.1.3　阶段2.5：观其大略，不求甚解　6
2.1.4　阶段3：运用自如　6
2.1.5　重中之重　6
2.2　Erlang安装　7
2.2.1　二进制发布版　7
2.2.2　从源代码创建Erlang　8
2.2.3　使用CEAN　8
2.3　本书代码　8
2.4　启动shell　9
2.5　简单的整数运算　10
2.6　变量　11
2.6.1　变量不变　12
2.6.2　模式匹配　13
2.6.3　单一赋值为何有益于编写质量更高的代码　14
2.7　浮点数　15
2.8　原子　16
2.9　元组　17
2.9.1　创建元组　18
2.9.2　从元组中提取字段值　18
2.10　列表　19
2.10.1　术语　20
2.10.2　定义列表　20
2.10.3　从列表中提取元素　20
2.11　字符串　21
2.12　再论模式匹配　22&lt;/p&gt;

&lt;p&gt;第3章　顺序型编程　24
3.1　模块　24
3.2　购物系统——进阶篇　28
3.3　同名不同目的函数　31
3.4　fun　31
3.4.1　以fun为参数的函数　32
3.4.2　返回fun的函数　33
3.4.3　定义你自己的抽象流程控制　34
3.5　简单的列表处理　35
3.6　列表解析　38
3.6.1　快速排序　39
3.6.2　毕达哥拉斯三元组　40
3.6.3　变位词　40
3.7　算术表达式　41
3.8　断言　41
3.8.1　断言序列　42
3.8.2　断言样例　43
3.8.3　true断言的使用　44
3.8.4　过时的断言函数　44
3.9　记录　44
3.9.1　创建和更新记录　45
3.9.2　从记录中提取字段值　45
3.9.3　在函数中对记录进行模式匹配　46
3.9.4　记录只是元组的伪装　46
3.10　case/if表达式　46
3.10.1　case表达式　47
3.10.2　if表达式　47
3.11　以自然顺序创建列表　48
3.12　累加器　48&lt;/p&gt;

&lt;p&gt;第4章　异常　50
4.1　异常　50
4.2　抛出异常　51
4.3　try...catch　51
4.3.1　缩减版本　53
4.3.2　使用try...catch的编程惯例　53
4.4　catch　54
4.5　改进错误信息　55
4.6　try...catch的编程风格　55
4.6.1　经常会返回错误的程序　55
4.6.2　出错几率比较小的程序　56
4.7　捕获所有可能的异常　56
4.8　新老两种异常处理风格　56
4.9　栈跟踪　57&lt;/p&gt;

&lt;p&gt;第5章　顺序型编程进阶　58
5.1　BIF　58
5.2　二进制数据　58
5.3　比特语法　60
5.3.1　16bit色彩的封包与解包　60
5.3.2　比特语法表达式　61
5.3.3　高级比特语法样例　62
5.4　小问题集锦　67
5.4.1　apply　68
5.4.2　属性　68
5.4.3　块表达式　71
5.4.4　布尔类型　71
5.4.5　布尔表达式　72
5.4.6　字符集　72
5.4.7　注释　72
5.4.8　epp　73
5.4.9　转义符　73
5.4.10　表达式和表达式序列　74
5.4.11　函数引用　74
5.4.12　包含文件　75
5.4.13　列表操作符++和——　75
5.4.14　宏　76
5.4.15　在模式中使用匹配操作符　77
5.4.16　数值类型　78
5.4.17　操作符优先级　79
5.4.18　进程字典　79
5.4.19　引用　80
5.4.20　短路布尔表达式　80
5.4.21　比较表达式　81
5.4.22　下划线变量　82&lt;/p&gt;

&lt;p&gt;第6章　编译并运行程序　83
6.1　开启和停止Erlang shell　83
6.2　配置开发环境　84
6.2.1　为文件加载器设定搜索路径　84
6.2.2　在系统启动时批量执行命令　85
6.3　运行程序的几种不同方法　86
6.3.1　在Erlang shell中编译运行　86
6.3.2　在命令提示符下编译运行　86
6.3.3　把程序当作escript脚本运行　88
6.3.4　用命令行参数编程　89
6.4　使用makefile进行自动编译　90
6.4.1　makefile模板　90
6.4.2　定制makefile模板　92
6.5　在Erlang shell中的命令编辑　93
6.6　解决系统死锁　93
6.7　如何应对故障　93
6.7.1　未定义/遗失代码　94
6.7.2　makefile不能工作　94
6.7.3　shell没有响应　95
6.8　获取帮助　96
6.9　调试环境　96
6.10　崩溃转储　97&lt;/p&gt;

&lt;p&gt;第7章　并发　98&lt;/p&gt;

&lt;p&gt;第8章　并发编程　101
8.1　并发原语　101
8.2　一个简单的例子　102
8.3　客户/服务器介绍　103
8.4　创建一个进程需要花费多少时间　107
8.5　带超时的receive　109
8.5.1　只有超时的receive　109
8.5.2　超时时间为0的receive　109
8.5.3　使用一个无限等待超时进行接收　110
8.5.4　实现一个计时器　110
8.6　选择性接收　111
8.7　注册进程　112
8.8　如何编写一个并发程序　113
8.9　尾递归技术　114
8.10　使用MFA启动进程　115
8.11　习题　115&lt;/p&gt;

&lt;p&gt;第9章　并发编程中的错误处理　116
9.1　链接进程　116
9.2　on_exit处理程序　117
9.3　远程错误处理　118
9.4　错误处理的细节　118
9.4.1　捕获退出的编程模式　119
9.4.2　捕获退出信号(进阶篇)　120
9.5　错误处理原语　125
9.6　链接进程集　126
9.7　监视器　126
9.8　存活进程　127&lt;/p&gt;

&lt;p&gt;第10章　分布式编程　128
10.1　名字服务　129
10.1.1　第一步：一个简单的名字服务　130
10.1.2　第二步：在同一台机器上，客户端运行于一个节点而服务器运行于第二个节点　131
10.1.3　第三步：让客户机和服务器运行于同一个局域网内的不同机器上　132
10.1.4　第四步：在因特网上的不同主机上分别运行客户机和服务器　133
10.2　分布式原语　134
10.3　分布式编程中使用的库　136
10.4　有cookie保护的系统　136
10.5　基于套接字的分布式模式　137
10.5.1　lib_chan　137
10.5.2　服务器代码　138&lt;/p&gt;

&lt;p&gt;第11章　IRC Lite　141
11.1　消息序列图　142
11.2　用户界面　143
11.3　客户端程序　144
11.4　服务器端组件　147
11.4.1　聊天控制器　147
11.4.2　聊天服务器　148
11.4.3　群组管理器　149
11.5　运行程序　150
11.6　聊天程序源代码　151
11.6.1　聊天客户端　151
11.6.2　Lib_chan配置　154
11.6.3　聊天控制器　154
11.6.4　聊天服务器　155
11.6.5　聊天群组　156
11.6.6　输入输出窗口　157
11.7　习题　159&lt;/p&gt;

&lt;p&gt;第12章　接口技术　160
12.1　端口　161
12.2　为一个外部C程序添加接口　161
12.2.1　C程序　162
12.2.2　Erlang程序　164
12.3　open_port　167
12.4　内联驱动　167
12.5　注意　170&lt;/p&gt;

&lt;p&gt;第13章　对文件编程　172
13.1　库的组织结构　172
13.2　读取文件的不同方法　172
13.2.1　从文件中读取所有Erlang数据项　174
13.2.2　从文件的数据项中一次读取一项　174
13.2.3　从文件中一次读取一行数据　176
13.2.4　将整个文件的内容读入到一个二进制数据中　176
13.2.5　随机读取一个文件　176
13.2.6　读取ID3标记　177
13.3　写入文件的不同方法　179
13.3.1　向一个文件中写入一串Erlang数据项　179
13.3.2　向文件中写入一行　181
13.3.3　一步操作写入整个文件　181
13.3.4　在随机访问模式下写入文件　183
13.4　目录操作　183
13.5　查询文件的属性　184
13.6　复制和删除文件　185
13.7　小知识　185
13.8　一个搜索小程序　186&lt;/p&gt;

&lt;p&gt;第14章　套接字编程　189
14.1　使用TCP　189
14.1.1　从服务器上获取数据　189
14.1.2　一个简单的TCP服务器　192
14.1.3　改进服务器　195
14.1.4　注意　196
14.2　控制逻辑　197
14.2.1　主动型消息接收(非阻塞)　197
14.2.2　被动型消息接收(阻塞)　198
14.2.3　混合型模式(半阻塞)　198
14.3　连接从何而来　199
14.4　套接字的出错处理　199
14.5　UDP　200
14.5.1　最简单的UDP服务器和客户机　201
14.5.2　一个计算阶乘UDP的服务器　201
14.5.3　关于UDP协议的其他注意事项　203
14.6　向多台机器广播消息　203
14.7　SHOUTcast服务器　204
14.7.1　SHOUTcast协议　205
14.7.2　SHOUTcast服务器的工作机制　205
14.7.3　SHOUTcast服务器的伪代码　206
14.7.4　运行SHOUTcast服务器　211
14.8　进一步深入　212&lt;/p&gt;

&lt;p&gt;第15章　ETS和DETS：大量数据的存储机制　213
15.1　表的基本操作　214
15.2　表的类型　214
15.3　ETS表的效率考虑　215
15.4　创建ETS表　216
15.5　ETS程序示例　217
15.5.1　三字索引迭代器　218
15.5.2　构造表　219
15.5.3　构造表有多快　219
15.5.4　访问表有多快　220
15.5.5　胜出的是……　220
15.6　DETS　222
15.7　我们没有提及的部分　224
15.8　代码清单　225&lt;/p&gt;

&lt;p&gt;第16章　OTP概述　228
16.1　通用服务器程序的进化路线　229
16.1.1　server 1：原始服务器程序　229
16.1.2　server 2：支持事务的服务器程序　230
16.1.3　server 3：支持热代码替换的服务器程序　231
16.1.4　server 4：同时支持事务和热代码替换　233
16.1.5　server 5：压轴好戏　234
16.2　gen_server起步　236
16.2.1　第一步：确定回调模块的名称　237
16.2.2　第二步：写接口函数　237
16.2.3　第三步：编写回调函数　237
16.3　gen_server回调的结构　240
16.3.1　启动服务器程序时发生了什么　240
16.3.2　调用服务器程序时发生了什么　240
16.3.3　调用和通知　241
16.3.4　发给服务器的原生消息　241
16.3.5　Hasta la Vista, Baby(服务器的终止)　242
16.3.6　热代码替换　242
16.4　代码和模板　243
16.4.1　gen_server模板　243
16.4.2　my_bank　245
16.5　进一步深入　246&lt;/p&gt;

&lt;p&gt;第17章　Mnesia：Erlang数据库　247
17.1　数据库查询　247
17.1.1　选取表中所有的数据　248
17.1.2　选取表中的数据　249
17.1.3　按条件选取表中的数据　249
17.1.4　从两个表选取数据(关联查询)　250
17.2　增删表中的数据　250
17.2.1　增加一行　251
17.2.2　删除一行　251
17.3　Mnesia事务　252
17.3.1　取消一个事务　253
17.3.2　加载测试数据　255
17.3.3　do()函数　255
17.4　在表中保存复杂数据　256
17.5　表的类型和位置　257
17.5.1　创建表　258
17.5.2　表属性的常见组合　259
17.5.3　表的行为　260
17.6　创建和初始化数据库　260
17.7　表查看器　261
17.8　进一步深入　262
17.9　代码清单　262&lt;/p&gt;

&lt;p&gt;第18章　构造基于OTP的系统　266
18.1　通用的事件处理　267
18.2　错误日志　270
18.2.1　记录一个错误　270
18.2.2　配置错误日志　270
18.2.3　分析错误　274
18.3　警报管理　275
18.4　应用服务　277
18.4.1　素数服务　277
18.4.2　面积服务　278
18.5　监控树　279
18.6　启动整个系统　282
18.7　应用程序　285
18.8　文件系统的组织　287
18.9　应用程序监视器　288
18.10　进一步深入　289
18.11　我们如何创建素数　290&lt;/p&gt;

&lt;p&gt;第19章　多核小引　292&lt;/p&gt;

&lt;p&gt;第20章　多核编程　294
20.1　如何在多核的CPU上更有效率地运行　295
20.1.1　使用大量进程　295
20.1.2　避免副作用　295
20.1.3　顺序瓶颈　296
20.2　并行化顺序代码　297
20.3　小消息、大计算　300
20.4　映射—归并算法和磁盘索引程序　303
20.4.1　映射—归并算法　303
20.4.2　全文检索　307
20.4.3　索引器的操作　308
20.4.4　运行索引器　309
20.4.5　评论　310
20.4.6　索引器的代码　310
20.5　面向未来的成长　311&lt;/p&gt;

&lt;p&gt;附录A　给我们的程序写文档　312
附录B　Microsoft Windows环境下的Erlang环境　316
附录C　资源　318
附录D　套接字应用程序　321
附录E　其他　335
附录F　模块和函数参考　351
索引　415&lt;/p&gt;

&lt;h1&gt;Note&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&quot;erlang&quot;&gt;
第1章　引言　1
1.1　路线图　1
1.2　正式起航　3
1.3　致谢　3
面向并行编程的杰出语言，由爱立信公司开发。 

第2章　入门　5
2.1　概览　5
2.1.1　阶段1：茫然无绪　5
2.1.2　阶段2：初窥门径　5
2.1.3　阶段2.5：观其大略，不求甚解　6
2.1.4　阶段3：运用自如　6
2.1.5　重中之重　6
2.2　Erlang安装　7
2.2.1　二进制发布版　7
2.2.2　从源代码创建Erlang　8
2.2.3　使用CEAN　8
关于ubuntu的安装，需要如下东西。
sudo apt-get install erlang, erlang-dev, erlang-x11, erlang-src, erlang-nox 
2.3　本书代码　8
2.4　启动shell　9
erl 
2.5　简单的整数运算　10
允许任意长度，解释器内部自动调整，类似于Ruby 
2.6　变量　11 
首子母要求大写 
2.6.1　变量不变　12
变量像代数里的变量一样只允许赋值一次，可以使用f()函数来forget all variable bindings 
赋过值的变量称为bound variable，否则称为unbound variable 
“=”在这里不是赋值操作符，而是模式匹配符 
在Erlang里一个变量只是一个值的引用，即一个指向存储值的区域的指针，而这个值不能被改变  
2.6.2　模式匹配　13
2.6.3　单一赋值为何有益于编写质量更高的代码　14
Erlang里变量不可变最大的好处利于多核编程，因为Erlang不像C或Java，它没有mutable state，所以没有shared memory，没有锁  
2.7　浮点数　15
类似于Ruby的浮点数 
2.8　原子　16
Atom用来表示非数字常量，它类似于C或Java里的枚举类型 
Atom以小写字母开始，后面接字母、下划线或@符 
Atom也可以用单引号括起来，这样就可以使用大写字母开头或带空格等的Atom 
Atom有点类似Ruby里的Symbol  
2.9　元组　17
2.9.1　创建元组　18
2.9.2　从元组中提取字段值　18
Tuple用来将一些元素分组，它使用大括号将元素括起来，并用逗号隔开 
Tuple类似于C里的structs，但Tuple是匿名的，而且Tuple里的fields没有名字 
Tuple里的items可以为任何类型，Tuple可以嵌套 
推荐做法是Tuple的第一个元素为一个Atom，这样可以清楚的描述该Tuple  
可以用匿名变量“_”作为占位符放在不想取值的地方
2.10　列表　19
2.10.1　术语　20
2.10.2　定义列表　20
2.10.3　从列表中提取元素　20
 List用来存放多个元素，它用中括号将元素括起来，并用逗号隔开 
List左边第一个元素我们称为head，剩下的元素组成的List称为tail 
例如对[1,2,3,4,5]，head为1，tail为[2,3,4,5] 
如果T为一个List，则[H|T]也是一个List，head为H，tail为T
2.11　字符串　21
Erlang里字符串必需用双引号括起来 
Erlang的字符串使用Latin-1(ISO-8859-1)字符集  
2.12　再论模式匹配　22

第3章　顺序型编程　24
3.1　模块　24
3.2　购物系统——进阶篇　28
3.3　同名不同目的函数　31
函数重载 
3.4　fun　31
匿名函数 
3.4.1　以fun为参数的函数　32
3.4.2　返回fun的函数　33
3.4.3　定义你自己的抽象流程控制　34
module用来声明本module名 
export用来导出本module的公开方法 
import用来导入其它module的公开方法  
3.5　简单的列表处理　35
3.6　列表解析　38
3.6.1　快速排序　39
3.6.2　毕达哥拉斯三元组　40
3.6.3　变位词　40
3.7　算术表达式　41
Op           Argument Type Priority  
+X               Number       1  
-X               Number       1  
X*Y              Number       2  
X/Y              Number       2  
bnot X           Integer      2  
X div Y          Integer      2  
X rem Y          Integer      2  
X band Y         Integer      2  
X+Y              Number       3  
X-Y              Number       3  
X bor Y          Integer      3  
X bxor Y         Integer      3  
X bsl N          Integer      3  
X bsr N          Integer      3  

3.8　断言　41
Guard是Erlang里的的一种表达式，关键字为when  
3.8.1　断言序列　42
Guard Sequence是一个或多个Guard，用“;”隔开 
G1;G2;...;Gn中至少有一个Guard为true的话则这个Guard Sequence为true 

Guard是一个或多个Guard表达式，用“,”隔开 
GuardExpr1,GuardExpr2,...,GuardExprN中所有Guard表达式都为true时为true 

合法的Guard表达式: 
1，The atom true 
2，Other constants(terms and bound variables)，all evaluate to false 
3，Calls to the guard predicates and to the BIFs 
4，Term comparisons 
5, Arithmetic expressions 
6, Boolean expressions 
7, Short-circuit boolean expressions  

3.8.2　断言样例　43
is_atom(X)  
is_binary(X)  
is_constant(X)  
is_float(X)  
is_function(X)  
is_function(X, N)  
is_integer(X)  
is_list(X)  
is_number(X)  
is_pid(X)  
is_port(X)  
is_reference(X)  
is_tuple(X)  
is_record(X, Tag)  
is_record(X, Tag, N)  
3.8.3　true断言的使用　44
if  
    Guard -&amp;gt; Expressions;  
    Guard -&amp;gt; Expressions;  
    ...  
    true -&amp;gt; Expressions  
end

abs(X)  
element(N, X)  
float(X)  
hd(X)  
length(X)  
node()  
node(X)  
round(X)  
self()  
size(X)  
trunc(X)  
tl(X)  
3.8.4　过时的断言函数　44
3.9　记录　44
Record用来给Tuple的元素起名字
-record(todo, {status=reminder, who=joe,text}).  
3.9.1　创建和更新记录　45
2&amp;gt; X=#todo{}.  
#todo{status = reminder, who = joe, text = undefined}  
3&amp;gt; X1=#todo{status=urgent, text=&quot;Fix errata in book&quot;}.  
#todo{status = urgent, who = joe, text = &quot;Fix errata in book&quot;}  
4&amp;gt; X2=X1#todo{status=done}.  
#todo{status = done, who = joe, text = &quot;Fix errata in book&quot;}  
5&amp;gt; #todo{who=W, text=Txt} = X2.  
#todo{status = done, who = joe, text = &quot;Fix errata in book&quot;}  
6&amp;gt; W.  
joe  
7&amp;gt; Txt.  
&quot;Fix errata in book&quot;  
8&amp;gt; X2#todo.text.  
&quot;Fix errata in book&quot;  
3.9.2　从记录中提取字段值　45
3.9.3　在函数中对记录进行模式匹配　46
3.9.4　记录只是元组的伪装　46
Record的filed可以有默认值 
Record定义可以在Erlang源代码里或者放在外部.hrl文件里并被Erlang源代码所引入 
我们可以在Eshell里使用rr()方法来读取Record定义 

1&amp;gt; X.  
#todo{status = done, who = joe, text = &quot;Fix errata in book&quot;}  
2&amp;gt; rf(todo).  
ok  
3&amp;gt; X.  
{todo, done, joe, &quot;Fix errata in book&quot;}  

3.10　case/if表达式　46
3.10.1　case表达式　47
case Expression of  
    Pattern1 [when Guard1] -&amp;gt; Expr_seq1;  
    Pattern2 [when Guard2] -&amp;gt; Expr_seq2;  
    ...  
end  
3.10.2　if表达式　47
if  
    Guard1 -&amp;gt;  
        Expr_seq1;  
    Guard2 -&amp;gt;  
        Expr_seq2;  
    ...  
end
3.11　以自然顺序创建列表　48
3.12　累加器　48

第4章　异常　50
4.1　异常　50
4.2　抛出异常　51
4.3　try...catch　51
4.3.1　缩减版本　53
4.3.2　使用try...catch的编程惯例　53
4.4　catch　54
4.5　改进错误信息　55
4.6　try...catch的编程风格　55
4.6.1　经常会返回错误的程序　55
4.6.2　出错几率比较小的程序　56
4.7　捕获所有可能的异常　56
4.8　新老两种异常处理风格　56
4.9　栈跟踪　57
try FuncOrExpressionSequence of  
  Pattern1 [when Guard1] -&amp;gt; Expressions1;  
  Pattern2 [when Guard2] -&amp;gt; Expressions2;  
  ...  
catch  
  ExceptionType: ExPattern1 [when ExGuard1] -&amp;gt; ExExpressions1;  
  ExceptionType: ExPattern2 [when ExGuard2] -&amp;gt; ExExpressions2;  
  ...  
after  
  AfterExpressions  
end 
try FuncOrExpressionSequence of
  Pattern1 [when Guard1] -&amp;gt; Expressions1;
  Pattern2 [when Guard2] -&amp;gt; Expressions2;
  ...
catch
  ExceptionType: ExPattern1 [when ExGuard1] -&amp;gt; ExExpressions1;
  ExceptionType: ExPattern2 [when ExGuard2] -&amp;gt; ExExpressions2;
  ...
after
  AfterExpressions
end

exit(Why)  
throw(Why)  
erlang:error(Why)  
erlang:get_stacktrace()  

第5章　顺序型编程进阶　58
5.1　BIF　58
所有的BIFs都属于erlang module，如erlang:tuple_to_list()、erlang:time()，但是大部分BIFs都auto-imported了，所以可以直接调用tuple_to_list()、time() 
erlang module的所有BIFs列表见:http://www.erlang.org/doc/man/erlang.html  
5.2　二进制数据　58
@spec list_to_binary(loList) -&amp;gt; binary()  
@spec split_binary(Bin, Pos) -&amp;gt; {Bin1, Bin2}  
@spec term_to_binary(Term) -&amp;gt; Bin  
@spec binary_to_term(Bin) -&amp;gt; Term  
@spec size(Bin) -&amp;gt; Int
5.3　比特语法　60
5.3.1　16bit色彩的封包与解包　60
5.3.2　比特语法表达式　61
5.3.3　高级比特语法样例　62
5.4　小问题集锦　67
5.4.1　apply　68
5.4.2　属性　68
-module(modname).  
-import(Mod, [Name1/Arity1, Name2/Arity2,...]).  
-export([Name1/Arity1, Name2/Arity2,...]).  
-compile(Options).  
-vsn(Version).  
5.4.3　块表达式　71
5.4.4　布尔类型　71
5.4.5　布尔表达式　72
1&amp;gt; not true.  
false.  
2&amp;gt; true and flase.  
false.  
3&amp;gt; true or false.  
true  
4&amp;gt; true xor false.  
true  
5.4.6　字符集　72
Erlang源代码按ISO-8859-1(Latin-1)编码处理 
Erlang内部没有字符数据类型，字符串事实上并不存在而是由整数列表来表示 
Erlang对Unicode解析有限，因为整数列表有限 
5.4.7　注释　72
Erlang里的代码注释以%开始，为单行注释  
5.4.8　epp　73
在Erlang模块编译之前，Erlang的预处理器epp先处理它 
epp会扩展源代码里的macros并插入必要的头文件 
可以使用命令cmopile:file(M, [&#39;P&#39;])来编译M.erl并将结果输出到M.P文件里  
5.4.9　转义符　73
\b                     Backspace                  8  
\d                     Delete                     127  
\e                     Escape                     27  
\f                     Form feed                  12  
\n                     New line                   10  
\r                     Carriage return            13  
\s                     Space                      32  
\t                     Tab                        9  
\v                     Vertical tab               11  
\NNN \NN \N            Octal characters(N is 0..7)  
\^a..\^z or \^A..\^Z   Ctrl+A to Ctrl+Z           1 to 26  
\&#39;                     Single quote               39  
\&quot;                     Double quote               34  
\\                     Backslash                  92  
\C                     The ASCII code for C       An integer
5.4.10　表达式和表达式序列　74
5.4.11　函数引用　74 
5.4.12　包含文件　75
Erlang里被引入的文件的扩展名为.hrl 
-include(Filename).  
-include_lib(&quot;kernel/include/file.hrl&quot;).
5.4.13　列表操作符++和——　75
5.4.14　宏　76
-define(Constant, Replacement).  
-define(Func(Var1, Var2, .. , Var), Replacement).

当遇到形如?MacroName的表达式时Macros会被epp扩展
-define(macro1(X, Y), {a, X, Y}).  

foo(A) -&amp;gt;  
    ?macro1(A+10, b)

?FILE 当前文件名  
?MODULE 当前module名  
?LINE 当前行数 

-define(Macro).  
-undef(Macro).  
-ifdef(Macro).  
-ifndef(Macro).  
-else.  
-endif.

5.4.15　在模式中使用匹配操作符　77
5.4.16　数值类型　78
5.4.17　操作符优先级　79
5.4.18　进程字典　79
1&amp;gt; erase().  
[]  
2&amp;gt; put(x, 20).  
undefined  
3&amp;gt; get(x).  
20  
4&amp;gt; get().  
[{x, 20}]  
5&amp;gt; erase(x).  
20  
6&amp;gt; get(x).  
undefined  
5.4.19　引用　80
5.4.20　短路布尔表达式　80
Expr1 orelse Expr2  
Expr1 andalso Expr2
5.4.21　比较表达式　81
X &amp;gt; Y  
X &amp;lt; Y  
X =&amp;lt; Y  
X &amp;gt;= Y  
X == Y  
X /= Y  
X =:= Y  
X =/= Y  
5.4.22　下划线变量　82
_ 匿名变量 
第6章　编译并运行程序　83
6.1　开启和停止Erlang shell　83
6.2　配置开发环境　84
6.2.1　为文件加载器设定搜索路径　84
6.2.2　在系统启动时批量执行命令　85
6.3　运行程序的几种不同方法　86
6.3.1　在Erlang shell中编译运行　86
6.3.2　在命令提示符下编译运行　86
6.3.3　把程序当作escript脚本运行　88
6.3.4　用命令行参数编程　89
6.4　使用makefile进行自动编译　90
6.4.1　makefile模板　90
6.4.2　定制makefile模板　92
6.5　在Erlang shell中的命令编辑　93
6.6　解决系统死锁　93
6.7　如何应对故障　93
6.7.1　未定义/遗失代码　94
6.7.2　makefile不能工作　94
6.7.3　shell没有响应　95
6.8　获取帮助　96
6.9　调试环境　96
6.10　崩溃转储　97
启动和停止Eshell

   $ erl  
   1&amp;gt; halt().  

$ erl

1&amp;gt; halt().



查看/添加代码查找路径
code:get_path().
code:add_patha(Dir).
code:add_pathz(Dir).

erl -pa Dir1 -pa Dir2 ... -pz DirK1 -pz DirK2


查看载入的module和查看出错的module
code:all_loaded().
code:clash().

可以将code:add_patha()和code:add_pathz()扔到.erlang文件

运行Erl程序的几种方式:
hello.erl
  -module(hello).  
  -export([start/0]).  

  start() -&amp;gt;  
      io:format(&quot;Hello world~n&quot;).  

  %%%%%%%%%%%%%  
  $ erl  
  1&amp;gt; c(hello).  
  2&amp;gt; hello:start().  
  %%%%%%%%%%%%%  
  $ erlc hello.erl  
  $ erl -noshell -s hello start -s init stop  

-module(hello).
-export([start/0]).

start() -&amp;gt;
    io:format(&quot;Hello world~n&quot;).

%%%%%%%%%%%%%
$ erl
1&amp;gt; c(hello).
2&amp;gt; hello:start().
%%%%%%%%%%%%%
$ erlc hello.erl
$ erl -noshell -s hello start -s init stop



Quick Scripting
erl -eval &#39;io:format(&quot;Memory: ~p~n&quot;, [erlang:memory(total)]).&#39; -noshell -s init stop


hello.sh
#!/bin/sh
erl -noshell -pa /home/joe/code -s hello start -s init stop

接受命令行参数
-module(main).
-export([main/1]).

fac(0) -&amp;gt; 1;
fac(N) -&amp;gt; N*fac(N-1).

main([A]) -&amp;gt;
  I = list_to_integer(atom_to_list(A)),
  F = fac(I),
  io:format(&quot;factorial ~w = ~w~n&quot;, [I, F]),
  init:stop().

%%%%%%%%%%%%
$ erlc main.erl
$ erl -noshell -s main main 25
factorial 25 = 15511210043330985984000000



使用Makefile构建Erl程序

% Makefile.template
# leave these lines alone
.SUFFIXED: .erl .beam .yrl

.erl.beam:
  erlc -W $&amp;lt;

.yrl.erl:
  erlc -W $&amp;lt;

ERL = erl -boot start_clean

# Here&#39;s a list of the erlang modules you want compiling
# If the modules don&#39;t fit onto one line add a \ character
# to the end of the lien and continue on the next line

# Edit the lines below
MODS = module1 module2 \
       module3 ... special1 ...\
       ...
       moduleN

# The first target in any makefile is the default target.
# If you just type &quot;make&quot; then &quot;make all&quot; is assumed (because
# &quot;all&quot; is the first target in this makefile)

all: compile

compile: ${MODS:%=%.beam} subdirs

## special compilation requirements are added here

special1.beam: special1.erl
  ${ERL} -Dflag1 -WO special1.erl

## run an application from the makefile

application1: compile
  ${ERL} -pa Dir1 -s application1 start Arg1 Arg2

# the subdirs target compiles any code in
# sub-directories

subdirs:
  cd dir1; make
  cd dir2; make
  ...

# remove all the code

clean:
  rm -rf *.beam erl_crash.dump
  cd dir1; make clean
  cd dir2; make clean


Getting Help
$ erl -man lists

如果Erlang crash掉了，它会生成一个erl_crash.dump文件，有一个基于Web的crash分析工具
   1&amp;gt; webtool:start().


第7章　并发　98
1. Erlang程序由许多进程组成，这些进程可以相互发送消息
2. 这些消息可能接收并理解也可能不接收不理解，如果你希望消息被接收并理解，你必须等待应答
3. 进程组可以连在一起，如果一组进程中的一个死掉，则该组的其他进程会收到一个说明那个进程为啥死掉的消息
第8章  并发编程　101
8.1　并发原语　101
1.创建和销毁进程非常快
2.进程间发送消息非常快
3.在所有的操作系统间进程行为一致
4.可以有大量的进程
5.进程不共享内存并且完全独立
6.与进程交互的唯一途径是发送消息  
8.2　一个简单的例子　102
Pid = spawn(Fun)  

Pid!Message  

receive  

  Pattern1 [when Guard1] -&amp;gt;  
    Expressions1;  
  Pattern2 [when Guard2] -&amp;gt;  
    Expressions2;  
  ...  
  after Time -&amp;gt;  
    Expressions  
end 
8.3　客户/服务器介绍　103
8.4　创建一个进程需要花费多少时间　107
8.5　带超时的receive　109
8.5.1　只有超时的receive　109
8.5.2　超时时间为0的receive　109
sleep(T) -&amp;gt;  
  receive  
  after T -&amp;gt;  
    true  
  end. 
8.5.3　使用一个无限等待超时进行接收　110
8.5.4　实现一个计时器　110
8.6　选择性接收　111
每个进程都有一个mailbox 
发送消息到该进程时，消息被放入mailbox 
当程序运行到receive语句时，启动一个timer 
读取mailbox中的第一条消息，匹配Pattern1，2，...，如果消息匹配了，则从mailbox中删除掉，并执行该Pattern后的表达式 
如果receive语句中没有匹配的Pattern，则将该消息从mailbox中删除并放入save queue，然后下一条消息进来匹配 
如果mailbox中没有一条消息是匹配成功的，则进程suspend并等待下一次新的消息进来，下次有新消息时save queue里的消息不会再匹配 
一旦有消息匹配，则已经放入save queue的消息按到达进程的顺序重新进入mailbox，如果设置了timer，则清空save queue 
如果在等待消息时timer到点，则执行ExpressionsTimeout表达式并将保存的消息按到达进程的顺序放入mailbox  
8.7　注册进程　112
register(AnAtom, Pid)  
unregister(AnAtom)  
whereis(AnAtom) -&amp;gt; Pid | undefined  
registered() -&amp;gt; [AnAtom::atom()]
8.8　如何编写一个并发程序　113
-module(ctemplate).  
-compile(export_all).  

start() -&amp;gt;  
  spawn(fun() -&amp;gt; loop([]) end).  

rpc(Pid, Request) -&amp;gt;  
  Pid ! {self(), Request},  
  receive  
    {Pid, Response} -&amp;gt;  
      Response  
  end.  

loop(X) -&amp;gt;  
  receive  
    Any -&amp;gt;  
      io:format(&quot;Received:~p~n&quot;, [Any]),  
      loop(X)  
  end.  
8.9　尾递归技术　114
在loop里receive之后马上又调用loop，则loop称为tail-recursive方法 
如果我们写一个方法F，F never returns，则需要确保在调用F之后不会调用其他方法，也不要将F用于List或Tuple的constructor，否则内存溢出 
8.10　使用MFA启动进程　115
spawn(Mod, FuncName, Args)
 使用Mod名、Func名和Args列表(成为一个MFA)来显式的调用spawn是确保系统动态加载代码(热修改)的正确方式 
spawn with funs则不会动态加载代码
8.11　习题　115

第9章　并发编程中的错误处理　116
9.1　链接进程　116
使用BIF link将两个节点连接起来，如果其中一个节点B退出，则另一个节点A会收到{&#39;EXIT&#39;, B, Why}的信号
9.2　on_exit处理程序　117
可以创建一个on_exit(Pid, Fun)方法来捕获某个Pid进程的死掉:  
on_exit(Pid, Fun) -&amp;gt;  
  spawn(fun() -&amp;gt;  
      process_flag(trap_exit, true),  
      link(Pid),  
      receive  
        {&#39;EXIT&#39;, Pid, Why} -&amp;gt;  
          Fun(Why)  
      end  
    end).  

9.3　远程错误处理　118
Erlang可以远程捕获和处理错误(跨机器) 
9.4　错误处理的细节　118
调用BIF process_flag(trap_exit, true)来将一个正常的进程转换为一个可以trap exits的系统进程   
9.4.1　捕获退出的编程模式　119
Pid = spawn(fun() -&amp;gt; ... end)   % 不关联 I Don&#39;t Care If a Process I Created Crashes
Pid = spawn_link(fun() -&amp;gt; ... end)  % 关联 I Want to Die If a Process I Created Crashes
%I Want to Handle Errors If a Process I Create Crashes
...  
process_flag(trap_exit, true),  
Pid = spawn_link(fun() -&amp;gt; ... end),  
...  
loop(...).  

loop(State) -&amp;gt;  
  receive  
    {&#39;EXIT&#39;, SomePid, Reason} -&amp;gt;  
      %% do something with the error  
      loop(State1);  
    ...  
  end  
9.4.2　捕获退出信号(进阶篇)　120
9.5　错误处理原语　125
9.6　链接进程集　126
@spec spawn_link(Fun) -&amp;gt; Pid  
@spec process_flag(trap_exit, true)
@spec link(Pid) -&amp;gt; true  
@spec unlink(Pid) -&amp;gt; true  
@spec exit(Why) -&amp;gt; none()  
@spec exit(Pid, Why) -&amp;gt; true  
@spec erlang:monitor(process, Item) -&amp;gt; MonitorRef 
9.7　监视器　126
9.8　存活进程　127

第10章　分布式编程　128
10.1　名字服务　129
10.1.1　第一步：一个简单的名字服务　130
10.1.2　第二步：在同一台机器上，客户端运行于一个节点而服务器运行于第二个节点　131
10.1.3　第三步：让客户机和服务器运行于同一个局域网内的不同机器上　132
10.1.4　第四步：在因特网上的不同主机上分别运行客户机和服务器　133
10.2　分布式原语　134
10.3　分布式编程中使用的库　136
10.4　有cookie保护的系统　136
10.5　基于套接字的分布式模式　137
10.5.1　lib_chan　137
10.5.2　服务器代码　138
分布式程序指设计用于运行在网络中的可以通过消息传递相互交流彼此的活动的计算机上的程序

分布式应用的好处:Performance、Reliability、Scalability、Intrinsically distributed application、Fun

1. key-value server的简单例子:

-module(kvs).
-export([start/0, store/2, lookup/1]).

start() -&amp;gt; register(kvs, spawn(fun() -&amp;gt; loop() end)).

store(Key, Value) -&amp;gt; rpc({store, Key, Value}).

lookup(Key) -&amp;gt; rpc({lookup, Key}).

rpc(Q) -&amp;gt;
    kvs ! {self(), Q},
    receive
    {kvs, Reply} -&amp;gt;
        Reply
    end.

loop() -&amp;gt;
    receive
    {From, {store, Key, Value}} -&amp;gt;
        put(Key, {ok, Value}),
        From ! {kvs, true},
        loop();
    {From, {lookup, Key}} -&amp;gt;
        From ! {kvs, get(Key)},
        loop()
    end.
%%%%%%%%%
1&amp;gt; kvs:start().
true
2&amp;gt; kvs:store({location, joe}, &quot;Stockholm&quot;).
true
3&amp;gt; kvs:store(weather, raining).
true
4&amp;gt; kvs:lookup(weather).
{ok,raining}
5&amp;gt; kvs:lookup({location, joe}).
{ok,&quot;Stockhom&quot;}
6&amp;gt; kvs:lookup({location, jane}).
undefined

2. 同一机器上Client-Server的key-value server例子:
$ erl -sname gandalf
(gandalf@loalhost) 1&amp;gt; kvs:start().
true

$ erl -sname bilbo
(bilbo@localhost) 1&amp;gt; rpc:call(gandalf@localhost, kvs, store, [weather, fine]).
true
(bilbo@localhost) 2&amp;gt; rpc:call(gandalf@localhost, kvs, lookup, [weather]).
{ok,fine}

(gandalf@loalhost) 2&amp;gt; kvs:lookup(weather).
{ok, fine}

3, 局域网内不同机器做Client-Server的key-value server例子:
doris $ erl -name gandalf -setcookie abc
(gandalf@doris.myerl.example.com) 1&amp;gt; kvs:start().
true

george $ erl -name bilbo -setcookie abc
(bilbo@george.myerl.example.com) 1&amp;gt; rpc:call(gandalf@doris.myerl.example.com, kvs, store, [weather, cold]).
true
(bilbo@george.myerl.example.com) 2&amp;gt; rpc:call(gandalf@doris.myerl.example.com, kvs, lookup, [weather]).
{ok, cold}

4, Internet上不同主机的Client-Server的key-value server的例子:
1)确保4369端口对TCP和UDP都开放，epmd(Erlang Port Mapper Daemon)这个程序需要使用该端口
2)如果想使用的端口为Min和Max，则确保这些端口也是打开的

$ erl -name ... -setcookie ... -kernel inet_dist_listen_min Min \
                                       inet_dist_listen_max Max


Distribution Primitives

@spec spawn(Node, Fun) -&amp;gt; Pid
@spec spawn(Node, Mod, Func, ArgList) -&amp;gt; Pid
@spec spawn_link(Node, Fun) -&amp;gt; Pid
@spec spawn_link(Node, Mod, Func, ArgList) -&amp;gt; Pid
@spec disconnect_node(Node) -&amp;gt; bool() | ignored
@spec monitor_node(Node, Flag) -&amp;gt; true
@spec node() -&amp;gt; Node
@spec node(Arg) -&amp;gt; Node
@spec nodes() -&amp;gt; [Node]
@spec is_alive() -&amp;gt; bool()
{RegName, Node} ! Msg

远程Spawning

-module(dist_demo).
-export([rpc/4, start/1]).

start(Node) -&amp;gt;
  spawn(Node, fun() -&amp;gt; loop() end).

rpc(Pid, M, F, A) -&amp;gt;
  Pid ! {rpc, self(), M, F, A},
  receive
    {Pid, Response} -&amp;gt;
      Response
  end.

loop() -&amp;gt;
  receive
    {rpc, Pid, M, F, A} -&amp;gt;
      Pid ! {self(), (catch apply(M, F, A))},
      loop()
  end.
%%%%%%%%%%%%
doris $ erl -name gandalf -setcookie abc
(gandalf@doris.myeerl.example.com) 1&amp;gt;

george $ erl -name bilbo -setcookie abc
(bilbo@george.myerl.example.com) 1&amp;gt;

(bilbo@george.myerl.example.com) 1&amp;gt; Pid = dist_demo:start(&#39;gandalf@doris.myerl.example.com&#39;).
&amp;lt;5094.40.0&amp;gt;

(bilbo@george.myerl.example.com) 1&amp;gt; dist_demo:rpc(Pid, erlang, node, []).
&#39;gandalf@doris.myerl.example.com&#39;



一般写分布式程序时不会直接用这些BIFs，而是使用一些封装好的libraries
rpc
global


rpc模块里最常用的方法是:
call(Node, Mod, Function, Args) -&amp;gt; Result|{badrpc, Reason}



对于分布式Erlang节点，它们必须使用cookie
cookie不会跨网络发送，而是仅仅用于初始化session认证
有三种设置cookie的方式:
1，在$HOME/.erlang.cookie文件里写入，然后chmod 400 .erlang.cookie只允许文件所有者访问
2，$ erl -setcookie AFRTY12ESS...，不安全，ps命令可以看到
3，erlang:set_cookie(node(), C)

分布式Erlang的主要问题是不安全，client可以在server机器上spawn任意进程，下面的调用会摧毁系统:
rpc:multicall(nodes(), os, cmd, [&quot;cd /; rm -rf *&quot;])


所以我们需要给出一定的限制，比如认证机制，lib_chan就是一个控制访问的库(作者自己在本书代码中写的一个库)
@spec start_server() -&amp;gt; true
配置文件默认为$HOME/.erlang/lib_chan.conf
@spec start_server(Conf) -&amp;gt; true
配置文件:
{port, NNNN}
{service,S,password,P,mfa,SomeMod,SomeFunc,SomeArgsS}

@spec connect(Host,Port,S,P,ArgsC) -&amp;gt; {ok, Pid} | {error, Whay}



例如如下配置文件
{port, 1234}.
{service, nameServer, password, &quot;ABXy45&quot;, mfa, mod_name_server, start_me_up, notUsed}.



mod_name_server.erl
-module(mod_name_server).
-export([start_me_up/3]).

start_me_up(MM, _ArgsC, _ArgS) -&amp;gt;
  loop(MM).

loop(MM) -&amp;gt;
  receive
    {chan, MM, {store, K, V}} -&amp;gt;
      kvs:store(K, V),
      loop(MM);
    {chan, MM, {lookup, k}} -&amp;gt;
      MM ! {send, kvs:lookup(K)},
      loop(MM);
    {chan_closed, MM} -&amp;gt;
      true
  end.



试试:
   1. 起一个Erlang session作为server  
   2. 1&amp;gt; kvs:start().  
   3. true  
   4. 2&amp;gt; lib_chan:start_server().  
   5. Starting a port server on 1234...  
   6. true  
   7.   
   8. 另起一个Erlang session作为client  
   9. 1&amp;gt; {ok, Pid} = lib_chan:connect(&quot;localhost&quot;, 1234, nameServer, &quot;ABXy45&quot;, &quot;&quot;).  
  10. {ok, &amp;lt;0.43.0&amp;gt;}  
  11. 2&amp;gt; lib_chan:cast(Pid, {store, joe, &quot;writing a book&quot;}).  
  12. {send,{store,joe,&quot;writing a book&quot;}}  
  13. 3&amp;gt; lib_chan:rpc(Pid, {lookup, joe}).  
  14. {ok, &quot;writing a book&quot;}  
  15. 4&amp;gt; lib_chan:rpc( Pid, {lookup, jim}).  
  16. undefined 


change_group      Change group of a file.
change_owner      Change owner of a file.
change_time      Change the modification or last access time of a file.
close      Close a file.
consult      Read Erlang terms from a file.
copy      Copy file contents.
del_dir      Delete a directory.
delete      Delete a file.
eval      Evaluate Erlang expressions in a file.
format_error      Return a descriptive string for an error reason.
get_cwd      Get the current working directory.
list_dir      List files in a directory.
make_dir      Make a directory.
make_link      Make a hard link to a file.
make_symlink      Make a symbolic link to a file or directory.
open      Open a file.
position      Set position in a file.
pread      Read from a file at a certain position.
pwrite      Write to a file at a certain position.
read      Read from a file.
read_file      Read an entire file.
read_file_info      Get information about a file.
read_link      See what a link is pointing to.
read_link_info      Get information about a link or file.
rename      Rename a file.
script      Evaluate and return the value of Erlang expressions in a file.
set_cwd      Set the current working directory.
sync      Synchronize the in-memory state of a file with that on the physical medium.
truncate      Truncate a file.
write      Write to a file.
write_file      Write an entire file.
write_file_info      Change information about a file.

第14章　套接字编程　189
14.1　使用TCP　189
14.1.1　从服务器上获取数据　189
14.1.2　一个简单的TCP服务器　192
14.1.3　改进服务器　195
14.1.4　注意　196
14.2　控制逻辑　197
14.2.1　主动型消息接收(非阻塞)　197
14.2.2　被动型消息接收(阻塞)　198
14.2.3　混合型模式(半阻塞)　198
14.3　连接从何而来　199
14.4　套接字的出错处理　199
-module(socket_examples).
-compile(export_all).
-import(lists, [reverse/1]).

nano_get_url() -&amp;gt;
  nano_get_url(&quot;www.google.com&quot;).

nano_get_url(Host) -&amp;gt;
  {ok, Socket} = gen_tcp:connect(Host, 80, [binary, {packet, 0}]),
  ok = gen_tcp:send(Socket, &quot;GET / HTTP/1.0\r\n\r\n&quot;),
  receive_data(Socket, []).

receive_data(Socket, SoFar) -&amp;gt;
  receive
    {tcp, Socket, Bin} -&amp;gt;
      receive_data(Socket, [Bin|SoFar]);
    {tcp_closed, Socket} -&amp;gt;
      list_to_binary(reverse(SoFar))
  end.

start_nano_server() -&amp;gt;
  {ok, Listen} = gen_tcp:listen(2345, [binary, {packet, 4},
                                       {reuseaddr, true},
                                       {active, true}]),
  {ok, Socket} = gen_tcp:accept(Listen),
  gen_tcp:close(Listen),
  loop(Socket).

loop(Socket) -&amp;gt;
  receive
    {tcp, Socket, Bin} -&amp;gt;
      io:format(&quot;Server received binary = ~p~n&quot;, [Bin]),
      Str = binary_to_term(Bin),
      io:format(&quot;Server (unpacked) ~p~n&quot;, [Str]),
      Reply = string2value(Str),
      io:format(&quot;Server replying = ~p~n&quot;, [Reply]),
      gen_tcp:send(Socket, term_to_binary(Reply)),
      loop(Socket);
    {tcp_closed, Socket} -&amp;gt;
      io:format(&quot;Server socket closed~n&quot;)
  end.

nano_client_eval(Str) -&amp;gt;
  {ok, Socket} = 
    gen_tcp:connect(&quot;localhost&quot;, 2345, [binary, {packet, 4}]),
    ok = gen_tcp:send(Socket, term_to_binary(Str)),
    receive
      {tcp, Socket, Bin} -&amp;gt;
        io:format(&quot;Client received binary = ~p~n&quot;, [Bin]),
        Val = binary_to_term(Bin),
        io:format(&quot;Client result = ~p~n&quot;, [Val]),
        gen_tcp:close(Socket)
    end.

string2value(Str) -&amp;gt;
    {ok, Tokens, _} = erl_scan:string(Str ++ &quot;.&quot;),
    {ok, Exprs} = erl_parse:parse_exprs(Tokens),
    Bindings = erl_eval:new_bindings(),
    {value, Value, _} = erl_eval:exprs(Exprs, Bindings),
    Value.

- show quoted text -
-module(ets_test).

-export([start/0]).

start() -&amp;gt;
  lists:foreach(fun test_ets/1,
    [set, ordered_set, bag, duplicate_bag]).

test_ets(Mode) -&amp;gt;
  TableId = ets:new(test, [Mode]),
  ets:insert(TableId, {a,1}),
  ets:insert(TableId, {b,2}),
  ets:insert(TableId, {a,1}),
  ets:insert(TableId, {a,3}),
  List = ets:tab2list(TableId),
  io:format(&quot;~-13w =&amp;gt; ~p~n&quot;, [Mode, List]),
  ets:delete(TableId).

- show quoted text -
%% 
%%  Excerpted from &quot;Programming Erlang&quot;,
%%  published by The Pragmatic Bookshelf.
%%  Copyrights apply to this code. It may not be used to create training material, 
%%  courses, books, articles, and the like. Contact us if you are in doubt.
%%  We make no guarantees that this code is fit for any purpose. 
%%  Visit http://www.pragmaticprogrammer.com/titles/jaerlang for more book information.
%%
-module(test_mnesia).
-import(lists, [foreach/2]).
-compile(export_all).

%% IMPORTANT: The next line must be included
%%            if we want to call qlc:q(...)

-include_lib(&quot;stdlib/include/qlc.hrl&quot;).
-record(shop, {item, quantity, cost}).
-record(cost, {name, price}).
-record(design, {id, plan}).

do_this_once() -&amp;gt;
    mnesia:create_schema([node()]),
    mnesia:start(),
    mnesia:create_table(shop,   [{attributes, record_info(fields, shop)}]),
    mnesia:create_table(cost,   [{attributes, record_info(fields, cost)}]),
    mnesia:create_table(design, [{attributes, record_info(fields, design)}]),
    mnesia:stop().

start() -&amp;gt;
    mnesia:start(),
    mnesia:wait_for_tables([shop,cost,design], 20000).

%% SQL equivalent
%%  SELECT * FROM shop;
demo(select_shop) -&amp;gt;
    do(qlc:q([X || X &amp;lt;- mnesia:table(shop)]));

%% SQL equivalent
%%  SELECT item, quantity FROM shop;
demo(select_some) -&amp;gt;
    do(qlc:q([{X#shop.item, X#shop.quantity} || X &amp;lt;- mnesia:table(shop)]));

%% SQL equivalent
%%   SELECT shop.item FROM shop
%%   WHERE  shop.quantity &amp;lt; 250;
demo(reorder) -&amp;gt;
    do(qlc:q([X#shop.item || X &amp;lt;- mnesia:table(shop),
                 X#shop.quantity &amp;lt; 250
                ]));

%% SQL equivalent
%%   SELECT shop.item, shop.quantity, cost.name, cost.price
%%   FROM shop, cost 
%%   WHERE shop.item = cost.name 
%%     AND cost.price &amp;lt; 2
%%     AND shop.quantity &amp;lt; 250
demo(join) -&amp;gt;
    do(qlc:q([X#shop.item || X &amp;lt;- mnesia:table(shop),
                 X#shop.quantity &amp;lt; 250,
                 Y &amp;lt;- mnesia:table(cost),
                 X#shop.item =:= Y#cost.name,
                 Y#cost.price &amp;lt; 2
                ])).

do(Q) -&amp;gt;
    F = fun() -&amp;gt; qlc:e(Q) end,
    {atomic, Val} = mnesia:transaction(F),
    Val.

example_tables() -&amp;gt;
    [%% The shop table
     {shop, apple,   20,   2.3},
     {shop, orange,  100,  3.8},
     {shop, pear,    200,  3.6},
     {shop, banana,  420,  4.5},
     {shop, potato,  2456, 1.2},
     %% The cost table
     {cost, apple,   1.5},
     {cost, orange,  2.4},
     {cost, pear,    2.2},
     {cost, banana,  1.5},
     {cost, potato,  0.6}
    ].

add_shop_item(Name, Quantity, Cost) -&amp;gt;
    Row = #shop{item=Name, quantity=Quantity, cost=Cost},
    F = fun() -&amp;gt;
      mnesia:write(Row)
    end,
    mnesia:transaction(F).

remove_shop_item(Item) -&amp;gt;
    Oid = {shop, Item},
    F = fun() -&amp;gt;
        mnesia:delete(Oid)
    end,
    mnesia:transaction(F).

farmer(Nwant) -&amp;gt;
    %% Nwant = Number of oranges the farmer wants to buy
    F = fun() -&amp;gt;
        %% find the number of apples
        [Apple] = mnesia:read({shop,apple}),
        Napples = Apple#shop.quantity,
        Apple1  = Apple#shop{quantity = Napples + 2*Nwant},
        %% update the database
        mnesia:write(Apple1),
        %% find the number of oranges
        [Orange] = mnesia:read({shop,orange}),
        NOranges = Orange#shop.quantity,
        if 
            NOranges &amp;gt;= Nwant -&amp;gt;
            N1 =  NOranges - Nwant,
            Orange1 = Orange#shop{quantity=N1},
            %% update the database
            mnesia:write(Orange1);
            true -&amp;gt;
            %% Oops -- not enough oranges
            mnesia:abort(oranges)
        end
    end,
    mnesia:transaction(F).

reset_tables() -&amp;gt;
    mnesia:clear_table(shop),
    mnesia:clear_table(cost),
    F = fun() -&amp;gt;
        foreach(fun mnesia:write/1, example_tables())
    end,
    mnesia:transaction(F).

add_plans() -&amp;gt;
    D1 = #design{id   = {joe,1},
         plan = {circle,10}},
    D2 = #design{id   = fred, 
         plan = {rectangle,10,5}},
    D3 = #design{id   = {jane,{house,23}},
         plan = {house,
             [{floor,1,
               [{doors,3},
                {windows,12},
                {rooms,5}]},
              {floor,2,
               [{doors,2},
                {rooms,4},
                {windows,15}]}]}},
    F = fun() -&amp;gt; 
        mnesia:write(D1),
        mnesia:write(D2),
        mnesia:write(D3)
    end,
    mnesia:transaction(F).

get_plan(PlanId) -&amp;gt;
    F = fun() -&amp;gt; mnesia:read({design, PlanId}) end,
    mnesia:transaction(F). 


第15章　ETS和DETS：大量数据的存储机制　213
15.1　表的基本操作　214
15.2　表的类型　214
15.3　ETS表的效率考虑　215
15.4　创建ETS表　216
15.5　ETS程序示例　217
15.5.1　三字索引迭代器　218
15.5.2　构造表　219
15.5.3　构造表有多快　219
15.5.4　访问表有多快　220
15.5.5　胜出的是……　220
15.6　DETS　222
15.7　我们没有提及的部分　224
15.8　代码清单　225
@spec ets:new(Name, [Opt]) -&amp;gt; TableId
    Name is an atom. [Opt] is a list of options, taken from the following:
    set | ordered_set | bag | duplicate_bag
          Create an ETS table of the given type (we talked about these
          earlier).
    private
          Create a private table. Only the owner process can read and
          write this table.
    public
          Create a public table. Any process that knows the table iden-
          tifier can read and write this table.
    protected
          Create a protected table. Any process that knows the table
          identifier can read this table, but only the owner process can
          write to the table.
    named_table
          If this is present, then Name can be used for subsequent table
          operations.
    {keypos, K}
          Use K as the key position. Normally position 1 is used for the
          key. Probably the only time when we would use this option
          is if we store an Erlang record (which is actually a disguised
          tuple), where the first element of the record contains the
          record name.
    Note: Opening an ETS table with zero options is the same as opening it
with the options [set,protected,{keypos,1}].

Create a new table or open an existing table.
     This we do with ets:new or dets:open_file.
Insert a tuple or several tuples into a table.
     Here we call insert(Tablename, X), where X is a tuple or a list of
     tuples. insert has the same arguments and works the same way in
     ETS and DETS.
Look up a tuple in a table.
     Here we call lookup(TableName, Key). The result is a list of tuples
     that match Key. lookup is defined for both ETS and DETS.
     (Why is the return value a list of tuples? If the table type is a “bag,”
     then several tuples can have the same key. We’ll look at the table
     types in the next section.)
     If no tuples in the table have the required key, then an empty list
     is returned.
Dispose of a table.
     When we’ve finished with a table, we can tell the system by calling
     dets:close(TableId) or ets:delete(TableId).

第16章　OTP概述　228
16.1　通用服务器程序的进化路线　229
16.1.1　server 1：原始服务器程序　229
16.1.2　server 2：支持事务的服务器程序　230
16.1.3　server 3：支持热代码替换的服务器程序　231
16.1.4　server 4：同时支持事务和热代码替换　233
16.1.5　server 5：压轴好戏　234
16.2　gen_server起步　236
16.2.1　第一步：确定回调模块的名称　237
16.2.2　第二步：写接口函数　237
16.2.3　第三步：编写回调函数　237
16.3　gen_server回调的结构　240
16.3.1　启动服务器程序时发生了什么　240
16.3.2　调用服务器程序时发生了什么　240
16.3.3　调用和通知　241
16.3.4　发给服务器的原生消息　241
16.3.5　Hasta la Vista, Baby(服务器的终止)　242
16.3.6　热代码替换　242
16.4　代码和模板　243
16.4.1　gen_server模板　243
16.4.2　my_bank　245
16.5　进一步深入　246
一套优秀的Erlang服务框架，利用绑定回调机制实现相关操作。 
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>Reading Note for Advanced Rails Recipes</title>
   <link href="http://www.5wpc.info/it/technical/language/ruby/2013/01/30/AdvancedRailsRecipes"/>
   <updated>2013-01-30T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/technical/language/ruby/2013/01/30/AdvancedRailsRecipes</id>
   <content type="html">&lt;h1&gt;1  Introduction&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;What Makes a Good Recipe Book?&lt;/li&gt;
&lt;li&gt;What Makes This an Advanced Recipe Book?&lt;/li&gt;
&lt;li&gt;Who’s It For?&lt;/li&gt;
&lt;li&gt;Who’s Talking?&lt;/li&gt;
&lt;li&gt;Rails Version&lt;/li&gt;
&lt;li&gt;Resources&lt;/li&gt;
&lt;li&gt;Acknowledgments&lt;/li&gt;
&lt;li&gt;Tags and Thumb tabs&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Part I—REST and Routes Recipes&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;   Putting A Resource On The Web
   利用REST提供WebAPI&lt;/li&gt;
&lt;li&gt;   Adding Your Own REST Actions (Or Not)
   添加自定义的REST&lt;/li&gt;
&lt;li&gt;   Authenticating REST Clients
   制作REST的session登录&lt;/li&gt;
&lt;li&gt;   Custom Response Formats
   自定义反馈信息格式&lt;/li&gt;
&lt;li&gt;   Catch All 404s
   捕获404错误: 做好记录工作;充分利用DB的index以提高速度&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Part II—Search Recipes&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;   Improve SEO with Dynamic Meta Tags
   通过Meta标签提高搜索引擎收录&lt;/li&gt;
&lt;li&gt;   Full-Text Search with Ferret
   利用Ferret实现DB全文搜索&lt;/li&gt;
&lt;li&gt;   Active Record on Solr
   利用solr实现全文搜索&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Part III—Database Recipes&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;   Adding Foreign Key Constraints
   添加外键关联&lt;/li&gt;
&lt;li&gt;   Write Your Own Custom Validations
   添加自定义表单验证&lt;/li&gt;
&lt;li&gt;   Analyzing SQL Queries
   分析优化SQL搜索&lt;/li&gt;
&lt;li&gt;   Taking Advantage of Master/Slave Databases
   利用主从数据库实现读写&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Part IV—User Interface Recipes&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;   Replacing In-View Raw JavaScript with RJS
   利用嵌入式的RJS替代原生态JavaScript&lt;/li&gt;
&lt;li&gt;   Handling Multiple Models In One Form
   单个表单中提交多个Model&lt;/li&gt;
&lt;li&gt;   Simplifying Controllers With a Presenter
   对于一个controller里面的多model处理:可以采用视图/混合类的方式进行处理,原理同14.另外需要充分利用method_missing, 利用人为的方式规定表单数据域格式&lt;/li&gt;
&lt;li&gt;   Validating Required Form Fields Inline
   即时表单验证&lt;/li&gt;
&lt;li&gt;   Creating a Wizard
   制作步骤导航&lt;/li&gt;
&lt;li&gt;   Updating # Partial Resources with Ajax
   局部Ajax更新&lt;/li&gt;
&lt;li&gt;   Uploading Images and Creating Thumbnails
   Ajax上传图片&lt;/li&gt;
&lt;li&gt;   Decouple Your JavaScript with Low Pro
   简化javascript&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Part V—Design Recipes&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;   Freshening Up Your Models With Scope
   利用with scope简化Model&lt;/li&gt;
&lt;li&gt;   Keeping Forms Dry and Flexible
   通过自定义的FormBuilder来DRY表单模板&lt;/li&gt;
&lt;li&gt;   Prevent Train Wrecks with Delegate
   利用委派机制将火车式的调用简单化&lt;/li&gt;
&lt;li&gt;   Creating Meaningful Relationships Through Proxies
   将Model间的关系语义化&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Part VI—Asynchronous Recipes&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;   Processing an Asynchronous Workflow
   处理异步工作流&lt;/li&gt;
&lt;li&gt;   Off-Loading Long-Running Tasks to BackgrounDRb
   将长时间任务处理放到后台&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Part VII—E-mail Recipes&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;   Validating E-mail Addresses
   验证Email格式&lt;/li&gt;
&lt;li&gt;   Receiving E-mail Reliably via POP or IMAP
   通过POP/IMAP收取邮件&lt;/li&gt;
&lt;li&gt;   Keeping E-mail Addresses Up To Date
   保证Email地址有效&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Part VIII—Console Snacks&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;   Writin’ Console Methods
   利用console&lt;/li&gt;
&lt;li&gt;   Console Loggin’
   Console日志&lt;/li&gt;
&lt;li&gt;   Playin’ in the Sandbox
   利用sandbox使console的操作最后对DB无效&lt;/li&gt;
&lt;li&gt;   Accessin’ Helpers
   利用Console查看helper效果&lt;/li&gt;
&lt;li&gt;   Shortcuttin’ the Console
   console快捷键&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Part IX—Testing&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;   Creating Your Own Rake Test Tasks
   创建自己的Rake 测试任务&lt;/li&gt;
&lt;li&gt;   Testing JavaScript With Selenium
   利用selenium测试JS&lt;/li&gt;
&lt;li&gt;   Mocking With a Safety Net
   在安全的网络里测试&lt;/li&gt;
&lt;li&gt;   Getting Started with BDD
   BDD&lt;/li&gt;
&lt;li&gt;   Describing Behaviour from the Outside-In With RSpec
   RSpec描述行为&lt;/li&gt;
&lt;li&gt;   Reducing Dependencies with Mocks
   消除Mock中的依赖&lt;/li&gt;
&lt;li&gt;   Fixtures Without Frustration
   测试数据有效&lt;/li&gt;
&lt;li&gt;   Tracking Test Coverage with RCov
   利用RCov检测测试覆盖率&lt;/li&gt;
&lt;li&gt;   Testing HTML Validity
   检测HTML合法性&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Part X—Performance and Scalability Recipes&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;   Looking Up Constant Data
   制作常量数据&lt;/li&gt;
&lt;li&gt;   Serving Page Caches to Facebook
   制作缓存&lt;/li&gt;
&lt;li&gt;   Profiling In The Browser
   在Browser中检测性能&lt;/li&gt;
&lt;li&gt;   Caching Up With the Big Guys
   追踪性能问题根源&lt;/li&gt;
&lt;li&gt;   Dynamically Updating Cached Pages
   动态更新Cache&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Part XI—Security Recipes&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;   Flipping On SSL
   利用SSL&lt;/li&gt;
&lt;li&gt;   Locking Down Sensitive Data
   控制敏感数据&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Part XII—Deployment and Capistrano Recipes&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;   Custom Maintenance Pages&lt;/li&gt;
&lt;li&gt;   Running Multi-Stage Deployments&lt;/li&gt;
&lt;li&gt;   Creating New Environments&lt;/li&gt;
&lt;li&gt;   Managing Plugin Versions&lt;/li&gt;
&lt;li&gt;   Safeguarding the Launch Codes&lt;/li&gt;
&lt;li&gt;   Config Files On-The-Fly&lt;/li&gt;
&lt;li&gt;   Preserving Files Between Deployments&lt;/li&gt;
&lt;li&gt;   Responding To Remote Prompts&lt;/li&gt;
&lt;li&gt;   Generating Custom Error Pages&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Part XIII—Big-Picture Recipes&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;   Avoid Starting From Scratch&lt;/li&gt;
&lt;li&gt;   Fail Early&lt;/li&gt;
&lt;li&gt;   Analyzing Your Log Files&lt;/li&gt;
&lt;li&gt;   Formatting Dates and Times&lt;/li&gt;
&lt;li&gt;   Geocoding to Find Things By Location&lt;/li&gt;
&lt;li&gt;   Giving Users Their Own Subdomain&lt;/li&gt;
&lt;li&gt;   Tunneling Back to Your Application&lt;/li&gt;
&lt;li&gt;   Monitoring (and Repairing) Processes with Monit&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;A Bibliography 288&lt;/h1&gt;

&lt;p&gt;  Index        289&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>理财BasicMethods</title>
   <link href="http://www.5wpc.info/it/project/financialmanage/2013/01/20/BasicMethods"/>
   <updated>2013-01-20T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/project/financialmanage/2013/01/20/BasicMethods</id>
   <content type="html">&lt;h1&gt;理财BasicMethods&lt;/h1&gt;

&lt;h2&gt;理财陷阱&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;消费

&lt;ul&gt;
&lt;li&gt;现象

&lt;ul&gt;
&lt;li&gt;商场打折&lt;/li&gt;
&lt;li&gt;电视广告&lt;/li&gt;
&lt;li&gt;Email&lt;/li&gt;
&lt;li&gt;Internel&lt;/li&gt;
&lt;li&gt;讲座&lt;/li&gt;
&lt;li&gt;数码&lt;/li&gt;
&lt;li&gt;教育&lt;/li&gt;
&lt;li&gt;FindWork&lt;/li&gt;
&lt;li&gt;婚介&lt;/li&gt;
&lt;li&gt;家装&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Howto

&lt;ul&gt;
&lt;li&gt;调查研究，计划消费&lt;/li&gt;
&lt;li&gt;要以理性面对激动&lt;/li&gt;
&lt;li&gt;不要贪便宜&lt;/li&gt;
&lt;li&gt;拒绝虚荣心&lt;/li&gt;
&lt;li&gt;放弃不合实际的幻想&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;投资

&lt;ul&gt;
&lt;li&gt;现象

&lt;ul&gt;
&lt;li&gt;原始股&lt;/li&gt;
&lt;li&gt;黑基金&lt;/li&gt;
&lt;li&gt;非法集资&lt;/li&gt;
&lt;li&gt;托管造林&lt;/li&gt;
&lt;li&gt;产权酒店&lt;/li&gt;
&lt;li&gt;分时度假&lt;/li&gt;
&lt;li&gt;加盟连锁&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;特点

&lt;ul&gt;
&lt;li&gt;一夜暴富&lt;/li&gt;
&lt;li&gt;无风险，高收益&lt;/li&gt;
&lt;li&gt;迅速给你“收益”&lt;/li&gt;
&lt;li&gt;带上合法的外衣&lt;/li&gt;
&lt;li&gt;虚构有实力的形象&lt;/li&gt;
&lt;li&gt;构建“神坛”，打造“神人&quot;&lt;/li&gt;
&lt;li&gt;创新项目&lt;/li&gt;
&lt;li&gt;海外项目&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Howto

&lt;ul&gt;
&lt;li&gt;克服自身的弱点

&lt;ul&gt;
&lt;li&gt;贪婪，贪便宜&lt;/li&gt;
&lt;li&gt;企图走捷径&lt;/li&gt;
&lt;li&gt;无知&lt;/li&gt;
&lt;li&gt;从众&lt;/li&gt;
&lt;li&gt;冲动&lt;/li&gt;
&lt;li&gt;心存侥幸&lt;/li&gt;
&lt;li&gt;好了伤疤忘了疼&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;６步自问法

&lt;ul&gt;
&lt;li&gt;什么人卖给我产品？这个人有信誉吗？&lt;/li&gt;
&lt;li&gt;他拿我的钱做什么去了？有人监督资金吗？他靠什么赚钱&lt;/li&gt;
&lt;li&gt;我买到了什么？我赚钱有保证吗？&lt;/li&gt;
&lt;li&gt;投资收益合理吗&lt;/li&gt;
&lt;li&gt;我一旦不想要这个产品了，能卖出去吗？&lt;/li&gt;
&lt;li&gt;如果产品卖不出去，我能自己用吗？&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;做自己的理财师&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;分析家庭的财务状况&lt;/li&gt;
&lt;li&gt;生命周期与理财目标

&lt;ul&gt;
&lt;li&gt;青年期

&lt;ul&gt;
&lt;li&gt;单身

&lt;ul&gt;
&lt;li&gt;扩大收入来源&lt;/li&gt;
&lt;li&gt;合理投资&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;家庭与事业形成期

&lt;ul&gt;
&lt;li&gt;利用贷款买房&lt;/li&gt;
&lt;li&gt;买保障型保险&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;买房、买车、結婚、生子&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;中年期

&lt;ul&gt;
&lt;li&gt;家庭与事业成长期

&lt;ul&gt;
&lt;li&gt;还清房贷&lt;/li&gt;
&lt;li&gt;加大投资力度

&lt;ul&gt;
&lt;li&gt;特别是风险性投资&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;退休前期

&lt;ul&gt;
&lt;li&gt;减少风险性投资比重，增加安全性投资的比重&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;子女教育、养老&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;老年期

&lt;ul&gt;
&lt;li&gt;财产安排&lt;/li&gt;
&lt;li&gt;安度晚年、财产传承&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;安排理财规划

&lt;ul&gt;
&lt;li&gt;现金

&lt;ul&gt;
&lt;li&gt;活期存款&lt;/li&gt;
&lt;li&gt;短期、定期&lt;/li&gt;
&lt;li&gt;存款&lt;/li&gt;
&lt;li&gt;贷币市场基金&lt;/li&gt;
&lt;li&gt;短期国债&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;贷款

&lt;ul&gt;
&lt;li&gt;还款控制在月收入的30%左右&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;保险

&lt;ul&gt;
&lt;li&gt;意外伤害保险、车险、重大疾病&lt;/li&gt;
&lt;li&gt;外出旅游保险&lt;/li&gt;
&lt;li&gt;房屋贷款保险&lt;/li&gt;
&lt;li&gt;定期寿险&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;投资&lt;/li&gt;
&lt;li&gt;結婚

&lt;ul&gt;
&lt;li&gt;财产分配&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;教育&lt;/li&gt;
&lt;li&gt;养老&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;tags: Finacial&lt;/h2&gt;
</content>
 </entry>
 
 <entry>
   <title>ToBeALeader</title>
   <link href="http://www.5wpc.info/it/career/manage/2013/01/15/ToBeALeader"/>
   <updated>2013-01-15T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/career/manage/2013/01/15/ToBeALeader</id>
   <content type="html">&lt;h1&gt;ToBeALeader&lt;/h1&gt;

&lt;h2&gt;Thoughts&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;以人为本，改变组织理念

&lt;ul&gt;
&lt;li&gt;http://www.infoq.com/cn/news/2012/12/mindset-focus-people&lt;/li&gt;
&lt;li&gt;组织期望：他们期望你成为一个好的管理者还是卓越的管理者？&lt;/li&gt;
&lt;li&gt;结果和延期的结果：优秀的管理者所带来的现在和将来的收益&lt;/li&gt;
&lt;li&gt;勇敢的管理和沟通：怎样知道你的团队成员需要什么，并使他们真正参与进来&lt;/li&gt;
&lt;li&gt;敌对和友善：关注工作关系&lt;/li&gt;
&lt;li&gt;勇气以及一个管理者所面对的挑战&lt;/li&gt;
&lt;li&gt;管理者的角色以及职业规划&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;乌合之众

&lt;ul&gt;
&lt;li&gt;http://m.douban.com/book/review/5337136/?session=defe1994&lt;/li&gt;
&lt;li&gt;大众的心理毫无理性可言，他们是一群疯狂、冲动、偏执、盲目、狂热、易被鼓动的无意识庸众——即乌合之众。 群体是盲目的，易受暗示的。这种盲目性最为典型的要属网络暴民，所有的事情出来之后，大家都要去急迫地表态站队，如果站了非主流的队，就有人骂你，更可笑的是，不表态也有人骂你。 在抽象的，激烈的情绪的传染中，群体往往会失去正确的是非判断力，基本的真相往往会被掩盖。 群体只知道简单而极端的感情，提供给他们的意见、想法和观念，他们或者全盘接受，或者一概拒绝。 书中讲到群体领袖的动员方法：断言、重复和传染。比如领袖会利用自己的名望来带动群众，再将自己的主张灌输其中，一些所谓的公知便是如此。有时候观点不断被重复，群众便信以为真，成为其群体的一部分，有些谣言便是如此传播的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;帮助你有效反制项目破坏者

&lt;ul&gt;
&lt;li&gt;http://www.iteye.com/news/27047&lt;/li&gt;
&lt;li&gt;知己知彼，百战百胜

&lt;ul&gt;
&lt;li&gt;成功破坏一个项目的关键是要从对项目最重要的地方下手，将开发者的注意力从最重要的工作上转移走，并耗尽开发者的精力。用你的想象力和创造力，不要放过任何机会，将项目一步一步拉向失败的边缘。

&lt;ul&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;专注于边缘问题，以证明你知识渊博&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;问一些你不理解答案的问题，并坚持弄懂&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;拒绝文档或会议记录&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;避免明确的决定&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;忽略分配给你的任务&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;专注于其他人的缺点&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;没有议程或结构的会议&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;消耗能量&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;文档&lt;/li&gt;
&lt;li&gt;明确会议议程和决定&lt;/li&gt;
&lt;li&gt;必要的时候，制造点小冲突&lt;/li&gt;
&lt;li&gt;避免冲突&lt;/li&gt;
&lt;li&gt;明智地使用谦虚的话来避免冲突&lt;/li&gt;
&lt;li&gt;在项目中孤立破坏者&lt;/li&gt;
&lt;li&gt;权利至关重要&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;tags: Manage&lt;/h2&gt;
</content>
 </entry>
 
 <entry>
   <title>JavaScript</title>
   <link href="http://www.5wpc.info/it/technical/language/2013/01/15/JavaScript"/>
   <updated>2013-01-15T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/technical/language/2013/01/15/JavaScript</id>
   <content type="html">&lt;h1&gt;JavaScript&lt;/h1&gt;

&lt;h2&gt;应用场景&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;HTML5+JS=Phone APP

&lt;ul&gt;
&lt;li&gt;HTML&lt;/li&gt;
&lt;li&gt;CSS&lt;/li&gt;
&lt;li&gt;JS&lt;/li&gt;
&lt;li&gt;Icenium&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;Memory&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;内存泄漏

&lt;ul&gt;
&lt;li&gt;GoogleLeakFinder

&lt;ul&gt;
&lt;li&gt;http://www.infoq.com/cn/news/2013/01/JavaScript-Leak-Finder&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;Test&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;测试执行器Testacular

&lt;ul&gt;
&lt;li&gt;http://www.infoq.com/cn/news/2012/12/Testacular&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;VM&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;V8

&lt;ul&gt;
&lt;li&gt;Performance

&lt;ul&gt;
&lt;li&gt;http://www.infoq.com/cn/presentations/javaScript-engine&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Modules

&lt;ul&gt;
&lt;li&gt;Parser

&lt;ul&gt;
&lt;li&gt;DFA&lt;/li&gt;
&lt;li&gt;LL&lt;/li&gt;
&lt;li&gt;ASL&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;IR

&lt;ul&gt;
&lt;li&gt;bytecode&lt;/li&gt;
&lt;li&gt;stack-mode&lt;/li&gt;
&lt;li&gt;Register-mode&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Interpretor

&lt;ul&gt;
&lt;li&gt;Switch mode&lt;/li&gt;
&lt;li&gt;Direct jump&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;JIT&lt;/li&gt;
&lt;li&gt;Runtime

&lt;ul&gt;
&lt;li&gt;Object Module&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;GC&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Features

&lt;ul&gt;
&lt;li&gt;Hidden Class&lt;/li&gt;
&lt;li&gt;inline-cache&lt;/li&gt;
&lt;li&gt;JIT&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;OpenJDK

&lt;ul&gt;
&lt;li&gt;Nashorn

&lt;ul&gt;
&lt;li&gt;JSR292&lt;/li&gt;
&lt;li&gt;invokedynamic&lt;/li&gt;
&lt;li&gt;JSR223&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>如何成为一个架构师</title>
   <link href="http://www.5wpc.info/it/technical/architecture/2013/01/15/HowToBe"/>
   <updated>2013-01-15T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/technical/architecture/2013/01/15/HowToBe</id>
   <content type="html">&lt;h1&gt;How to?&lt;/h1&gt;

&lt;p&gt;http://www.iteye.com/news/26955&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;你必须不断寻求改善。这里有一些很不错的书籍，可以提升你的技能：

&lt;ol&gt;
&lt;li&gt;每一个软件架构师都应该知道的97件事&lt;/li&gt;
&lt;li&gt;企业应用架构模式&lt;/li&gt;
&lt;li&gt;C#中的敏捷原则、模式与实践&lt;/li&gt;
&lt;li&gt;企业集成模式&lt;/li&gt;
&lt;li&gt;JavaScript：最精彩的部分&lt;/li&gt;
&lt;li&gt;修改代码的艺术&lt;/li&gt;
&lt;li&gt;领域驱动设计&lt;/li&gt;
&lt;li&gt;企业架构战略&lt;/li&gt;
&lt;li&gt;设计模式&lt;/li&gt;
&lt;li&gt;目标&lt;/li&gt;
&lt;li&gt;SOA设计模式&lt;/li&gt;
&lt;li&gt;SOA服务设计原则&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;每一到两年学习一门新的编程语言。&lt;/li&gt;
&lt;li&gt;选择一个重点领域，尽可能对技术有一个高层次的理解。&lt;/li&gt;
&lt;li&gt;针对你的重点领域，开始写博客，并继续扩大你的知识面，在你的重点领域中成为专家。&lt;/li&gt;
&lt;li&gt;尝试不同的技术、编程语言、设计模式、架构等。&lt;/li&gt;
&lt;li&gt;向你的听众介绍技术，并努力让每个听众都能理解。&lt;/li&gt;
&lt;li&gt;阅读博客，浏览并参与到Twitter和Google+中，收听播客、看杂志、参加用户组会议和技术会议，并在这些会议上发言。&lt;/li&gt;
&lt;li&gt;每天安排时间学习新的东西，即使它只需15分钟。&lt;/li&gt;
&lt;li&gt;有效利用一些被浪费掉的时间。&lt;/li&gt;
&lt;li&gt;了解各种可用的工具，以帮助你更有效地做好本职工作。&lt;/li&gt;
&lt;li&gt;了解大量不同项目中的不同架构。&lt;/li&gt;
&lt;li&gt;了解不同的项目管理方法。&lt;/li&gt;
&lt;li&gt;你所用的技术可以提供给业务多少价值？了解评估的方法。&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;大胆行前人未行之路&lt;/h1&gt;

&lt;p&gt;http://www.infoq.com/cn/articles/pragmatic-architect&lt;/p&gt;

&lt;p&gt;架构设计恰好就需要如此。来到事物之间：在代码行上或其间，发现隐藏的领域概念；在你的系统和其他系统的组件之间， 可以引导你设计好接口和工作流；在不确定性及可选项之间，驱动你的决策。架构师的工作就是去尽早地发现这些“在中间的”事物，使它们更加明确，从中做出决 策。以上这些加上扎实的有关架构方法和技术的专业知识，以及谨慎的实践，就是对架构的精通之道：在软件系统的痛点上进行深思熟虑并最终决定它的成败。&lt;/p&gt;

&lt;h1&gt;架构师应该掌握的协商原则&lt;/h1&gt;

&lt;p&gt;http://www.infoq.com/cn/news/2013/01/architect-negotiation&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在你与人协商时，需要决定结果以一种不让人惊讶的方式给出&lt;/li&gt;
&lt;li&gt;协商的第二个原则就是不要模棱两可：是就“是”，不是就“不是”。&lt;/li&gt;
&lt;li&gt;架构师们应该委派权威而不是义务：一般情况下，我总是试着在每一组中找出几个需要共事的关键个人，与之建立高度信任的关系。我给这些人在协商中成长的机会，以及做决定的能力。要认识的一个基本原则是你不能委任责任。

&lt;ul&gt;
&lt;li&gt;当你做的某个决定以失败告终，Dave认为应当采取下列补救措施：

&lt;ul&gt;
&lt;li&gt;承担责任。&lt;/li&gt;
&lt;li&gt;在尽量早的时间内向受影响的各方道歉。&lt;/li&gt;
&lt;li&gt;让别人知道所发生的事情。&lt;/li&gt;
&lt;li&gt;让别人知道所发生事情的原因。&lt;/li&gt;
&lt;li&gt;不要责备别人，不要把责任转嫁给别人。&lt;/li&gt;
&lt;li&gt;在别人试图搞清楚发生的事情时，不要保持沉默。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;倘若你说你要做某件事，并已经承诺做这件事，你需要兑现承诺：

&lt;ul&gt;
&lt;li&gt;不管是在公开场合还是私下说的。&lt;/li&gt;
&lt;li&gt;不管是口头承诺还是书面承诺的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>ZygoteStartupSteps</title>
   <link href="http://www.5wpc.info/it/technical/os/android/2012/12/17/ZygoteStartupSteps"/>
   <updated>2012-12-17T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/technical/os/android/2012/12/17/ZygoteStartupSteps</id>
   <content type="html">&lt;h1&gt;ZygoteStartupSteps&lt;/h1&gt;

&lt;h2&gt;Linux&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;init

&lt;ul&gt;
&lt;li&gt;restart&lt;/li&gt;
&lt;li&gt;app_process

&lt;ul&gt;
&lt;li&gt;runtime

&lt;ul&gt;
&lt;li&gt;new&lt;/li&gt;
&lt;li&gt;config arguments&lt;/li&gt;
&lt;li&gt;java env

&lt;ul&gt;
&lt;li&gt;startVM&lt;/li&gt;
&lt;li&gt;Find Class&lt;/li&gt;
&lt;li&gt;Find Method&lt;/li&gt;
&lt;li&gt;invoke Method

&lt;ul&gt;
&lt;li&gt;com.andrid.internal.os.ZygoteInit:main&lt;/li&gt;
&lt;li&gt;Go to Java World&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;Java World&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;ZygoteInit.main

&lt;ul&gt;
&lt;li&gt;RegisterZygoteSocket&lt;/li&gt;
&lt;li&gt;preload

&lt;ul&gt;
&lt;li&gt;Classes&lt;/li&gt;
&lt;li&gt;Resources&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;gc&lt;/li&gt;
&lt;li&gt;startSystemServer

&lt;ul&gt;
&lt;li&gt;com.android.server.SystemServer&lt;/li&gt;
&lt;li&gt;Zygote.forkSystemServer

&lt;ul&gt;
&lt;li&gt;Child

&lt;ul&gt;
&lt;li&gt;handleSystemServerProcess

&lt;ul&gt;
&lt;li&gt;closeServerSocket&lt;/li&gt;
&lt;li&gt;Run

&lt;ul&gt;
&lt;li&gt;WrapperInit.execApplication&lt;/li&gt;
&lt;li&gt;RuntimeInit.zygoteInit

&lt;ul&gt;
&lt;li&gt;applicationInit

&lt;ul&gt;
&lt;li&gt;invokeStaticMain

&lt;ul&gt;
&lt;li&gt;Get main method&lt;/li&gt;
&lt;li&gt;throw new ZygoteInit.MethodAndArgsCaller&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Parent

&lt;ul&gt;
&lt;li&gt;return true&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;run

&lt;ul&gt;
&lt;li&gt;ForkMode&lt;/li&gt;
&lt;li&gt;SelectLoopMode

&lt;ul&gt;
&lt;li&gt;add peer to list&lt;/li&gt;
&lt;li&gt;Get item from list

&lt;ul&gt;
&lt;li&gt;peer.runOnce

&lt;ul&gt;
&lt;li&gt;Prepare&lt;/li&gt;
&lt;li&gt;forkAndSpecialize

&lt;ul&gt;
&lt;li&gt;Child

&lt;ul&gt;
&lt;li&gt;handleChildProc

&lt;ul&gt;
&lt;li&gt;invokeStaticMain&lt;/li&gt;
&lt;li&gt;Run&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Parent

&lt;ul&gt;
&lt;li&gt;peer wait

&lt;ul&gt;
&lt;li&gt;return true&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;closeServerSocket&lt;/li&gt;
&lt;li&gt;catch MethodAndArgsCaller

&lt;ul&gt;
&lt;li&gt;save to caller&lt;/li&gt;
&lt;li&gt;caller.run&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;catch RuntimeException

&lt;ul&gt;
&lt;li&gt;save to ex&lt;/li&gt;
&lt;li&gt;closeServerSocket&lt;/li&gt;
&lt;li&gt;throw ex&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>BeingGeek</title>
   <link href="http://www.5wpc.info/it/career/coder/2012/12/17/BeingGeek"/>
   <updated>2012-12-17T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/career/coder/2012/12/17/BeingGeek</id>
   <content type="html">&lt;h1&gt;BeingGeek&lt;/h1&gt;

&lt;h2&gt;tags: Review&lt;/h2&gt;

&lt;h2&gt;职业生涯攻防手册&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;致胜之道(心中有个风向标)

&lt;ul&gt;
&lt;li&gt;我们的特点

&lt;ul&gt;
&lt;li&gt;系统思维者&lt;/li&gt;
&lt;li&gt;不善于处理人际关系&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;需要具备的基本能力

&lt;ul&gt;
&lt;li&gt;面对事情应变&lt;/li&gt;
&lt;li&gt;为人处事&lt;/li&gt;
&lt;li&gt;积累

&lt;ul&gt;
&lt;li&gt;Note&lt;/li&gt;
&lt;li&gt;Review&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;职业蓝图

&lt;ul&gt;
&lt;li&gt;为正在做的事情找一个更大的主题&lt;/li&gt;
&lt;li&gt;明确方向，做出决定&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;三要素(生活与工作的状态)

&lt;ul&gt;
&lt;li&gt;技术方向

&lt;ul&gt;
&lt;li&gt;你是否主动确定产品的技术方向？&lt;/li&gt;
&lt;li&gt;提醒每天关心自己的工作&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;保持成长

&lt;ul&gt;
&lt;li&gt;你是否明白要做哪些事情才能一直成长&lt;/li&gt;
&lt;li&gt;关注自己的职业生涯&lt;/li&gt;
&lt;li&gt;确保今天不是昨天单调的重复&lt;/li&gt;
&lt;li&gt;积累自己的知识

&lt;ul&gt;
&lt;li&gt;对各种事实、资料、状况和人格的消費&lt;/li&gt;
&lt;li&gt;对自己取得的信息进行整合&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;交付工作

&lt;ul&gt;
&lt;li&gt;你是否按时完成工作，兑现承诺，言出必行&lt;/li&gt;
&lt;li&gt;对信誉的日常投资&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;工作之痒(不爽的时候)

&lt;ul&gt;
&lt;li&gt;冷电话的意义

&lt;ul&gt;
&lt;li&gt;这是一种对个人是否满意现状的检验&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;对现状的愤怒&lt;/li&gt;
&lt;li&gt;无意识间的预警

&lt;ul&gt;
&lt;li&gt;对工作的投入程度&lt;/li&gt;
&lt;li&gt;漫无目的的活动

&lt;ul&gt;
&lt;li&gt;不用心最終是会还的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;准备换工作时应该打消的顾虑

&lt;ul&gt;
&lt;li&gt;不会失去谁

&lt;ul&gt;
&lt;li&gt;朋友是用分开来检验的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;对现有工作的影响

&lt;ul&gt;
&lt;li&gt;工作没有完，不用担心&lt;/li&gt;
&lt;li&gt;自然有人做&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;进入新环境的顾虑

&lt;ul&gt;
&lt;li&gt;我们需要接受打击&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;未来是否绚烂夺目

&lt;ul&gt;
&lt;li&gt;这根据你是否知道想要什么&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;新的工作

&lt;ul&gt;
&lt;li&gt;电话面试(心智评估)

&lt;ul&gt;
&lt;li&gt;准备

&lt;ul&gt;
&lt;li&gt;调查基本信息

&lt;ul&gt;
&lt;li&gt;面试的人background

&lt;ul&gt;
&lt;li&gt;专业&lt;/li&gt;
&lt;li&gt;爱好&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Beginning

&lt;ul&gt;
&lt;li&gt;初步调整

&lt;ul&gt;
&lt;li&gt;沟通能力(开场的生活问题)&lt;/li&gt;
&lt;li&gt;緩和过程(从面试者简历出发)&lt;/li&gt;
&lt;li&gt;难题

&lt;ul&gt;
&lt;li&gt;开放式问题&lt;/li&gt;
&lt;li&gt;沟通能力&lt;/li&gt;
&lt;li&gt;思维方式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;自己提问(关键)

&lt;ul&gt;
&lt;li&gt;根据对方的特点准备问题&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;收尾

&lt;ul&gt;
&lt;li&gt;长时间令人尴尬的停顿&lt;/li&gt;
&lt;li&gt;对抗性的互动

&lt;ul&gt;
&lt;li&gt;你的个性与团队的相处&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;感觉如何

&lt;ul&gt;
&lt;li&gt;个人的映象&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;具体的下一步

&lt;ul&gt;
&lt;li&gt;如果面试者进一步说过来看看，表明不错&lt;/li&gt;
&lt;li&gt;如果没有下一步，可以考虑主动提及(可能存在问题)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;当面面试

&lt;ul&gt;
&lt;li&gt;之前的准备(紧张神经)

&lt;ul&gt;
&lt;li&gt;Maybe

&lt;ul&gt;
&lt;li&gt;Problem

&lt;ul&gt;
&lt;li&gt;具体的

&lt;ul&gt;
&lt;li&gt;针对性强，没有什么大问题&lt;/li&gt;
&lt;li&gt;自己的业务相关事情&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;问题解决类

&lt;ul&gt;
&lt;li&gt;思维方式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;开放式问题

&lt;ul&gt;
&lt;li&gt;理解问题

&lt;ul&gt;
&lt;li&gt;不理解

&lt;ul&gt;
&lt;li&gt;reask&lt;/li&gt;
&lt;li&gt;ask for verifying&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;不会

&lt;ul&gt;
&lt;li&gt;说出来&quot;我不会&quot;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;保持信心&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;正式面试

&lt;ul&gt;
&lt;li&gt;面试人员的安排

&lt;ul&gt;
&lt;li&gt;技术&lt;/li&gt;
&lt;li&gt;团队&lt;/li&gt;
&lt;li&gt;性格&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;面试人

&lt;ul&gt;
&lt;li&gt;愤怒的面试者

&lt;ul&gt;
&lt;li&gt;抱怨自己的环境&lt;/li&gt;
&lt;li&gt;没有意义&lt;/li&gt;
&lt;li&gt;表明团队的现状可能不好&lt;/li&gt;
&lt;li&gt;How to face

&lt;ul&gt;
&lt;li&gt;可以获得信息&lt;/li&gt;
&lt;li&gt;主动询问原由&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;we get

&lt;ul&gt;
&lt;li&gt;少抱怨&lt;/li&gt;
&lt;li&gt;高速自己&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;健谈的

&lt;ul&gt;
&lt;li&gt;How to face

&lt;ul&gt;
&lt;li&gt;可以获得信息&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;we get

&lt;ul&gt;
&lt;li&gt;说正确、有价值的话&lt;/li&gt;
&lt;li&gt;不要一直说&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;诗人

&lt;ul&gt;
&lt;li&gt;有一定影响&lt;/li&gt;
&lt;li&gt;可以沟通&lt;/li&gt;
&lt;li&gt;we get

&lt;ul&gt;
&lt;li&gt;工作中不要自我陶醉&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;为难人

&lt;ul&gt;
&lt;li&gt;喜欢看别人紧张&lt;/li&gt;
&lt;li&gt;How to face

&lt;ul&gt;
&lt;li&gt;Find his 弱点&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;老练的&lt;/li&gt;
&lt;li&gt;沉默的

&lt;ul&gt;
&lt;li&gt;对业务技术影响巨大&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;总裁&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;新的视角

&lt;ul&gt;
&lt;li&gt;通过面试了解公司的状况&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;薪酬(经营自己)

&lt;ul&gt;
&lt;li&gt;需要考虑的方面

&lt;ul&gt;
&lt;li&gt;基本工资&lt;/li&gt;
&lt;li&gt;头衔&lt;/li&gt;
&lt;li&gt;签约奖金&lt;/li&gt;
&lt;li&gt;股票&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;谈判中的角色

&lt;ul&gt;
&lt;li&gt;你表现的越渴望，谈判优势越少&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Parameters

&lt;ul&gt;
&lt;li&gt;年假&lt;/li&gt;
&lt;li&gt;晚开工&lt;/li&gt;
&lt;li&gt;SOHO&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;没兴趣

&lt;ul&gt;
&lt;li&gt;How do you love&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;解读管理&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;公司文化的意义(文化流行榜)

&lt;ul&gt;
&lt;li&gt;刚开始在一个地方工作(90天)

&lt;ul&gt;
&lt;li&gt;为了获得提拔，你需要做哪些具体的事情?&lt;/li&gt;
&lt;li&gt;How to answer?

&lt;ul&gt;
&lt;li&gt;Know 公司文化&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;探究公司文化

&lt;ul&gt;
&lt;li&gt;永远要想在管理者前面

&lt;ul&gt;
&lt;li&gt;拿出了他极度需要却没有想到要你提供的东西&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;From

&lt;ul&gt;
&lt;li&gt;公司的传说&lt;/li&gt;
&lt;li&gt;故事&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Who 确定文化

&lt;ul&gt;
&lt;li&gt;关注这个群体，因为他们做什么，整个公司也会follow&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;文化改变了(一部分核心人走了)

&lt;ul&gt;
&lt;li&gt;Find改变，不断为自己重新定位&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;管理你的老板

&lt;ul&gt;
&lt;li&gt;评估你的老板

&lt;ul&gt;
&lt;li&gt;How?

&lt;ul&gt;
&lt;li&gt;Behaviors

&lt;ul&gt;
&lt;li&gt;有无一对一的面谈

&lt;ul&gt;
&lt;li&gt;Have

&lt;ul&gt;
&lt;li&gt;应该定期开诚布公地讨论你工作中的表现&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;No

&lt;ul&gt;
&lt;li&gt;你需要到工作第一线去获取经验&lt;/li&gt;
&lt;li&gt;Require

&lt;ul&gt;
&lt;li&gt;For your thinking your work and plan yourself&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;部门会议

&lt;ul&gt;
&lt;li&gt;Random

&lt;ul&gt;
&lt;li&gt;有机型&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Plan

&lt;ul&gt;
&lt;li&gt;机械型

&lt;ul&gt;
&lt;li&gt;Plan&lt;/li&gt;
&lt;li&gt;Timeline&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Different style, different methods to communicate with them&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;状态报告

&lt;ul&gt;
&lt;li&gt;作用

&lt;ul&gt;
&lt;li&gt;填补沟通问题&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;积极应对

&lt;ul&gt;
&lt;li&gt;Remember

&lt;ul&gt;
&lt;li&gt;What happens&lt;/li&gt;
&lt;li&gt;What&#39;s the important&lt;/li&gt;
&lt;li&gt;Plan&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;安排什么类型的会议

&lt;ul&gt;
&lt;li&gt;技术型

&lt;ul&gt;
&lt;li&gt;For technical discuss&lt;/li&gt;
&lt;li&gt;For future&#39;s works&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;协调型

&lt;ul&gt;
&lt;li&gt;确认步调是否一致&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;越俎代庖

&lt;ul&gt;
&lt;li&gt;对中间层的孤立&lt;/li&gt;
&lt;li&gt;不好&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;How to manage

&lt;ul&gt;
&lt;li&gt;将事情的基本要素提炼出来，在合适的地方加入自己的观点，并根据老板对信息的偏好，用合适的方式传达&lt;/li&gt;
&lt;li&gt;及时通报&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;面对无能者

&lt;ul&gt;
&lt;li&gt;管理者与上司的意义

&lt;ul&gt;
&lt;li&gt;提供资源与帮助&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;We should

&lt;ul&gt;
&lt;li&gt;Know what should we decide&lt;/li&gt;
&lt;li&gt;What should we ask for help&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;向上管理

&lt;ul&gt;
&lt;li&gt;基层的信息重于高层的时候&lt;/li&gt;
&lt;li&gt;You should

&lt;ul&gt;
&lt;li&gt;弄清楚老板需要什么样的信息，以及他何時需要这种信息&lt;/li&gt;
&lt;li&gt;独立、高效地处理团队中的问题，让事情有条不紊地进行，让老板听不到任何坏消息&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;何時上报

&lt;ul&gt;
&lt;li&gt;是份内的事情吗

&lt;ul&gt;
&lt;li&gt;Yes

&lt;ul&gt;
&lt;li&gt;Do&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;No

&lt;ul&gt;
&lt;li&gt;Report&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;能否解决

&lt;ul&gt;
&lt;li&gt;No-Report&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;问题的严重性

&lt;ul&gt;
&lt;li&gt;Yes-Report&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;是否是老板关心的

&lt;ul&gt;
&lt;li&gt;Yes-Report&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;独立解决，后果

&lt;ul&gt;
&lt;li&gt;成功&lt;/li&gt;
&lt;li&gt;失败&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;What you get?&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;当心无能者

&lt;ul&gt;
&lt;li&gt;你有义务看穿他们的官腔&lt;/li&gt;
&lt;li&gt;寻找他们的宝贵经验&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;At last

&lt;ul&gt;
&lt;li&gt;说清楚问题&lt;/li&gt;
&lt;li&gt;提供解决方案&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;针对自己疏忽的问题

&lt;ul&gt;
&lt;li&gt;不要找借口&lt;/li&gt;
&lt;li&gt;在自己出问题，时注意表达方式

&lt;ul&gt;
&lt;li&gt;认错&lt;/li&gt;
&lt;li&gt;解释原因&lt;/li&gt;
&lt;li&gt;寻找解决方案&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;讲些有意义的话&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;发生错误时

&lt;ul&gt;
&lt;li&gt;上级可能出问题&lt;/li&gt;
&lt;li&gt;上级的状态

&lt;ul&gt;
&lt;li&gt;讯问

&lt;ul&gt;
&lt;li&gt;通过问题寻找错误，给出方案&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;排序

&lt;ul&gt;
&lt;li&gt;通过列出所有可能&lt;/li&gt;
&lt;li&gt;寻找突破口&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;启发

&lt;ul&gt;
&lt;li&gt;引导&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;愤怒

&lt;ul&gt;
&lt;li&gt;失去理智&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;自己需要明白

&lt;ul&gt;
&lt;li&gt;引导型汇报&lt;/li&gt;
&lt;li&gt;共同寻找解决问题的方法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;不可能的任务

&lt;ul&gt;
&lt;li&gt;什么是疯狂的任务

&lt;ul&gt;
&lt;li&gt;只有目的，没有计划&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;赌注的大小

&lt;ul&gt;
&lt;li&gt;看清发展势头，明确自己的处境&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;领导的影响力&lt;/li&gt;
&lt;li&gt;我们要明确

&lt;ul&gt;
&lt;li&gt;他真正需要啥&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;日常工具箱&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;一天的滋味

&lt;ul&gt;
&lt;li&gt;早上整理&lt;/li&gt;
&lt;li&gt;注重效率&lt;/li&gt;
&lt;li&gt;晚上整理&lt;/li&gt;
&lt;li&gt;战术

&lt;ul&gt;
&lt;li&gt;完成工作&lt;/li&gt;
&lt;li&gt;利用资源完成事情&lt;/li&gt;
&lt;li&gt;紧但不一定重要的事情&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;涓滴列表

&lt;ul&gt;
&lt;li&gt;重要而不紧急的事情

&lt;ul&gt;
&lt;li&gt;战略&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;每天一点&lt;/li&gt;
&lt;li&gt;及时跟进与整理&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;战术与战略相互结合，统一成关键信息出现的快速反馈与整合&lt;/li&gt;
&lt;li&gt;危机与创造性

&lt;ul&gt;
&lt;li&gt;从危机中走出，通过总结将其变成可按的事情，这是对现有流程的规划&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;优化自己使用的工具&lt;/li&gt;
&lt;li&gt;无为，多多停下来总结，看看天&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>Zygote</title>
   <link href="http://www.5wpc.info/it/technical/os/android/2012/12/13/Zygote"/>
   <updated>2012-12-13T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/technical/os/android/2012/12/13/Zygote</id>
   <content type="html">&lt;h1&gt;Zygote&lt;/h1&gt;

&lt;h2&gt;From&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;init process&lt;/li&gt;
&lt;li&gt;app_process&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;Resources&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/luoshengyang/article/details/6768304&quot;&gt;Android系统进程Zygote启动过程的源代码分析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src=&quot;http://pic.yupoo.com/qianjigui/CuRPLCqf/UhmYQ.png&quot; alt=&quot;Steps&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;IPC&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;UNIX domain socket&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;Steps&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;app_process.main

&lt;ul&gt;
&lt;li&gt;创建一个AppRuntime变量&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;AndroidRuntime.start

&lt;ul&gt;
&lt;li&gt;启动Android系统运行时库&lt;/li&gt;
&lt;li&gt;Work

&lt;ul&gt;
&lt;li&gt;调用函数startVM启动虚拟机&lt;/li&gt;
&lt;li&gt;调用函数startReg注册JNI方法&lt;/li&gt;
&lt;li&gt;调用了com.android.internal.os.ZygoteInit类的main函数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ZygoteInit.main

&lt;ul&gt;
&lt;li&gt;调用registerZygoteSocket函数创建了一个socket接口，用来和ActivityManagerService通讯&lt;/li&gt;
&lt;li&gt;调用startSystemServer函数来启动SystemServer组件&lt;/li&gt;
&lt;li&gt;调用runSelectLoopMode函数进入一个无限循环在前面创建的socket接口上等待ActivityManagerService请求创建新的应用程序进程&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ZygoteInit.registerZygoteSocket&lt;/li&gt;
&lt;li&gt;ZygoteInit.startSystemServer&lt;/li&gt;
&lt;li&gt;ZygoteInit.handleSystemServerProcess

&lt;ul&gt;
&lt;li&gt;SystemServer不需要socket通信，关闭socket&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;RuntimeInit.zygoteInit

&lt;ul&gt;
&lt;li&gt;调用zygoteInitNative函数来执行一个Binder进程间通信机制的初始化工作&lt;/li&gt;
&lt;li&gt;调用上面 传进来的com.android.server.SystemServer类的main函数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;RuntimeInit.zygoteInitNative&lt;/li&gt;
&lt;li&gt;SystemServer.main&lt;/li&gt;
&lt;li&gt;ZygoteInit.runSelectLoopMode&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>Binder</title>
   <link href="http://www.5wpc.info/it/technical/os/android/2012/12/13/Binder"/>
   <updated>2012-12-13T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/technical/os/android/2012/12/13/Binder</id>
   <content type="html">&lt;h1&gt;Binder&lt;/h1&gt;

&lt;h2&gt;Introduction&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;一种进程间通信机制IPC&lt;/li&gt;
&lt;li&gt;一种类似于COM和CORBA分布式组件架构&lt;/li&gt;
&lt;li&gt;提供远程过程调用（RPC）功能&lt;/li&gt;
&lt;li&gt;核心组件便是Binder驱动程序了，Service Manager提供了辅助管理的功能，Client和Server正是在Binder驱动和Service Manager提供的基础设施上，进行Client-Server之间的通信&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;Resources&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/luoshengyang/article/details/6618363&quot;&gt;Android进程间通信（IPC）机制Binder简要介绍和学习计划 &lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/innost/archive/2011/01/09/1931456.html&quot;&gt;Android深入浅出之Binder机制&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://disanji.net/2011/02/28/android-bnder-design/&quot;&gt;Android Binder设计与实现 – 设计篇 &lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;Feature&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;可靠性

&lt;ul&gt;
&lt;li&gt;资源稀缺的环境下&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;传输性能

&lt;ul&gt;
&lt;li&gt;共享内存 0次数据copy&lt;/li&gt;
&lt;li&gt;Binder 1次数据copy&lt;/li&gt;
&lt;li&gt;Socket/管道/消息队列 2次数据copy&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;安全性

&lt;ul&gt;
&lt;li&gt;为发送发添加UID/PID身份，既支持实名Binder也支持匿名Binder&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;面向对象的 Binder IPC&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;RPC进程间方法调用&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;通信模型&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;角色

&lt;ul&gt;
&lt;li&gt;Server，Client，ServiceManager（以后简称SMgr）以及驱动&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Binder 驱动

&lt;ul&gt;
&lt;li&gt;实现方式和设备驱动程序是一样的：它工作于内核态，提供open()，mmap()，poll()，ioctl()等标准文件操作，以字符驱动设备中的misc设备注册在设备目录 /dev下，用户通过/dev/binder访问该它。&lt;/li&gt;
&lt;li&gt;Care

&lt;ul&gt;
&lt;li&gt;通信建立&lt;/li&gt;
&lt;li&gt;进程间binder传递&lt;/li&gt;
&lt;li&gt;Binder引用计数管理&lt;/li&gt;
&lt;li&gt;数据包在进程之间的传递和交互&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ServiceManager 与实名Binder

&lt;ul&gt;
&lt;li&gt;Register Service&lt;/li&gt;
&lt;li&gt;Broadcast&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Client 获得实名Binder的引用

&lt;ul&gt;
&lt;li&gt;Get service by name&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;匿名 Binder

&lt;ul&gt;
&lt;li&gt;Not register&lt;/li&gt;
&lt;li&gt;私密通道&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;Binder 协议&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;基本格式是（命令+数据），使用ioctl(fd, cmd, arg)函数实现交互&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;Binder 的表述&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Client&lt;/li&gt;
&lt;li&gt;Server&lt;/li&gt;
&lt;li&gt;ServiceManager&lt;/li&gt;
&lt;li&gt;Driver&lt;/li&gt;
&lt;li&gt;File&lt;/li&gt;
&lt;li&gt;Data Transfer&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;Binder 内存映射和接收缓存区管理&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;mmap

&lt;ul&gt;
&lt;li&gt;Sender&lt;/li&gt;
&lt;li&gt;Receiver&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Memory Pool

&lt;ul&gt;
&lt;li&gt;最佳匹配算法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;Binder 接收线程管理&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Create many threads at first&lt;/li&gt;
&lt;li&gt;Block for getting&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;数据包接收队列与（线程）等待队列管理&lt;/h2&gt;

&lt;h2&gt;tags: IPC&lt;/h2&gt;

&lt;h2&gt;整体实现结构&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;在init.rc中以servicemanager启动

&lt;ul&gt;
&lt;li&gt;整个Android System_Server的binder支持来源于此&lt;/li&gt;
&lt;li&gt;可以只启动servicemanager进行binder操作测试&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Startup

&lt;ul&gt;
&lt;li&gt;By init.rc

&lt;ul&gt;
&lt;li&gt;servicemanager&lt;/li&gt;
&lt;li&gt;dm_agent_binder&lt;/li&gt;
&lt;li&gt;nvram_backup_binder&lt;/li&gt;
&lt;li&gt;nvram_agent_binder&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;by kthreadd

&lt;ul&gt;
&lt;li&gt;binder_watchdog&lt;/li&gt;
&lt;li&gt;binder&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;具体使用

&lt;ul&gt;
&lt;li&gt;Demo

&lt;ul&gt;
&lt;li&gt;https://github.com/qianjigui/android_system_service_example&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Server

&lt;ul&gt;
&lt;li&gt;Start ServiceManager&lt;/li&gt;
&lt;li&gt;Start server for attaching service&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Client

&lt;ul&gt;
&lt;li&gt;Client getService from ServiceManager&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>JavaHarmony</title>
   <link href="http://www.5wpc.info/it/technical/language/java/2012/12/11/JavaHarmony"/>
   <updated>2012-12-11T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/technical/language/java/2012/12/11/JavaHarmony</id>
   <content type="html">&lt;h1&gt;JavaHarmony&lt;/h1&gt;

&lt;h2&gt;&lt;a href=&quot;http://www.ibm.com/developerworks/cn/java/j-harmony/&quot;&gt;ReadingRes&lt;/a&gt;&lt;/h2&gt;

&lt;h2&gt;Background&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Aim

&lt;ul&gt;
&lt;li&gt;开发出一个独立并且与现有 JDK 兼容的 Java SE 5 实现，并且以 Apache 软件许可证 2.0 版发行&lt;/li&gt;
&lt;li&gt;建立一个开放的模块化运行时架构，包括虚拟机和类库之间及其内部的模块化，并通过这个平台，允许社区在此基础上自由定制自己的 Java 实现，或者对某个模块单独进行创新&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Structure

&lt;ul&gt;
&lt;li&gt;&lt;img src=&quot;http://www.ibm.com/developerworks/cn/java/j-lo-harmony1/images/image002.jpg&quot; alt=&quot;StructureImage&quot; /&gt;&lt;/li&gt;
&lt;li&gt;ThreeLevels

&lt;ul&gt;
&lt;li&gt;OS&lt;/li&gt;
&lt;li&gt;JVM&lt;/li&gt;
&lt;li&gt;Java Library&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Feature

&lt;ul&gt;
&lt;li&gt;虚拟机和类库内部被高度模块化

&lt;ul&gt;
&lt;li&gt;Library

&lt;ul&gt;
&lt;li&gt;类库在功能和 Java Package 的基础上被分成 31 个模块&lt;/li&gt;
&lt;li&gt;list

&lt;ul&gt;
&lt;li&gt;ACCESSIBILITY&lt;/li&gt;
&lt;li&gt;ANNOTATION&lt;/li&gt;
&lt;li&gt;APPLET&lt;/li&gt;
&lt;li&gt;ARCHIVE&lt;/li&gt;
&lt;li&gt;AUTH&lt;/li&gt;
&lt;li&gt;AWT&lt;/li&gt;
&lt;li&gt;BEANS&lt;/li&gt;
&lt;li&gt;CONCURRENT&lt;/li&gt;
&lt;li&gt;CRYPTO&lt;/li&gt;
&lt;li&gt;IMAGEIO&lt;/li&gt;
&lt;li&gt;INSTRUMENT

&lt;ul&gt;
&lt;li&gt;动态扩展&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;JMX

&lt;ul&gt;
&lt;li&gt;Java Management extension&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;JNDI

&lt;ul&gt;
&lt;li&gt;Java 命名与目录接口（Java Naming and Directory Interface）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;LANG-MANAGEMENT&lt;/li&gt;
&lt;li&gt;LOGGING&lt;/li&gt;
&lt;li&gt;LUNI （lang， util， net， io）&lt;/li&gt;
&lt;li&gt;MATH&lt;/li&gt;
&lt;li&gt;NIO-CHANNELS&lt;/li&gt;
&lt;li&gt;NIO-CHARSET&lt;/li&gt;
&lt;li&gt;ORB

&lt;ul&gt;
&lt;li&gt;CORBA&lt;/li&gt;
&lt;li&gt;对象请求代管&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;PREFS&lt;/li&gt;
&lt;li&gt;PRINT&lt;/li&gt;
&lt;li&gt;REGEX&lt;/li&gt;
&lt;li&gt;RMI&lt;/li&gt;
&lt;li&gt;SECURITY&lt;/li&gt;
&lt;li&gt;SOUND&lt;/li&gt;
&lt;li&gt;SQL&lt;/li&gt;
&lt;li&gt;SWING&lt;/li&gt;
&lt;li&gt;TEXT&lt;/li&gt;
&lt;li&gt;X-NET&lt;/li&gt;
&lt;li&gt;XML&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;img src=&quot;http://www.ibm.com/developerworks/cn/java/j-lo-harmony4/img/arch.jpg&quot; alt=&quot;Library image&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;JVM

&lt;ul&gt;
&lt;li&gt;JIT&lt;/li&gt;
&lt;li&gt;MemoryManager&lt;/li&gt;
&lt;li&gt;ThreadManager&lt;/li&gt;
&lt;li&gt;JNI&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;每个模块都有一定的接口定义，从而有可能单独被替换成不同的实现&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Port Layer

&lt;ul&gt;
&lt;li&gt;操作系统层次与虚拟机层次之间的接口&lt;/li&gt;
&lt;li&gt;封装了不同的操作系统的差异，为虚拟机和类库的本地代码提供了一套统一的 API 访问底层系统调用。&lt;/li&gt;
&lt;li&gt;标准 C 语言 API 访问系统调用

&lt;ul&gt;
&lt;li&gt;IO

&lt;ul&gt;
&lt;li&gt;File&lt;/li&gt;
&lt;li&gt;Network&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Thread

&lt;ul&gt;
&lt;li&gt;Threads&lt;/li&gt;
&lt;li&gt;Sync&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;MemoryManager&lt;/li&gt;
&lt;li&gt;Signal&lt;/li&gt;
&lt;li&gt;Errorhandle&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Structure

&lt;ul&gt;
&lt;li&gt;数据类型&lt;/li&gt;
&lt;li&gt;实例访问&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;VMI(加入了一层虚拟机接口加入了一层虚拟机接口)

&lt;ul&gt;
&lt;li&gt;主要由内核类（Kernel Class）和本地代码 VMI 组成&lt;/li&gt;
&lt;li&gt;实现了虚拟机接口的虚拟机实现都可以使用 Harmony 的类库实现，并且可以被 Harmony 提供的同一个 Java 启动程序启动&lt;/li&gt;
&lt;li&gt;Parts

&lt;ul&gt;
&lt;li&gt;Kernel Class

&lt;ul&gt;
&lt;li&gt;java.lang，java.lang.ref，java.lang.reflect 和 java.security 等几个核心的包，比如说 java.lang.ClassLoader， java.lang.ref.WeakReference 等

&lt;ul&gt;
&lt;li&gt;java.lang.Object&lt;/li&gt;
&lt;li&gt;java.lang.Class&lt;/li&gt;
&lt;li&gt;java.lang.ClassLoader&lt;/li&gt;
&lt;li&gt;java.lang.Compiler&lt;/li&gt;
&lt;li&gt;java.lang.Package&lt;/li&gt;
&lt;li&gt;java.lang.Runtime&lt;/li&gt;
&lt;li&gt;java.lang.Thread&lt;/li&gt;
&lt;li&gt;java.lang.reflect.AccessibleObject&lt;/li&gt;
&lt;li&gt;java.lang.reflect.Constructor&lt;/li&gt;
&lt;li&gt;java.lang.reflect.Field&lt;/li&gt;
&lt;li&gt;java.lang.reflect.Method&lt;/li&gt;
&lt;li&gt;java.lang.reflect.Array&lt;/li&gt;
&lt;li&gt;java.lang.ref.Reference&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;VMI

&lt;ul&gt;
&lt;li&gt;虚拟机接口还定义了 VM 必须实现的 10 个 C 函数，用来访问虚拟机和类库共享的数据结构和接口，比如说访问操作系统抽象库（Port Library），虚拟机本地存储空间等。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;JNI&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;tags: JVM Harmony&lt;/h2&gt;

&lt;h2&gt;Development&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;TDD&lt;/li&gt;
&lt;li&gt;CodeReview&lt;/li&gt;
&lt;li&gt;PairCoding&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;基础设施&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;DevelopTools

&lt;ul&gt;
&lt;li&gt;Eclipse&lt;/li&gt;
&lt;li&gt;SVN&lt;/li&gt;
&lt;li&gt;Snapshot&lt;/li&gt;
&lt;li&gt;VM&lt;/li&gt;
&lt;li&gt;VM Plugin&lt;/li&gt;
&lt;li&gt;ant&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;TDD&lt;/li&gt;
&lt;li&gt;EmailList for discuss&lt;/li&gt;
&lt;li&gt;JIRA 问题跟踪管理系统&lt;/li&gt;
&lt;li&gt;Wiki doc&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>TheArtOfConcurrency</title>
   <link href="http://www.5wpc.info/it/technical/design/2012/12/09/TheArtOfConcurrency"/>
   <updated>2012-12-09T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/technical/design/2012/12/09/TheArtOfConcurrency</id>
   <content type="html">&lt;h1&gt;TheArtOfConcurrency&lt;/h1&gt;

&lt;h2&gt;背景&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;基本概念

&lt;ul&gt;
&lt;li&gt;并发

&lt;ul&gt;
&lt;li&gt;相同的工作同时运行&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;并行

&lt;ul&gt;
&lt;li&gt;不同类的工作一齐运行&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;主要问题

&lt;ul&gt;
&lt;li&gt;任务划分与分配

&lt;ul&gt;
&lt;li&gt;负载均衡&lt;/li&gt;
&lt;li&gt;分发与合并的开销与损耗&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;数据共享

&lt;ul&gt;
&lt;li&gt;并发与独占&lt;/li&gt;
&lt;li&gt;读与写&lt;/li&gt;
&lt;li&gt;Tools

&lt;ul&gt;
&lt;li&gt;锁(资源共享)&lt;/li&gt;
&lt;li&gt;信号量(线程同步)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Steps

&lt;ul&gt;
&lt;li&gt;Analysis:Find the concurrency&lt;/li&gt;
&lt;li&gt;Design&amp;amp;Implement:Thread model &amp;amp; algorithm&lt;/li&gt;
&lt;li&gt;Test&lt;/li&gt;
&lt;li&gt;Performance

&lt;ul&gt;
&lt;li&gt;Egs

&lt;ul&gt;
&lt;li&gt;False Sharing&lt;/li&gt;
&lt;li&gt;Bus Overload&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Model

&lt;ul&gt;
&lt;li&gt;PRAM(Parallel Random Access Machine)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;Todo&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;DesignModel

&lt;ul&gt;
&lt;li&gt;Task Decomposition

&lt;ul&gt;
&lt;li&gt;Granularity粒度

&lt;ul&gt;
&lt;li&gt;Coarse粗&lt;/li&gt;
&lt;li&gt;Fine细&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Dependency依赖

&lt;ul&gt;
&lt;li&gt;Order&lt;/li&gt;
&lt;li&gt;Data&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Scheduling调度

&lt;ul&gt;
&lt;li&gt;Dynamic&lt;/li&gt;
&lt;li&gt;Static&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Data Decomposition

&lt;ul&gt;
&lt;li&gt;Cell&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Steps

&lt;ul&gt;
&lt;li&gt;Performance&lt;/li&gt;
&lt;li&gt;简单&lt;/li&gt;
&lt;li&gt;可移植&lt;/li&gt;
&lt;li&gt;可伸缩&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Can&#39;t

&lt;ul&gt;
&lt;li&gt;Algorithm With status&lt;/li&gt;
&lt;li&gt;递推&lt;/li&gt;
&lt;li&gt;归纳Induction Variable&lt;/li&gt;
&lt;li&gt;归约Reduction&lt;/li&gt;
&lt;li&gt;Loop-Carried-Dependence&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;MultiThreadsDesignRules&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;找出真正独立的运算&lt;/li&gt;
&lt;li&gt;在尽可能高的层次上实现并发&lt;/li&gt;
&lt;li&gt;尽早考虑通过增加处理器核的数量来获得可伸缩性&lt;/li&gt;
&lt;li&gt;尽可能使用线程安全的库

&lt;ul&gt;
&lt;li&gt;MTK&lt;/li&gt;
&lt;li&gt;IPP&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;使用正确的线程模型

&lt;ul&gt;
&lt;li&gt;Library&lt;/li&gt;
&lt;li&gt;Framework

&lt;ul&gt;
&lt;li&gt;OpenMP&lt;/li&gt;
&lt;li&gt;Interl Threading Building block&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;永远不要假设程序会按照某种特定的顺序运行&lt;/li&gt;
&lt;li&gt;尽可能使用线程局部存储或与特定数据相关的锁&lt;/li&gt;
&lt;li&gt;BraveToRefactorCodeToGetPerformance&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;ThreadingFrameworks&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;OpenMP&lt;/li&gt;
&lt;li&gt;Interl Threading Building Blocks&lt;/li&gt;
&lt;li&gt;Erlang&lt;/li&gt;
&lt;li&gt;OpenMPI&lt;/li&gt;
&lt;li&gt;PThreads&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;Tools&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Debug

&lt;ul&gt;
&lt;li&gt;dbg&lt;/li&gt;
&lt;li&gt;dbx&lt;/li&gt;
&lt;li&gt;VTune(Checker)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Performance

&lt;ul&gt;
&lt;li&gt;gprof&lt;/li&gt;
&lt;li&gt;VTune&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;tags: Concurrency Rules Threads&lt;/h2&gt;
</content>
 </entry>
 
 <entry>
   <title>系统健康与分析</title>
   <link href="http://www.5wpc.info/it/technical/os/2012/12/09/SystemHealthAnalysis"/>
   <updated>2012-12-09T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/technical/os/2012/12/09/SystemHealthAnalysis</id>
   <content type="html">&lt;h1&gt;系统健康与分析&lt;/h1&gt;

&lt;h2&gt;内存&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;明确目标

&lt;ul&gt;
&lt;li&gt;用对比参照物(同类产品)&lt;/li&gt;
&lt;li&gt;量化目标(要优化多少)&lt;/li&gt;
&lt;li&gt;经验(可能存在的问题)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;获取数据

&lt;ul&gt;
&lt;li&gt;从整体到部分

&lt;ul&gt;
&lt;li&gt;系统级别total&lt;/li&gt;
&lt;li&gt;应用级别PSS,USS&lt;/li&gt;
&lt;li&gt;应用内级别smaps

&lt;ul&gt;
&lt;li&gt;Java-Heap&lt;/li&gt;
&lt;li&gt;Native-Heap&lt;/li&gt;
&lt;li&gt;Other-Modules&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Tools

&lt;ul&gt;
&lt;li&gt;SystemAPI

&lt;ul&gt;
&lt;li&gt;proc&lt;/li&gt;
&lt;li&gt;smaps&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Jhat&lt;/li&gt;
&lt;li&gt;MAT&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;定位问题

&lt;ul&gt;
&lt;li&gt;DS-5&lt;/li&gt;
&lt;li&gt;DependOn Data&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;给出方法

&lt;ul&gt;
&lt;li&gt;PageShared&lt;/li&gt;
&lt;li&gt;DirtyPage&lt;/li&gt;
&lt;li&gt;精简结构&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;性能&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;AIM

&lt;ul&gt;
&lt;li&gt;Compare&lt;/li&gt;
&lt;li&gt;The feature&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Data

&lt;ul&gt;
&lt;li&gt;Profile&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;SolveLevel

&lt;ul&gt;
&lt;li&gt;Strategy

&lt;ul&gt;
&lt;li&gt;Algorithm&lt;/li&gt;
&lt;li&gt;DataStructure&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Language

&lt;ul&gt;
&lt;li&gt;LanguageFeature&lt;/li&gt;
&lt;li&gt;Hotpoint&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Hardware

&lt;ul&gt;
&lt;li&gt;RAM

&lt;ul&gt;
&lt;li&gt;Cached&lt;/li&gt;
&lt;li&gt;loop&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ROM&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Solve&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;思想&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;具体问题具体分析&lt;/li&gt;
&lt;li&gt;明确目标&lt;/li&gt;
&lt;li&gt;数据说话&lt;/li&gt;
&lt;li&gt;前人经验&lt;/li&gt;
&lt;li&gt;Thought

&lt;ul&gt;
&lt;li&gt;究竟要优化什么？在一开始，你就应该清楚地了解你要达到的效果，以及其他优化相关的各种问题。&lt;/li&gt;
&lt;li&gt;选择一个正确的优化指标: 将最多的努力投入到运行消耗时间最多的那部分代码中. 需要注意的是，如果你轻易选择了一个很容易达到的指标，这作用不大，因为没有真正解决问题。你有必要选择一个更复杂的、更接近你的目标的指标。&lt;/li&gt;
&lt;li&gt;优化在刀刃上: 找到项目中与你的目标（性能、资源或其他）相背的地方，并将你的努力和时间用在那里。 不要分心于容易实现的问题&lt;/li&gt;
&lt;li&gt;优化层次越高越好: 根据这个标准，最好的优化是找到一个更有效的算法。&lt;/li&gt;
&lt;li&gt;不要过早优化: 你应该将项目开发和优化当作两个独立的步骤来做&lt;/li&gt;
&lt;li&gt;依赖性能分析，而不是直觉: 性能分析数据应该是第一位的，最后才是直觉。&lt;/li&gt;
&lt;li&gt;优化不是万金油: 你无法优化一切，甚至无法同时优化两个问题&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;tags: SystemOptimize&lt;/h2&gt;

&lt;h2&gt;具体方法&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;展开循环&lt;/li&gt;
&lt;li&gt;消除数据相关性&lt;/li&gt;
&lt;li&gt;数据并行处理&lt;/li&gt;
&lt;li&gt;优化引用数据结构&lt;/li&gt;
&lt;li&gt;减小数据结构的尺寸&lt;/li&gt;
&lt;li&gt;DRAM板块上的数据分布策略&lt;/li&gt;
&lt;li&gt;规划数据流&lt;/li&gt;
&lt;li&gt;按字节、双字与四字进行内存处理&lt;/li&gt;
&lt;li&gt;数据对齐&lt;/li&gt;
&lt;li&gt;内存访问与计算的组合&lt;/li&gt;
&lt;li&gt;读写操作的组合&lt;/li&gt;
&lt;li&gt;只在必要时才访问内存&lt;/li&gt;
&lt;li&gt;内置C内存处理函数的优化&lt;/li&gt;
&lt;li&gt;内存处理函数的优化质量&lt;/li&gt;
&lt;li&gt;C字符串库函数的优化&lt;/li&gt;
&lt;li&gt;字符串处理函数的质量优化&lt;/li&gt;
&lt;li&gt;块处理算法的优化&lt;/li&gt;
&lt;li&gt;大型数组排序的优化&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>GTD学习</title>
   <link href="http://www.5wpc.info/it/living/selfmanagement/2012/12/09/GTDStudy"/>
   <updated>2012-12-09T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/living/selfmanagement/2012/12/09/GTDStudy</id>
   <content type="html">&lt;h1&gt;GTD学习&lt;/h1&gt;

&lt;h2&gt;tags: Time&lt;/h2&gt;

&lt;h2&gt;What&amp;amp;Why&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;GTD原理图

&lt;ul&gt;
&lt;li&gt;&lt;img src=&quot;http://pic.yupoo.com/qianjigui/CtUtHgqw/4LTWR.jpg&quot; alt=&quot;GTD&quot; /&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://kb.cnblogs.com/page/139579/&quot;&gt;ReadingWebSide&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;How&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Tools

&lt;ul&gt;
&lt;li&gt;Wiki

&lt;ul&gt;
&lt;li&gt;Knowledge&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Calendar

&lt;ul&gt;
&lt;li&gt;Item&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Notebook

&lt;ul&gt;
&lt;li&gt;Evernote&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Project&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Plan&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;提高效率&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;有效利用时间

&lt;ul&gt;
&lt;li&gt;选择值得的工作&lt;/li&gt;
&lt;li&gt;一心三用&lt;/li&gt;
&lt;li&gt;列张清单&lt;/li&gt;
&lt;li&gt;整合清单与生活&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;提升时间质量

&lt;ul&gt;
&lt;li&gt;减少生理限制

&lt;ul&gt;
&lt;li&gt;随身携带纸和笔&lt;/li&gt;
&lt;li&gt;避免被打断&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;缓解心理束缚

&lt;ul&gt;
&lt;li&gt;吃饭，睡觉，锻炼&lt;/li&gt;
&lt;li&gt;与开朗的人为伍&lt;/li&gt;
&lt;li&gt;分担工作&lt;/li&gt;
&lt;li&gt;拖延症和精神力场&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;面对困难

&lt;ul&gt;
&lt;li&gt;分拆工作&lt;/li&gt;
&lt;li&gt;简化工作&lt;/li&gt;
&lt;li&gt;思考难题&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;被分配的任务

&lt;ul&gt;
&lt;li&gt;创建虚假任务&lt;/li&gt;
&lt;li&gt;不要给自己布置任务&lt;/li&gt;
&lt;li&gt;把事情变得有趣&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>RubyAuthorThinking</title>
   <link href="http://www.5wpc.info/it/technical/language/ruby/2012/09/23/RubyAuthorThinking"/>
   <updated>2012-09-23T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/technical/language/ruby/2012/09/23/RubyAuthorThinking</id>
   <content type="html">&lt;h1&gt;RubyAuthorThinking&lt;/h1&gt;

&lt;h2&gt;Design&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;原则

&lt;ul&gt;
&lt;li&gt;简洁性&lt;/li&gt;
&lt;li&gt;扩展性&lt;/li&gt;
&lt;li&gt;稳定性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Why

&lt;ul&gt;
&lt;li&gt;兴趣&lt;/li&gt;
&lt;li&gt;CodeForFun&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;OO

&lt;ul&gt;
&lt;li&gt;难点

&lt;ul&gt;
&lt;li&gt;多态性&lt;/li&gt;
&lt;li&gt;数据抽象

&lt;ul&gt;
&lt;li&gt;复杂性是面向对象的敌人&lt;/li&gt;
&lt;li&gt;结构化编程&lt;/li&gt;
&lt;li&gt;数据抽象化&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;继承

&lt;ul&gt;
&lt;li&gt;找出相似的部分来继承&lt;/li&gt;
&lt;li&gt;从多重继承变形而来的Mix-in&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Duck Typing

&lt;ul&gt;
&lt;li&gt;只关心行为&lt;/li&gt;
&lt;li&gt;避免明确的类型检查

&lt;ul&gt;
&lt;li&gt;CheckMethod&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;克服动态类型的缺点

&lt;ul&gt;
&lt;li&gt;UnitTest&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;元编程

&lt;ul&gt;
&lt;li&gt;反射&lt;/li&gt;
&lt;li&gt;Meta&lt;/li&gt;
&lt;li&gt;DSL&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;程序块

&lt;ul&gt;
&lt;li&gt;Block&lt;/li&gt;
&lt;li&gt;Yield&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;设计模式&lt;/h2&gt;

&lt;h2&gt;Web&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;RoR&lt;/li&gt;
&lt;li&gt;AJAX&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;语言实现的点&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;文字编码

&lt;ul&gt;
&lt;li&gt;UTF8&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;正则表达式&lt;/li&gt;
&lt;li&gt;整数和浮点小数&lt;/li&gt;
&lt;li&gt;高速执行

&lt;ul&gt;
&lt;li&gt;profiler&lt;/li&gt;
&lt;li&gt;Methods

&lt;ul&gt;
&lt;li&gt;削减对象&lt;/li&gt;
&lt;li&gt;利用立即值&lt;/li&gt;
&lt;li&gt;利用C 语言&lt;/li&gt;
&lt;li&gt;采用合适的数据结构&lt;/li&gt;
&lt;li&gt;全部以C语言计算&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;并行处理

&lt;ul&gt;
&lt;li&gt;多线程&lt;/li&gt;
&lt;li&gt;Syn&lt;/li&gt;
&lt;li&gt;lock&lt;/li&gt;
&lt;li&gt;mutex&lt;/li&gt;
&lt;li&gt;Actor

&lt;ul&gt;
&lt;li&gt;Erlang&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;程序安全性

&lt;ul&gt;
&lt;li&gt;Exception&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;关于时间的处理&lt;/li&gt;
&lt;li&gt;关于数据的持久化

&lt;ul&gt;
&lt;li&gt;Marshal&lt;/li&gt;
&lt;li&gt;YAML&lt;/li&gt;
&lt;li&gt;XML&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;函数式编程

&lt;ul&gt;
&lt;li&gt;Block&lt;/li&gt;
&lt;li&gt;Erlang&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>BeautifulCode</title>
   <link href="http://www.5wpc.info/it/technical/architecture/2012/09/21/BeautifulCode"/>
   <updated>2012-09-21T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/technical/architecture/2012/09/21/BeautifulCode</id>
   <content type="html">&lt;h1&gt;BeautifulCode&lt;/h1&gt;

&lt;h2&gt;RegularMatcher&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;选择合适的功能集合&lt;/li&gt;
&lt;li&gt;正确使用递归&lt;/li&gt;
&lt;li&gt;选择恰当的语言語法&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;Subversion中的增量编辑器&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;漂亮的API能够指导我们思考&lt;/li&gt;
&lt;li&gt;节约学习时间&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;QuickSort性能分析&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;少为多&lt;/li&gt;
&lt;li&gt;多做程序分析

&lt;ul&gt;
&lt;li&gt;修改这个程序&lt;/li&gt;
&lt;li&gt;在具有代表性的数据上运行&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;多将功能凝聚成小段代码&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;WhichIs&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;CleanCode

&lt;ul&gt;
&lt;li&gt;容易与其他人协作（简单、意图明确、良好的抽象、不出意料、合适的名称）&lt;/li&gt;
&lt;li&gt;针对现实世界，比如，有一个清晰的错误处理策略&lt;/li&gt;
&lt;li&gt;代码作者显然很关心软件和其他开发者（针对双方的可读性和可维护性）&lt;/li&gt;
&lt;li&gt;最小化（做一件事，最小的依赖）&lt;/li&gt;
&lt;li&gt;以最合适的方式解决问题&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;tags: Design&lt;/h2&gt;
</content>
 </entry>
 
 <entry>
   <title>DebugHacks</title>
   <link href="http://www.5wpc.info/it/technical/debug/2012/09/16/DebugHacks"/>
   <updated>2012-09-16T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/technical/debug/2012/09/16/DebugHacks</id>
   <content type="html">&lt;h1&gt;DebugHacks&lt;/h1&gt;

&lt;h2&gt;思路图&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Image

&lt;ul&gt;
&lt;li&gt;&lt;img src=&quot;http://pic.yupoo.com/qianjigui/ClqS2IyK/medish.jpg&quot; alt=&quot;Don&#39;t Response&quot; /&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src=&quot;http://pic.yupoo.com/qianjigui/ClqS39ys/medish.jpg&quot; alt=&quot;AppExitUnUsual&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Invoke API

&lt;ul&gt;
&lt;li&gt;Debug API

&lt;ul&gt;
&lt;li&gt;valgrind&lt;/li&gt;
&lt;li&gt;dump&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;System status API

&lt;ul&gt;
&lt;li&gt;proc&lt;/li&gt;
&lt;li&gt;sys&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;System API

&lt;ul&gt;
&lt;li&gt;Invoke function&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;目录

&lt;ul&gt;
&lt;li&gt;http://book.douban.com/subject/6799412/&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;心得&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;复现

&lt;ul&gt;
&lt;li&gt;之前

&lt;ul&gt;
&lt;li&gt;配置环境&lt;/li&gt;
&lt;li&gt;听取发现人的意见(先自己总结)&lt;/li&gt;
&lt;li&gt;再次检查环境&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;之后

&lt;ul&gt;
&lt;li&gt;确认现象&lt;/li&gt;
&lt;li&gt;确认复现率和时间&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;分析时

&lt;ul&gt;
&lt;li&gt;目视确认现象&lt;/li&gt;
&lt;li&gt;尽量缩小范围&lt;/li&gt;
&lt;li&gt;根据内核配置、内核启动参数划分问题&lt;/li&gt;
&lt;li&gt;根据版本划分问题&lt;/li&gt;
&lt;li&gt;通过其他方法确认

&lt;ul&gt;
&lt;li&gt;lsusb&lt;/li&gt;
&lt;li&gt;lsof&lt;/li&gt;
&lt;li&gt;ip&lt;/li&gt;
&lt;li&gt;route&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;根据事实做出判断&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;问题原因不明

&lt;ul&gt;
&lt;li&gt;怀疑硬件问题&lt;/li&gt;
&lt;li&gt;找找以前改正的同类错误&lt;/li&gt;
&lt;li&gt;无法复现、原因不明

&lt;ul&gt;
&lt;li&gt;增加log、方便下次定位&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;为bug发生做准备

&lt;ul&gt;
&lt;li&gt;log&lt;/li&gt;
&lt;li&gt;abort&lt;/li&gt;
&lt;li&gt;assert&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;跟同事讨论&lt;/li&gt;
&lt;li&gt;咨询社区&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;Basic&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;CoreDump

&lt;ul&gt;
&lt;li&gt;OpenUse

&lt;ul&gt;
&lt;li&gt;ulimit -c unlimited&lt;/li&gt;
&lt;li&gt;ulimit -c 1024&lt;/li&gt;
&lt;li&gt;./a.out&lt;/li&gt;
&lt;li&gt;file core*&lt;/li&gt;
&lt;li&gt;gdb -c core.xxxx ./a.out&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;OpenSystem&lt;/li&gt;
&lt;li&gt;Space

&lt;ul&gt;
&lt;li&gt;ToSpecialDir&lt;/li&gt;
&lt;li&gt;tar&lt;/li&gt;
&lt;li&gt;MaskSharedMemoryDump&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;gdb

&lt;ul&gt;
&lt;li&gt;run&lt;/li&gt;
&lt;li&gt;break

&lt;ul&gt;
&lt;li&gt;function&lt;/li&gt;
&lt;li&gt;line-number&lt;/li&gt;
&lt;li&gt;file:line&lt;/li&gt;
&lt;li&gt;file:function&lt;/li&gt;
&lt;li&gt;+offset&lt;/li&gt;
&lt;li&gt;-offset&lt;/li&gt;
&lt;li&gt;*addr&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;backtrace&lt;/li&gt;
&lt;li&gt;print&lt;/li&gt;
&lt;li&gt;info reg&lt;/li&gt;
&lt;li&gt;continue&lt;/li&gt;
&lt;li&gt;next&lt;/li&gt;
&lt;li&gt;step&lt;/li&gt;
&lt;li&gt;set variabel var=exptr&lt;/li&gt;
&lt;li&gt;generate-core-file&lt;/li&gt;
&lt;li&gt;attach&lt;/li&gt;
&lt;li&gt;break xxx if exptr&lt;/li&gt;
&lt;li&gt;ignore breakpoint-number times&lt;/li&gt;
&lt;li&gt;clear

&lt;ul&gt;
&lt;li&gt;all(no arg)&lt;/li&gt;
&lt;li&gt;function&lt;/li&gt;
&lt;li&gt;line&lt;/li&gt;
&lt;li&gt;file:line&lt;/li&gt;
&lt;li&gt;file:func&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;delete bpn&lt;/li&gt;
&lt;li&gt;disable

&lt;ul&gt;
&lt;li&gt;all(no arg)&lt;/li&gt;
&lt;li&gt;bpn&lt;/li&gt;
&lt;li&gt;display xxx&lt;/li&gt;
&lt;li&gt;mem&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;应用程序调试&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;SIGSEGV

&lt;ul&gt;
&lt;li&gt;系统层面的signal&lt;/li&gt;
&lt;li&gt;Maybe

&lt;ul&gt;
&lt;li&gt;StackOverflow&lt;/li&gt;
&lt;li&gt;WrongAddressAccess

&lt;ul&gt;
&lt;li&gt;NULL-pointer&lt;/li&gt;
&lt;li&gt;Wrong-Pointer&lt;/li&gt;
&lt;li&gt;OutOfBound-Memory&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;backtrace无法显示

&lt;ul&gt;
&lt;li&gt;Reason

&lt;ul&gt;
&lt;li&gt;程序栈被破坏&lt;/li&gt;
&lt;li&gt;so没有源程序&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Find

&lt;ul&gt;
&lt;li&gt;根据被破坏的数据内容，查找执行写入的位置，看看有没有对栈空间(局部变量)的引用、指针传递处理&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;watch *addr&lt;/li&gt;
&lt;li&gt;malloc/free

&lt;ul&gt;
&lt;li&gt;MALLOC_CHECK_&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;Android系统死机调试&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;发生死机时的测试

&lt;ul&gt;
&lt;li&gt;看屏幕与按键是否有反应&lt;/li&gt;
&lt;li&gt;电话可否打入&lt;/li&gt;
&lt;li&gt;USB可否连接&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;USB测试

&lt;ul&gt;
&lt;li&gt;是否有事件产生&lt;/li&gt;
&lt;li&gt;系统状态

&lt;ul&gt;
&lt;li&gt;CPU&lt;/li&gt;
&lt;li&gt;Memory&lt;/li&gt;
&lt;li&gt;Mount size&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;SystemServer状况

&lt;ul&gt;
&lt;li&gt;信号级别调试&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;Unix&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Crash

&lt;ul&gt;
&lt;li&gt;Core dump&lt;/li&gt;
&lt;li&gt;ulimit

&lt;ul&gt;
&lt;li&gt;设置和查看用户的使用的资源限制情况&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;内存泄露

&lt;ul&gt;
&lt;li&gt;Purify&lt;/li&gt;
&lt;li&gt;valgrind&lt;/li&gt;
&lt;li&gt;free&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;性能不满足预期

&lt;ul&gt;
&lt;li&gt;prtdiag&lt;/li&gt;
&lt;li&gt;prstat&lt;/li&gt;
&lt;li&gt;top&lt;/li&gt;
&lt;li&gt;ps

&lt;ul&gt;
&lt;li&gt;ps -e -o user,pid,ppid,tid,time,%cpu,cmd --sort=%cpu&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;句柄泄露

&lt;ul&gt;
&lt;li&gt;iostat

&lt;ul&gt;
&lt;li&gt;报告中央处理单元（中央处理器）统计和输入 / 输出设备和分区统计&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;lsof&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Others

&lt;ul&gt;
&lt;li&gt;nm

&lt;ul&gt;
&lt;li&gt;显示目标文件的符号表信息&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ldd –显示动态库的依赖信息&lt;/li&gt;
&lt;li&gt;pstack（Solaris， Linux）， procstack（AIX）– 打印十六进制地址和符号名称&lt;/li&gt;
&lt;li&gt;pmap(Solaris, Linux), procmap(AIX) –打印地址空间映射&lt;/li&gt;
&lt;li&gt;pldd(Solaris), procldd(AIX) —列出进程加载的库&lt;/li&gt;
&lt;li&gt;pfiles(Solaris), procfiles(AIX)– 报告有关的所有文件描述符&lt;/li&gt;
&lt;li&gt;prstat(Solaris), ps -e -o user,pid,ppid,tid,time,%cpu,cmd –sort=%cpu(Linux)– 检查每个线程的处理器&lt;/li&gt;
&lt;li&gt;pwdx（Linux，Solaris）  pid 显示当前工作目录&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;img src=&quot;http://pic.yupoo.com/qianjigui/CIwePulE/11Uyc9.jpg&quot; alt=&quot;UnixProfile&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;tools&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;strace

&lt;ul&gt;
&lt;li&gt;std:run with kernel invoke&lt;/li&gt;
&lt;li&gt;-i: run with addr

&lt;ul&gt;
&lt;li&gt;gdb break by addr&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;-p pid&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;objdump&lt;/li&gt;
&lt;li&gt;valgrind

&lt;ul&gt;
&lt;li&gt;check

&lt;ul&gt;
&lt;li&gt;memory leak&lt;/li&gt;
&lt;li&gt;wrong address access&lt;/li&gt;
&lt;li&gt;read uninited memory&lt;/li&gt;
&lt;li&gt;access free mem&lt;/li&gt;
&lt;li&gt;double free&lt;/li&gt;
&lt;li&gt;stack error opt&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;tags: Tool&lt;/h2&gt;
</content>
 </entry>
 
 <entry>
   <title>垃圾收集技术</title>
   <link href="http://www.5wpc.info/it/technical/vm/2012/08/18/GC"/>
   <updated>2012-08-18T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/technical/vm/2012/08/18/GC</id>
   <content type="html">&lt;h1&gt;GC&lt;/h1&gt;

&lt;h2&gt;标记清扫算法&lt;/h2&gt;

&lt;h3&gt;标记数据&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;位图

&lt;ul&gt;
&lt;li&gt;额外空间开销&lt;/li&gt;
&lt;li&gt;减少了标记阶段中的缺页错误和cache写失误的发生率&lt;/li&gt;
&lt;li&gt;速度较快&lt;/li&gt;
&lt;li&gt;Dalvik 实现中是有两个bitmap，一个用于记录目前的活动对象，一个用于记录标记过程的可触及对象。然后暂停系统，对比bitmap进行释放标记。基于bitmap，实现一个根保守的栈mark操作成为可能。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;对象

&lt;ul&gt;
&lt;li&gt;具有跳跃性

&lt;ul&gt;
&lt;li&gt;影响cache&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;栈溢出(引用层次太多)

&lt;ul&gt;
&lt;li&gt;显示调用栈(容易栈溢出)&lt;/li&gt;
&lt;li&gt;手工维护

&lt;ul&gt;
&lt;li&gt; 定量栈+遍历堆&lt;/li&gt;
&lt;li&gt; 反向指针&lt;/li&gt;
&lt;li&gt; 循环使用栈&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;清扫阶段&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;立刻清扫&lt;/li&gt;
&lt;li&gt;延迟清扫

&lt;ul&gt;
&lt;li&gt;bdw&lt;/li&gt;
&lt;li&gt;Boehm-Demers-Weiser(多层次分配器，高层次分配器将请求流转到不同的子分配器，子分配器只负责统一大小数据的分配和回收。)

&lt;ul&gt;
&lt;li&gt;子分配器

&lt;ul&gt;
&lt;li&gt;采用渐进式回收&lt;/li&gt;
&lt;li&gt;考虑数据组织结构&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Hughes(每次分配时完成一定数量的清扫工作。对alloc的每次调用都会清扫堆，直到它找到一个合适的自由节点。)

&lt;ul&gt;
&lt;li&gt;回收中断变短&lt;/li&gt;
&lt;li&gt;来回操作位图，不高效&lt;/li&gt;
&lt;li&gt;能够直接利用回收节点，不用交还给空闲列表&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Zorn(也是分层次的数据组织形式，不过不是用链表串联，而是是用一个数组进行管理。)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;遍历堆&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;总结&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;优点

&lt;ul&gt;
&lt;li&gt;不需要移动对象&lt;/li&gt;
&lt;li&gt;利用了空间和时间的局部性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;缺点

&lt;ul&gt;
&lt;li&gt;空闲空间的组织方式

&lt;ul&gt;
&lt;li&gt;这也是标记清扫算法除需要中断机器的最主要问题。 以Dalvik为例，其为了避免这个问题不是自己来管理一块大空间的内存，而是通过dlmalloc来接管下面的数据。 所以其关键就是dlmalloc对于内存布局的合理分配。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;碎片较多&lt;/li&gt;
&lt;li&gt;不同工作集的数据交织在一起

&lt;ul&gt;
&lt;li&gt;影响了空间局部性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;标记缩并&lt;/h2&gt;

&lt;h3&gt;碎片现象&lt;/h3&gt;

&lt;p&gt;制作符合目标的分配器:
* 伙伴系统
* 两级分配
    * 堆不必连续
    * 缓解碎片
* 首次匹配
* 最佳匹配&lt;/p&gt;

&lt;h3&gt;缩并的方式&lt;/h3&gt;

&lt;h4&gt;考虑因素&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;处理不同大小的对象&lt;/li&gt;
&lt;li&gt;为了重新安放对象和更新指针，算法需要遍历堆几次&lt;/li&gt;
&lt;li&gt;算法需要多少额外的空间&lt;/li&gt;
&lt;li&gt;算法是否需要对指针施加某种限制（内部指针、回指）&lt;/li&gt;
&lt;li&gt;每一步需要做多少工作&lt;/li&gt;
&lt;/ul&gt;


&lt;h4&gt;单元排序方式&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;滑动的: 将活动单元滑动到堆的一端，把存活单元之间的自由单元“挤出去”，从而维持了分配是的原始次序。&lt;/li&gt;
&lt;li&gt;线性: 尽可能的将原来的单元和他所指向的单元放在相邻的位置。例如：以深度优先次序复制图中的节点的节点复制器可以利用类似cdr-coding这样的技术对数据结构进行压缩&lt;/li&gt;
&lt;li&gt;任意&lt;/li&gt;
&lt;/ul&gt;


&lt;h4&gt;三个阶段&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;标记存活的数据结构&lt;/li&gt;
&lt;li&gt;通过重新安防单元来缩并这些单元构成的图&lt;/li&gt;
&lt;li&gt;更新指向被移动了的单元的指针&lt;/li&gt;
&lt;/ol&gt;


&lt;h4&gt;现有的算法&lt;/h4&gt;

&lt;p&gt;双指针算法：使用两个指针，一个指向下一个空闲的位置，另一个指向下一个要移动的存活单元。单元被移动之后，在他们原先的位置上留下一个迁移地址。这类方法一般只能适用于固定大小的单元。&lt;/p&gt;

&lt;p&gt;迁移地址算法：在移动单元之前，把迁移地址写入每个单元的一个附加区域中。这一类方法可以用于收集不同大小的节点。&lt;/p&gt;

&lt;p&gt;基于表的方法：在重新安放单元之前或是与之同时，在堆中构造一个存放重新安放单元的相关信息的映射表。这个表通常被称为间断表。算法将在以后查阅这个表，借助它计算指针的新值。&lt;/p&gt;

&lt;p&gt;穿线方法：每个单元被链入一个链表，其中包含了所有原先指向他的单元。当单元转移时，算法通过这个链表做调整。&lt;/p&gt;

&lt;h5&gt;Lisp2(forward指针)&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;算法是一种滑动缩并算法，需要在每个对象的头部添加一个指针域forwarding用于存放该对象下一个新位置，并且需要进行三次堆扫描：

&lt;ol&gt;
&lt;li&gt; 计算存活对象的新位置并存到forwarding：其实就是移动算法。从heap起始位置做紧凑性压缩准备，对象新地址基于当前已占用空间的大小&lt;/li&gt;
&lt;li&gt; 更新存活对象的指针域==指向对象的forwarding域&lt;/li&gt;
&lt;li&gt; 存活对象基于forwarding移动&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Forwarding指针&lt;/li&gt;
&lt;li&gt;三遍扫描&lt;/li&gt;
&lt;/ul&gt;


&lt;h5&gt;穿线方法&lt;/h5&gt;

&lt;p&gt;将指向同一个地址的指针利用链表（已有链表）串联起来，然后等新数据确定后再更新数据。
1. A-&gt;P, B-&gt;P, C-&gt;P
1. P==Data
1. P-&gt; C-&gt;B-&gt;A==Data
1. 在P更新地址后，在遍历链表更新数据。&lt;/p&gt;

&lt;h6&gt;Jonkers&lt;/h6&gt;

&lt;ul&gt;
&lt;li&gt;操作本对象时涉及其他对象(工作集外面)&lt;/li&gt;
&lt;li&gt;穿线工作量很大&lt;/li&gt;
&lt;li&gt;该算法的限制：

&lt;ol&gt;
&lt;li&gt; 指针只能指向单元的头部&lt;/li&gt;
&lt;li&gt; 单元头的大小必须足以存放一个地址&lt;/li&gt;
&lt;li&gt; 单元头必须包含能够同指向堆的指针区分开来的数据&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;具体:

&lt;ul&gt;
&lt;li&gt;两次遍历：

&lt;ol&gt;
&lt;li&gt; 处理前向指针(forward pointer)：较低地址指向较高地址的指针&lt;/li&gt;
&lt;li&gt; 处理后向指针(backward pointer)：较高地址指向较低地址的指针&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;这个模型也需要看系统体系结构中数据的组织形式，是否有一个可以容纳空间的对象头。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h5&gt;基于表的方法&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;利用空闲区域存放: 利用堆空间自身，做迁移数据的保存。可以说是对forwarding的改进：不需要单独的存储空间。&lt;/li&gt;
&lt;li&gt;间断表: 在空闲区域存放间断表，间断表记录：(存活块的起始位置，到目前空闲块时已经发现的空闲空间大小）。 在完成扫描后可以基于该表进行指针更新。&lt;/li&gt;
&lt;/ul&gt;


&lt;h5&gt;双指针算法&lt;/h5&gt;

&lt;p&gt;该算法首先标记存活数据结构，并记录存活单元的数量，结果记为nlive
1. 第一次遍历将堆中较高的部分（高于Heap[nlive]）的单元重新安放到较低部分的空洞里，并把迁移地址写入腾出的空间的第一个区域。
1. 第二次遍历扫描堆中较低的部分中的单元（到Heap[nlive]为止），更新其中的指针并使之指向新的位置。&lt;/p&gt;

&lt;p&gt;在这里双指针的概念主要是指----算法使用两个指针：
1. free从堆的底部开始扫描，寻找自由节点
1. live则从堆的顶部开始扫描，寻找存活单元
1. 当free==live时第一次堆扫描完毕&lt;/p&gt;

&lt;p&gt;重新安放单元的次序是随机的.&lt;/p&gt;

&lt;h6&gt;处理相同大小的数据单元&lt;/h6&gt;

&lt;ul&gt;
&lt;li&gt;多次alloc，不同大小分配于不同堆区&lt;/li&gt;
&lt;li&gt;将可变大小的数据缩并到堆中干净的页面中去:

&lt;ul&gt;
&lt;li&gt;Bartlett:

&lt;ol&gt;
&lt;li&gt; 当整个堆被填满的部分超过85%时，它被用来追踪和缩并最年老的分代。&lt;/li&gt;
&lt;li&gt; 核心想法：把堆Heap分成固定大小的块block。有自由（空闲）块、和其他已经活动的块。&lt;/li&gt;
&lt;li&gt; 对象从当前的自由块中分配，为此只需要增大一个指针。&lt;/li&gt;
&lt;li&gt; 在缩并阶段，尽可能地减少在块之间移动的数据量，用轻微的碎片现象换取减少移动。其主要是缩并单个块而不是整个堆。&lt;/li&gt;
&lt;li&gt; 第一次扫描，寻找不到1/3满的块，把这些块上被标记的单元移动到当前自由块中，并留下一个迁移地址；而更满的块不会被处理。&lt;/li&gt;
&lt;li&gt; 队列中还有另外一个备用的自由块，用于防止自由块出现溢出。&lt;/li&gt;
&lt;li&gt; 第二次扫描时，和双指针算法相同进行指针更新处理。&lt;/li&gt;
&lt;li&gt; 利用自由块作为一层中间数据，缩并时先使用自由块空间。&lt;/li&gt;
&lt;li&gt; 块分为：自由块（空闲块）、刚刚进行分配使用的块（新对象）、发生了归并处理的块（对象已经移动，块中包含了迁移地址，不能被直接拿去使用）、归并处理结束包含数据已经完全没用的块&lt;/li&gt;
&lt;li&gt; Dalvik Copying算法基本上是使用了这种思想。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;指针域更新问题&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;动态更新所有指针域&lt;/li&gt;
&lt;li&gt;利用对象句柄&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;节点复制垃圾收集&lt;/h2&gt;

&lt;p&gt;如果存活数据在整个堆中只占很小的一部分，那么节点复制技术就特别有吸引力。&lt;/p&gt;

&lt;p&gt;利用多余的连续空间，将数据从一端完整的滑向另一端，原数据的不变性也保证了指针更新。&lt;/p&gt;

&lt;p&gt;三色法思路，scan&amp;amp;free指针&lt;/p&gt;

&lt;h3&gt;对象重组&lt;/h3&gt;

&lt;p&gt;主要是提高空间局部性，这主要由：
* 对象访问模式
* 对象组织模式
* 对象内部数据指针指向模式等具体情况&lt;/p&gt;

&lt;h3&gt;多区域收集&lt;/h3&gt;

&lt;h4&gt;大型对象区域&lt;/h4&gt;

&lt;p&gt;大型对象利用单独的存储空间进行处理，以减少移动带来的开销。&lt;/p&gt;

&lt;p&gt;最好这些大型对象时原数据，即像图像这种不带有指针的数据。&lt;/p&gt;

&lt;p&gt;甚至于可以和支持虚拟内存系统的OS做交互，修改页表映射做处理。&lt;/p&gt;

&lt;h4&gt;渐进的递增缩并垃圾收集&lt;/h4&gt;

&lt;p&gt;将数据分成很多小的block，然后每次只对一部分block做归并收集。&lt;/p&gt;

&lt;h4&gt;静态区域&lt;/h4&gt;

&lt;h3&gt;节点复制的效率&lt;/h3&gt;

&lt;p&gt;通过扩展堆的大小，可以任意地降低节点复制垃圾收集的平均成本。&lt;/p&gt;

&lt;p&gt;但是和标记清扫收集，其空间局部性很差。主要是由于整个数据从一个半区T移动到另外一个半区F。
可能F需要被重新换入主存，而T在主存的优势也完全丧失了。&lt;/p&gt;

&lt;h3&gt;双边收集(top&amp;amp;bottom)&lt;/h3&gt;

&lt;h2&gt;分代垃圾收集&lt;/h2&gt;

&lt;p&gt;分代的代提升策略：
* 多个分代
* 利用阈值判断
* 自适应&lt;/p&gt;

&lt;p&gt;分代组织和年龄纪录：
* 每个分代一个半区
* 创建一个附属空间
* 记录年龄
* 大型对象区域&lt;/p&gt;

&lt;p&gt;分代间指针的管理：主要是涉及到mark时根节点集合（只会扫描该分代对象，较老分代的引用就需要作为根节点处理）：
* 拦截器
* 各个分代一个入口表
* 记忆集
* 顺序保存缓冲区
* 硬件支持的页面标记
* 虚存系统支持的页面标记
* 卡片标记
* 记忆集与卡片可以相互结合&lt;/p&gt;

&lt;h3&gt;分代与对象生命周期&lt;/h3&gt;

&lt;p&gt;对象的生命周期与特定应用场景有关，并不能够通过一种简单的途径假设。&lt;/p&gt;

&lt;p&gt;目前已经普遍存在的假设：
* 强分代假设：越老的对象与不可能死亡。这种假设一般是不成立的。
* 弱分代假设：大多数对象在年轻时死亡&lt;/p&gt;

&lt;p&gt;有些比较可观的结论：
* 对象生命周期的分布是&quot;成块&quot;的。&lt;/p&gt;

&lt;p&gt;目前CRuby已经在2.1.0上采用了混合MarkSweep与分代式GC的策略.
&lt;a href=&quot;http://www.infoq.com/cn/news/2013/12/ruby21&quot;&gt;Ruby2.1.0GC&lt;/a&gt;
其中有一些GC方面的分析技术与手段思路还是可以借见的.&lt;/p&gt;

&lt;h2&gt;渐进式和并发垃圾收集&lt;/h2&gt;

&lt;p&gt;主要是进行并发时的保护，主要是通过拦截器完成。&lt;/p&gt;

&lt;p&gt;借助三色方案~&lt;/p&gt;

&lt;h3&gt;MarkSweep&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Dalvik MarkSweep&lt;/li&gt;
&lt;li&gt;Write-Barrier

&lt;ul&gt;
&lt;li&gt;dvmWriteBarrierField

&lt;ul&gt;
&lt;li&gt; dvmSetFieldObject

&lt;ul&gt;
&lt;li&gt; createArrayClass&lt;/li&gt;
&lt;li&gt; loadClassFromDex0&lt;/li&gt;
&lt;li&gt; dvmLinkClass&lt;/li&gt;
&lt;li&gt; dvmInitClass&lt;/li&gt;
&lt;li&gt; setInstFieldValue&lt;/li&gt;
&lt;li&gt; SET_TYPE_FIELD(Jni.cpp)&lt;/li&gt;
&lt;li&gt; enqueuePendingReference&lt;/li&gt;
&lt;li&gt; dequeuePendingReference&lt;/li&gt;
&lt;li&gt; clearReference&lt;/li&gt;
&lt;li&gt; enqueueFinalizerReferences&lt;/li&gt;
&lt;li&gt; DVM_OBJECT_INIT&lt;/li&gt;
&lt;li&gt; dvmGenerateProxyClass&lt;/li&gt;
&lt;li&gt; proxyConstructor&lt;/li&gt;
&lt;li&gt; dvmPrepMainThread&lt;/li&gt;
&lt;li&gt; dvmCreateInterpThread&lt;/li&gt;
&lt;li&gt; dvmAttachCurrentThread&lt;/li&gt;
&lt;li&gt; dvmDetachCurrentThread&lt;/li&gt;
&lt;li&gt; makeStringObject&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt; dvmSetFieldObjectVolatile

&lt;ul&gt;
&lt;li&gt; setInstFieldValue&lt;/li&gt;
&lt;li&gt; SET_TYPE_FIELD(Jni.cpp)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt; dvmSetFieldStaticObject&lt;/li&gt;
&lt;li&gt; dvmSetFieldStaticObjectVolatile&lt;/li&gt;
&lt;li&gt; Dalvik_sun_misc_Unsafe_compareAndSwapObject&lt;/li&gt;
&lt;li&gt; Dalvik_sun_misc_Unsafe_putObjectVolatile&lt;/li&gt;
&lt;li&gt; Dalvik_sun_misc_Unsafe_putObject&lt;/li&gt;
&lt;li&gt; Dalvik_sun_misc_Unsafe_putOrderedObject&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;dvmWriteBarrierObject&lt;/li&gt;
&lt;li&gt;dvmWriteBarrierArray

&lt;ul&gt;
&lt;li&gt; goto_target&lt;/li&gt;
&lt;li&gt; Dalvik_java_lang_System_arraycopy&lt;/li&gt;
&lt;li&gt; dvmSetObjectArrayElement&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;dvmGetInterfaces&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>虚拟机技术相关概要</title>
   <link href="http://www.5wpc.info/it/technical/vm/2012/08/08/index"/>
   <updated>2012-08-08T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/technical/vm/2012/08/08/index</id>
   <content type="html">&lt;h1&gt;虚拟机(Virtual Machines)&lt;/h1&gt;

&lt;h2&gt;介绍(Introduction)&lt;/h2&gt;

&lt;h3&gt;计算机体系结构(Computer Architecture)&lt;/h3&gt;

&lt;h2&gt;语言虚拟机&lt;/h2&gt;

&lt;p&gt;目前有大量的语言虚拟机出现，对具体使用环境的支持越发成熟。&lt;/p&gt;

&lt;h3&gt;Internal Structure&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Class model&lt;/li&gt;
&lt;li&gt;Class loader&lt;/li&gt;
&lt;li&gt;Threads Sync&lt;/li&gt;
&lt;li&gt;Objects 保护机制&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;Heap&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;GC&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;Native Interface&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;JNI&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;Interp&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Stack-mode&lt;/li&gt;
&lt;li&gt;Register-mode&lt;/li&gt;
&lt;li&gt;AOT&lt;/li&gt;
&lt;li&gt;JIT&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;Tools&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Heap: MAT, JHAT, Hprof, information&lt;/li&gt;
&lt;li&gt;Debugger&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;Examples&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Facebook已将HHVM/JIT用于其开发和产品中

&lt;ol&gt;
&lt;li&gt; HHVM这样运行PHP程序，先将PHP源代码转换为HipHop字节码（HHBC），然后使用字节码解释器和x64 JIT编译器来执行字节码。&lt;/li&gt;
&lt;li&gt; 这里的解释器和编译器可以无缝地进行互操作。&lt;/li&gt;
&lt;li&gt; HHVM会尽可能使用JIT，万不得已时才将解释器作为执行引擎。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>Virtual Machines</title>
   <link href="http://www.5wpc.info/it/technical/vm/2012/08/08/VirtualMachines"/>
   <updated>2012-08-08T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/technical/vm/2012/08/08/VirtualMachines</id>
   <content type="html">&lt;h1&gt;Virtual Machines&lt;/h1&gt;

&lt;h2&gt;导论&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;计算机体系结构

&lt;ul&gt;
&lt;li&gt;概念

&lt;ul&gt;
&lt;li&gt;ISA(Instruction Set Architecture)指令集体系结构

&lt;ul&gt;
&lt;li&gt;user ISA&lt;/li&gt;
&lt;li&gt;system ISA&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ABI(Application Binary Interface)应用二进制接口&lt;/li&gt;
&lt;li&gt;API(Application Program Interface)应用编程接口&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;img src=&quot;http://pic.yupoo.com/qianjigui/CaVbCW9i/medish.jpg&quot; alt=&quot;http://pic.yupoo.com/qianjigui/CaVbCW9i/medish.jpg&quot; /&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src=&quot;http://pic.yupoo.com/qianjigui/CaVcUY2N/medish.jpg&quot; alt=&quot;http://pic.yupoo.com/qianjigui/CaVcUY2N/medish.jpg&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;VM-base

&lt;ul&gt;
&lt;li&gt;&lt;img src=&quot;http://pic.yupoo.com/qianjigui/CaVbEzly/medish.jpg&quot; alt=&quot;http://pic.yupoo.com/qianjigui/CaVbEzly/medish.jpg&quot; /&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src=&quot;http://pic.yupoo.com/qianjigui/CaVbHPeS/medish.jpg&quot; alt=&quot;http://pic.yupoo.com/qianjigui/CaVbHPeS/medish.jpg&quot; /&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src=&quot;http://pic.yupoo.com/qianjigui/CaVbMx2U/medish.jpg&quot; alt=&quot;http://pic.yupoo.com/qianjigui/CaVbMx2U/medish.jpg&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;进程VM

&lt;ul&gt;
&lt;li&gt;多进程支持级别&lt;/li&gt;
&lt;li&gt;仿真器和动态二进制翻译器

&lt;ul&gt;
&lt;li&gt;&lt;img src=&quot;http://pic.yupoo.com/qianjigui/CaVbFSZm/medish.jpg&quot; alt=&quot;http://pic.yupoo.com/qianjigui/CaVbFSZm/medish.jpg&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;相同ISA下的二进制优化器&lt;/li&gt;
&lt;li&gt;HLL-VM

&lt;ul&gt;
&lt;li&gt;&lt;img src=&quot;http://pic.yupoo.com/qianjigui/CaVbE2FD/medish.jpg&quot; alt=&quot;http://pic.yupoo.com/qianjigui/CaVbE2FD/medish.jpg&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;系统VM

&lt;ul&gt;
&lt;li&gt;&lt;img src=&quot;http://pic.yupoo.com/qianjigui/CaVbIPjz/medish.jpg&quot; alt=&quot;http://pic.yupoo.com/qianjigui/CaVbIPjz/medish.jpg&quot; /&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src=&quot;http://pic.yupoo.com/qianjigui/CaVbBtBs/medish.jpg&quot; alt=&quot;http://pic.yupoo.com/qianjigui/CaVbBtBs/medish.jpg&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;分类

&lt;ul&gt;
&lt;li&gt;进程VM

&lt;ul&gt;
&lt;li&gt;相同ISA

&lt;ul&gt;
&lt;li&gt;多进程&lt;/li&gt;
&lt;li&gt;动态二进制优化器&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;不同ISA

&lt;ul&gt;
&lt;li&gt;动态翻译器&lt;/li&gt;
&lt;li&gt;高级语言虚拟机&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;系统VM

&lt;ul&gt;
&lt;li&gt;相同ISA

&lt;ul&gt;
&lt;li&gt;标准系统虚拟机&lt;/li&gt;
&lt;li&gt;主机虚拟机&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;不同ISA

&lt;ul&gt;
&lt;li&gt;全系统虚拟机&lt;/li&gt;
&lt;li&gt;协同设计虚拟机&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;仿真：解释和二进制翻译&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;基本的解释器

&lt;ul&gt;
&lt;li&gt;译码分派解释器&lt;/li&gt;
&lt;li&gt;switch-case:instruction&lt;/li&gt;
&lt;li&gt;loop:codes&lt;/li&gt;
&lt;li&gt;上下文环境:Context&lt;/li&gt;
&lt;li&gt;问题

&lt;ul&gt;
&lt;li&gt;存在大量直接或间接的跳转&lt;/li&gt;
&lt;li&gt;对cache不友好&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;线索解释

&lt;ul&gt;
&lt;li&gt;利用分派表来查找下一条指令解释例程&lt;/li&gt;
&lt;li&gt;分派表

&lt;ul&gt;
&lt;li&gt;间接线索解释&lt;/li&gt;
&lt;li&gt;dispatch-table&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;预先处理

&lt;ul&gt;
&lt;li&gt;预先译码&lt;/li&gt;
&lt;li&gt;直接线索解释

&lt;ul&gt;
&lt;li&gt;通过预先译码，将操作码与具体例程做函数对应&lt;/li&gt;
&lt;li&gt;直接例程地址&lt;/li&gt;
&lt;li&gt;一次偏移内存地址&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;处理复杂指令集

&lt;ul&gt;
&lt;li&gt;不可能将每个例程都线索化&lt;/li&gt;
&lt;li&gt;多个指令可能就是参数量不同，大量处理逻辑一致&lt;/li&gt;
&lt;li&gt;多次分派与共享例程处理

&lt;ul&gt;
&lt;li&gt;&lt;img src=&quot;http://pic.yupoo.com/qianjigui/CaVDjup9/medish.jpg&quot; alt=&quot;http://pic.yupoo.com/qianjigui/CaVDjup9/medish.jpg&quot; /&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src=&quot;http://pic.yupoo.com/qianjigui/CaVDjpvO/medish.jpg&quot; alt=&quot;http://pic.yupoo.com/qianjigui/CaVDjpvO/medish.jpg&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;通过软件流水的方式来组织分派循环的关键点是：与将来的源指令相关的加载操作与当前指令的解释相互重叠&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;二进制翻译

&lt;ul&gt;
&lt;li&gt;直接将源程序翻译成平台相关的二进制码&lt;/li&gt;
&lt;li&gt;状态隐射

&lt;ul&gt;
&lt;li&gt;指令操作&lt;/li&gt;
&lt;li&gt;寄存器使用&lt;/li&gt;
&lt;li&gt;存储器结构&lt;/li&gt;
&lt;li&gt;虚拟机状态维护&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;代码发现和动态翻译

&lt;ul&gt;
&lt;li&gt;存在的问题(即代码发现问题)是如何准确定位需要执行的代码序列

&lt;ul&gt;
&lt;li&gt;无法将全部源码做二进制翻译&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;如何定位间接跳转到源码位置(代码定位问题）&lt;/li&gt;
&lt;li&gt;增量式预译码和翻译

&lt;ul&gt;
&lt;li&gt;通过一个仿真管理器来处理源ISA和目标ISA对应链接问题&lt;/li&gt;
&lt;li&gt;一次只对一个动态block做二进制翻译&lt;/li&gt;
&lt;li&gt;这些block被管理&lt;/li&gt;
&lt;li&gt;通过管理器将执行流串起来&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;存在的问题

&lt;ul&gt;
&lt;li&gt;自修改代码&lt;/li&gt;
&lt;li&gt;自引用代码&lt;/li&gt;
&lt;li&gt;异常处理&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;控制转移优化

&lt;ul&gt;
&lt;li&gt;翻译链接

&lt;ul&gt;
&lt;li&gt;通过仿真管理器将动态block链接起来&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;软件间接跳转预测

&lt;ul&gt;
&lt;li&gt;内联高速缓存(inline caching)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;影子栈

&lt;ul&gt;
&lt;li&gt;在翻译时发生从翻译代码到目标二进制代码间接跳转时，需要纪录源程序的PC值（SPC），然后调用结束后通过SPC计算源程序的地址。这样存在一次查表&lt;/li&gt;
&lt;li&gt;将源程序翻译时，发生调用时候的地址纪录放入影子栈中。在目标二进制代码调用返回时，目标二进制有个结果PC值（DPC），如果状态正常，则这个DPC可以直接被使用（上次动态二进制翻译时，这个DPC可能是个陷阱值：需要再次解析，也可能已经链接完成）&lt;/li&gt;
&lt;li&gt;&lt;img src=&quot;http://pic.yupoo.com/qianjigui/CaVDjvhm/medish.jpg&quot; alt=&quot;http://pic.yupoo.com/qianjigui/CaVDjvhm/medish.jpg&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;进程虚拟机&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;img src=&quot;http://pic.yupoo.com/qianjigui/CbHVlKve/medish.jpg&quot; alt=&quot;http://pic.yupoo.com/qianjigui/CbHVlKve/medish.jpg&quot; /&gt;&lt;/li&gt;
&lt;li&gt;兼容性

&lt;ul&gt;
&lt;li&gt;概念

&lt;ul&gt;
&lt;li&gt;内在兼容性

&lt;ul&gt;
&lt;li&gt;系统透明&lt;/li&gt;
&lt;li&gt;完全满足各种需求&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;外在兼容性

&lt;ul&gt;
&lt;li&gt;满足部分兼容性&lt;/li&gt;
&lt;li&gt;依赖于具体实现和目标系统的特性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;源主机(被仿真设备)&lt;/li&gt;
&lt;li&gt;目标机(虚拟机运行的硬件平台)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;框架

&lt;ul&gt;
&lt;li&gt;状态映射&lt;/li&gt;
&lt;li&gt;方法

&lt;ul&gt;
&lt;li&gt;软件映射控制

&lt;ul&gt;
&lt;li&gt;内存

&lt;ul&gt;
&lt;li&gt;权限控制&lt;/li&gt;
&lt;li&gt;粒度&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;指令集合&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;直接映射

&lt;ul&gt;
&lt;li&gt;目标机提供支持是源主机需求的超集&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;虚拟机实现与目标机(实际主机)有依赖&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;状态映射

&lt;ul&gt;
&lt;li&gt;上下文环境

&lt;ul&gt;
&lt;li&gt;寄存器

&lt;ul&gt;
&lt;li&gt;完全映射

&lt;ul&gt;
&lt;li&gt;目标机寄存器可以涵盖虚拟机需求和源机器需求&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;部分映射

&lt;ul&gt;
&lt;li&gt;部分存在目标机寄存器&lt;/li&gt;
&lt;li&gt;部分存在于目标机内存&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;内存地址空间

&lt;ul&gt;
&lt;li&gt;软件转换表

&lt;ul&gt;
&lt;li&gt;类似于虚拟内存管理技术&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;直接映射硬件区域

&lt;ul&gt;
&lt;li&gt;直接偏移&lt;/li&gt;
&lt;li&gt;存在结构上的兼容性考虑&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;内存结构仿真

&lt;ul&gt;
&lt;li&gt;考虑的方面

&lt;ul&gt;
&lt;li&gt;内存空间的整体结构

&lt;ul&gt;
&lt;li&gt;分段&lt;/li&gt;
&lt;li&gt;整体单调线性结构&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;所支持的访问空间的权限类型

&lt;ul&gt;
&lt;li&gt;读&lt;/li&gt;
&lt;li&gt;写&lt;/li&gt;
&lt;li&gt;执行&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;保护/分配粒度

&lt;ul&gt;
&lt;li&gt;有些是4k一页&lt;/li&gt;
&lt;li&gt;有些可能是2的幂次&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;具体的问题

&lt;ul&gt;
&lt;li&gt;内存保护(权限控制映射)

&lt;ul&gt;
&lt;li&gt;借助于目标机的权限控制&lt;/li&gt;
&lt;li&gt;通过软件映射表控制

&lt;ul&gt;
&lt;li&gt;目标机支持是源主机的子集&lt;/li&gt;
&lt;li&gt;效率较低&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;页大小问题(粒度映射)

&lt;ul&gt;
&lt;li&gt;数据和代码各自页对齐&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;自引用和自修改代码

&lt;ul&gt;
&lt;li&gt;基本方法:写保护、陷阱中断、软件控制&lt;/li&gt;
&lt;li&gt;伪自修改代码(可写的数据区和代码混杂在一起的情况)

&lt;ul&gt;
&lt;li&gt;被保护代码和数据在一个页&lt;/li&gt;
&lt;li&gt;方法

&lt;ul&gt;
&lt;li&gt;动态检查

&lt;ul&gt;
&lt;li&gt;代码区开启写保护&lt;/li&gt;
&lt;li&gt;发生自修改&lt;/li&gt;
&lt;li&gt;复制源码作为比较依据&lt;/li&gt;
&lt;li&gt;插入检查逻辑&lt;/li&gt;
&lt;li&gt;永远关闭该页的写保护&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;将上述方法的检查逻辑作为独立块，进行链接&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;细粒度写保护

&lt;ul&gt;
&lt;li&gt;更细级别程度上设置标记&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;可靠的自修改代码

&lt;ul&gt;
&lt;li&gt;利用固有的习惯用语进行操作&lt;/li&gt;
&lt;li&gt;识别这些习惯用语&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;保护运行时软件的内存

&lt;ul&gt;
&lt;li&gt;保证虚拟机不修改源主机的程序&lt;/li&gt;
&lt;li&gt;进行软件检查

&lt;ul&gt;
&lt;li&gt;类似于高级语言的NULL-CHECK等

&lt;ul&gt;
&lt;li&gt;通过控制流、数据流分析优化掉部分检查&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;只在解释器阶段检查，翻译后不做处理&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;指令仿真

&lt;ul&gt;
&lt;li&gt;权衡性能付出

&lt;ul&gt;
&lt;li&gt;解释器&lt;/li&gt;
&lt;li&gt;翻译器&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;分阶段指令仿真

&lt;ul&gt;
&lt;li&gt;&lt;img src=&quot;http://pic.yupoo.com/qianjigui/CbHVjx12/medish.jpg&quot; alt=&quot;http://pic.yupoo.com/qianjigui/CbHVjx12/medish.jpg&quot; /&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src=&quot;http://pic.yupoo.com/qianjigui/CbHVkIq0/medish.jpg&quot; alt=&quot;http://pic.yupoo.com/qianjigui/CbHVkIq0/medish.jpg&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;异常处理

&lt;ul&gt;
&lt;li&gt;例外仿真

&lt;ul&gt;
&lt;li&gt;ABI可见

&lt;ul&gt;
&lt;li&gt;例如段错误&lt;/li&gt;
&lt;li&gt;例外检查

&lt;ul&gt;
&lt;li&gt;利用目标机基础设施

&lt;ul&gt;
&lt;li&gt;源主机可见

&lt;ul&gt;
&lt;li&gt;直接映射&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;源主机不可见

&lt;ul&gt;
&lt;li&gt;虚拟机封装掉&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ABI不可见

&lt;ul&gt;
&lt;li&gt;例如Java的OutOfArrayIndex&lt;/li&gt;
&lt;li&gt;添加指令做检查&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;中断处理

&lt;ul&gt;
&lt;li&gt;处于解释器

&lt;ul&gt;
&lt;li&gt;直接处理&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;处于翻译块阶段

&lt;ul&gt;
&lt;li&gt;快速反馈&lt;/li&gt;
&lt;li&gt;尽量减少到可中断点时间&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;确定精确的客户机状态

&lt;ul&gt;
&lt;li&gt;便于调试&lt;/li&gt;
&lt;li&gt;翻译时

&lt;ul&gt;
&lt;li&gt;即刻反馈&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;二进制状态时

&lt;ul&gt;
&lt;li&gt;维护反向索引链表&lt;/li&gt;
&lt;li&gt;从识别包含陷阱源指令的翻译块开始，然后将控制返回给运行时软件，运行时软件通过分析上下文给出正确的源状态和PC值&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;操作系统的仿真

&lt;ul&gt;
&lt;li&gt;系统调用映射问题&lt;/li&gt;
&lt;li&gt;相同系统

&lt;ul&gt;
&lt;li&gt;一般可以直接映射调用&lt;/li&gt;
&lt;li&gt;部分还是需要修改源程序的调用逻辑，进行修补调用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;不同系统

&lt;ul&gt;
&lt;li&gt;尽量保证逻辑上的正确性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;代码Cache管理

&lt;ul&gt;
&lt;li&gt;结构

&lt;ul&gt;
&lt;li&gt;Hash映射&lt;/li&gt;
&lt;li&gt;有限内存

&lt;ul&gt;
&lt;li&gt;时间空间局部性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;替换算法

&lt;ul&gt;
&lt;li&gt;最近最少使用

&lt;ul&gt;
&lt;li&gt;回退状态指针

&lt;ul&gt;
&lt;li&gt;在删除某个翻译块后，和其相关的翻译块(链接关系)都需要更新状态&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;难于维护，开销大&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;满时清除

&lt;ul&gt;
&lt;li&gt;重复翻译浪费&lt;/li&gt;
&lt;li&gt;丢失了部分profiling信息&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;抢先清除

&lt;ul&gt;
&lt;li&gt;外部监控，定时处理&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;细粒度FIFO

&lt;ul&gt;
&lt;li&gt;管理简单&lt;/li&gt;
&lt;li&gt;仍然需要回退指针&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;粗粒度FIFO

&lt;ul&gt;
&lt;li&gt;完全清楚是该方法的退化实现&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;系统环境

&lt;ul&gt;
&lt;li&gt;尽量透明

&lt;ul&gt;
&lt;li&gt;客户机限制最小化&lt;/li&gt;
&lt;li&gt;客户机和主机可互操作&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;主要是运行程序的加载器

&lt;ul&gt;
&lt;li&gt;源主机加载目标机DLL

&lt;ul&gt;
&lt;li&gt;尽量使加载过程由目标机统一完成&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;动态二进制优化&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;框架

&lt;ul&gt;
&lt;li&gt;基于基本块优化&lt;/li&gt;
&lt;li&gt;可以分阶段不同程度优化&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;动态程序的行为

&lt;ul&gt;
&lt;li&gt;一般程序的表现状况，统计结果&lt;/li&gt;
&lt;li&gt;动态控制流是高度可预测的&lt;/li&gt;
&lt;li&gt;容易出现双峰分支&lt;/li&gt;
&lt;li&gt;大部分分支的判定结果与上次相同&lt;/li&gt;
&lt;li&gt;向后的分支(多半是loop)通常是满足的&lt;/li&gt;
&lt;li&gt;间接跳转的可预测性

&lt;ul&gt;
&lt;li&gt;向单一目标20%&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;数据值的可预测性

&lt;ul&gt;
&lt;li&gt;大约20%与总是产生相同值的静态指令相关联&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;剖析(profiling)

&lt;ul&gt;
&lt;li&gt;意义

&lt;ul&gt;
&lt;li&gt;有选择的优化&lt;/li&gt;
&lt;li&gt;利用有限的资源做出尽量最优的优化方案&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;类型

&lt;ul&gt;
&lt;li&gt;执行频度--热点

&lt;ul&gt;
&lt;li&gt;基本块剖析&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;基于控制流

&lt;ul&gt;
&lt;li&gt;块的边剖析&lt;/li&gt;
&lt;li&gt;路径剖析

&lt;ul&gt;
&lt;li&gt;代价较大&lt;/li&gt;
&lt;li&gt;利用边剖析结果基本可以获得较好的路径结果&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;收集方法

&lt;ul&gt;
&lt;li&gt;插桩

&lt;ul&gt;
&lt;li&gt;在跳转等特殊逻辑处放入统计代码&lt;/li&gt;
&lt;li&gt;多处于解释处理阶段&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;采样

&lt;ul&gt;
&lt;li&gt;多作用于翻译后的二进制码&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;解释期间的剖析

&lt;ul&gt;
&lt;li&gt;管理结构

&lt;ul&gt;
&lt;li&gt;分支PC散列&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;剖析器衰减&lt;/li&gt;
&lt;li&gt;边剖析的问题

&lt;ul&gt;
&lt;li&gt;数据量大&lt;/li&gt;
&lt;li&gt;采用局部性原理&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;剖析翻译后的代码

&lt;ul&gt;
&lt;li&gt;插桩效率损失严重&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;开销

&lt;ul&gt;
&lt;li&gt;性能

&lt;ul&gt;
&lt;li&gt;缩小插桩点&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;空间&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;优化翻译块

&lt;ul&gt;
&lt;li&gt;提高局部性

&lt;ul&gt;
&lt;li&gt;空间

&lt;ul&gt;
&lt;li&gt;过程内联&lt;/li&gt;
&lt;li&gt;代码重排&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;时间&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;分析单元

&lt;ul&gt;
&lt;li&gt;踪迹&lt;/li&gt;
&lt;li&gt;超块

&lt;ul&gt;
&lt;li&gt;起始点

&lt;ul&gt;
&lt;li&gt;频繁程度&lt;/li&gt;
&lt;li&gt;启发门限&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;持续

&lt;ul&gt;
&lt;li&gt;结点信息＆边信息&lt;/li&gt;
&lt;li&gt;最常使用&lt;/li&gt;
&lt;li&gt;最近使用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;终止点

&lt;ul&gt;
&lt;li&gt;到达一个超级块&lt;/li&gt;
&lt;li&gt;超块达到最大容量&lt;/li&gt;
&lt;li&gt;不再有达到候选门限的候选基本块&lt;/li&gt;
&lt;li&gt;到达一个间接跳转/方法调用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;树簇

&lt;ul&gt;
&lt;li&gt;泛化的超块&lt;/li&gt;
&lt;li&gt;适合分支跳转各分支概率持平&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;优化框架

&lt;ul&gt;
&lt;li&gt;总的原则是应该使用快速、低开销的优化来收集那些“可轻松实现的目标”&lt;/li&gt;
&lt;li&gt;方法

&lt;ul&gt;
&lt;li&gt;&lt;img src=&quot;http://pic.yupoo.com/qianjigui/CcycBiL4/medish.jpg&quot; alt=&quot;http://pic.yupoo.com/qianjigui/CcycBiL4/medish.jpg&quot; /&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src=&quot;http://pic.yupoo.com/qianjigui/CcycB3n2/medish.jpg&quot; alt=&quot;http://pic.yupoo.com/qianjigui/CcycB3n2/medish.jpg&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;兼容性

&lt;ul&gt;
&lt;li&gt;陷阱&lt;/li&gt;
&lt;li&gt;内存&lt;/li&gt;
&lt;li&gt;寄存器&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;代码重排

&lt;ul&gt;
&lt;li&gt;基本指令重排

&lt;ul&gt;
&lt;li&gt;&lt;img src=&quot;http://pic.yupoo.com/qianjigui/CcycADFb/medish.jpg&quot; alt=&quot;http://pic.yupoo.com/qianjigui/CcycADFb/medish.jpg&quot; /&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src=&quot;http://pic.yupoo.com/qianjigui/CcyczZ27/medish.jpg&quot; alt=&quot;http://pic.yupoo.com/qianjigui/CcyczZ27/medish.jpg&quot; /&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src=&quot;http://pic.yupoo.com/qianjigui/Ccyczqav/medish.jpg&quot; alt=&quot;http://pic.yupoo.com/qianjigui/Ccyczqav/medish.jpg&quot; /&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src=&quot;http://pic.yupoo.com/qianjigui/Ccycz2bn/medish.jpg&quot; alt=&quot;http://pic.yupoo.com/qianjigui/Ccycz2bn/medish.jpg&quot; /&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src=&quot;http://pic.yupoo.com/qianjigui/CcycAvM7/medish.jpg&quot; alt=&quot;http://pic.yupoo.com/qianjigui/CcycAvM7/medish.jpg&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;调度算法

&lt;ul&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;翻译到单指令形式&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;形成寄存器映射&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;重排代码&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;确定检查点&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;分配寄存器&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;代码优化

&lt;ul&gt;
&lt;li&gt;基本

&lt;ul&gt;
&lt;li&gt;常量传播&lt;/li&gt;
&lt;li&gt;常量折叠&lt;/li&gt;
&lt;li&gt;代码下沉&lt;/li&gt;
&lt;li&gt;复写传播&lt;/li&gt;
&lt;li&gt;冗余分支消除&lt;/li&gt;
&lt;li&gt;强度削除&lt;/li&gt;
&lt;li&gt;无用赋值消除&lt;/li&gt;
&lt;li&gt;循环不定式外提&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;兼容性问题

&lt;ul&gt;
&lt;li&gt;陷阱安全&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;超块间优化

&lt;ul&gt;
&lt;li&gt;链接&lt;/li&gt;
&lt;li&gt;赋值移除&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;特定指令集优化&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;高级语言虚拟机&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;结构

&lt;ul&gt;
&lt;li&gt;特点

&lt;ul&gt;
&lt;li&gt;安全和保护

&lt;ul&gt;
&lt;li&gt;数据访问权限&lt;/li&gt;
&lt;li&gt;静态＆动态检查&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;健壮性

&lt;ul&gt;
&lt;li&gt;GC&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;网络&lt;/li&gt;
&lt;li&gt;性能

&lt;ul&gt;
&lt;li&gt;Interp&lt;/li&gt;
&lt;li&gt;JIT&lt;/li&gt;
&lt;li&gt;AOT&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Modules

&lt;ul&gt;
&lt;li&gt;VM

&lt;ul&gt;
&lt;li&gt;数据

&lt;ul&gt;
&lt;li&gt;类型

&lt;ul&gt;
&lt;li&gt;Primitive&lt;/li&gt;
&lt;li&gt;Reference&lt;/li&gt;
&lt;li&gt;Object&lt;/li&gt;
&lt;li&gt;Array&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;存储

&lt;ul&gt;
&lt;li&gt;Stack&lt;/li&gt;
&lt;li&gt;Heap&lt;/li&gt;
&lt;li&gt;全局内存&lt;/li&gt;
&lt;li&gt;常量池&lt;/li&gt;
&lt;li&gt;层次

&lt;ul&gt;
&lt;li&gt;&lt;img src=&quot;http://pic.yupoo.com/qianjigui/CcyuP9pa/medish.jpg&quot; alt=&quot;http://pic.yupoo.com/qianjigui/CcyuP9pa/medish.jpg&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ISA指令集

&lt;ul&gt;
&lt;li&gt;Format&lt;/li&gt;
&lt;li&gt;MOV&lt;/li&gt;
&lt;li&gt;Cast&lt;/li&gt;
&lt;li&gt;if/loop&lt;/li&gt;
&lt;li&gt;Stack-opt&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Exception&amp;amp;Error&lt;/li&gt;
&lt;li&gt;ClassFileFormat

&lt;ul&gt;
&lt;li&gt;class&lt;/li&gt;
&lt;li&gt;dex&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;JNI&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;APIs

&lt;ul&gt;
&lt;li&gt;Platforms&lt;/li&gt;
&lt;li&gt;Serializes&lt;/li&gt;
&lt;li&gt;Reflect&lt;/li&gt;
&lt;li&gt;Thread&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;实现

&lt;ul&gt;
&lt;li&gt;结构

&lt;ul&gt;
&lt;li&gt;&lt;img src=&quot;http://pic.yupoo.com/qianjigui/CcAYoNH5/medish.jpg&quot; alt=&quot;http://pic.yupoo.com/qianjigui/CcAYoNH5/medish.jpg&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;动态类加载

&lt;ul&gt;
&lt;li&gt;用于统一字节码&lt;/li&gt;
&lt;li&gt;静态安全检查&lt;/li&gt;
&lt;li&gt;验证完整性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;实现安全

&lt;ul&gt;
&lt;li&gt;沙盒

&lt;ul&gt;
&lt;li&gt;保护远程文件

&lt;ul&gt;
&lt;li&gt;远程操作系统控制&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;本地文件受运行的Java程序保护

&lt;ul&gt;
&lt;li&gt;安全按理器实现&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;JVM代码受运行的Java程序保护

&lt;ul&gt;
&lt;li&gt;静态＆动态检查&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;进程内保护

&lt;ul&gt;
&lt;li&gt;静态检查

&lt;ul&gt;
&lt;li&gt;元数据&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;动态检查

&lt;ul&gt;
&lt;li&gt;NULL-Check&lt;/li&gt;
&lt;li&gt;Array-Range-Check&lt;/li&gt;
&lt;li&gt;Type-Cast-Check&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;安全强制执行

&lt;ul&gt;
&lt;li&gt;API&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;增强的安全模型

&lt;ul&gt;
&lt;li&gt;身份&lt;/li&gt;
&lt;li&gt;签名

&lt;ul&gt;
&lt;li&gt;&lt;img src=&quot;http://pic.yupoo.com/qianjigui/CcAYtdh1/medish.jpg&quot; alt=&quot;http://pic.yupoo.com/qianjigui/CcAYtdh1/medish.jpg&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;利用调用栈做分析

&lt;ul&gt;
&lt;li&gt;&lt;img src=&quot;http://pic.yupoo.com/qianjigui/CcAYENvY/medish.jpg&quot; alt=&quot;http://pic.yupoo.com/qianjigui/CcAYENvY/medish.jpg&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;垃圾收集

&lt;ul&gt;
&lt;li&gt;&lt;img src=&quot;http://pic.yupoo.com/qianjigui/CcAYtokN/medish.jpg&quot; alt=&quot;http://pic.yupoo.com/qianjigui/CcAYtokN/medish.jpg&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;JNI

&lt;ul&gt;
&lt;li&gt;&lt;img src=&quot;http://pic.yupoo.com/qianjigui/CcAYstmG/medish.jpg&quot; alt=&quot;http://pic.yupoo.com/qianjigui/CcAYstmG/medish.jpg&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;仿真

&lt;ul&gt;
&lt;li&gt;Interp&lt;/li&gt;
&lt;li&gt;JIT

&lt;ul&gt;
&lt;li&gt;优化方法

&lt;ul&gt;
&lt;li&gt;代码重排&lt;/li&gt;
&lt;li&gt;方法内联&lt;/li&gt;
&lt;li&gt;VirtualMethodInvoke

&lt;ul&gt;
&lt;li&gt;Polymorphic Inline Caching(PIC)

&lt;ul&gt;
&lt;li&gt;&lt;img src=&quot;http://pic.yupoo.com/qianjigui/CcAYEka1/medish.jpg&quot; alt=&quot;http://pic.yupoo.com/qianjigui/CcAYEka1/medish.jpg&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;守护指令

&lt;ul&gt;
&lt;li&gt;&lt;img src=&quot;http://pic.yupoo.com/qianjigui/CcAYQjf0/medish.jpg&quot; alt=&quot;http://pic.yupoo.com/qianjigui/CcAYQjf0/medish.jpg&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;多版本和专门化

&lt;ul&gt;
&lt;li&gt;&lt;img src=&quot;http://pic.yupoo.com/qianjigui/CcAYFHc2/medish.jpg&quot; alt=&quot;http://pic.yupoo.com/qianjigui/CcAYFHc2/medish.jpg&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;栈替换

&lt;ul&gt;
&lt;li&gt;&lt;img src=&quot;http://pic.yupoo.com/qianjigui/CcAYIV5g/medish.jpg&quot; alt=&quot;http://pic.yupoo.com/qianjigui/CcAYIV5g/medish.jpg&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;堆分配对象

&lt;ul&gt;
&lt;li&gt;标量替换

&lt;ul&gt;
&lt;li&gt;逃逸分析&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;对象域排列

&lt;ul&gt;
&lt;li&gt;&lt;img src=&quot;http://pic.yupoo.com/qianjigui/CcAYDAGo/medish.jpg&quot; alt=&quot;http://pic.yupoo.com/qianjigui/CcAYDAGo/medish.jpg&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;低级别

&lt;ul&gt;
&lt;li&gt;Remove

&lt;ul&gt;
&lt;li&gt;NULL-Check&lt;/li&gt;
&lt;li&gt;Range-Check&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;循环剥离

&lt;ul&gt;
&lt;li&gt;&lt;img src=&quot;http://pic.yupoo.com/qianjigui/CcAYzvb7/medish.jpg&quot; alt=&quot;http://pic.yupoo.com/qianjigui/CcAYzvb7/medish.jpg&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Profiling&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;协同设计虚拟机&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Structure

&lt;ul&gt;
&lt;li&gt;通过结合使用专用硬件和软件协同实现VMM&lt;/li&gt;
&lt;li&gt;&lt;img src=&quot;http://pic.yupoo.com/qianjigui/CeGFosAw/medish.jpg&quot; alt=&quot;http://pic.yupoo.com/qianjigui/CeGFosAw/medish.jpg&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;寄存器和存储器

&lt;ul&gt;
&lt;li&gt;映射

&lt;ul&gt;
&lt;li&gt;&lt;img src=&quot;http://pic.yupoo.com/qianjigui/CeGFkd7j/medish.jpg&quot; alt=&quot;http://pic.yupoo.com/qianjigui/CeGFkd7j/medish.jpg&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;VMM部分隐藏

&lt;ul&gt;
&lt;li&gt;&lt;img src=&quot;http://pic.yupoo.com/qianjigui/CeGFh4If/medish.jpg&quot; alt=&quot;http://pic.yupoo.com/qianjigui/CeGFh4If/medish.jpg&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;自修改和自引用代码

&lt;ul&gt;
&lt;li&gt;TLB&lt;/li&gt;
&lt;li&gt;&lt;img src=&quot;http://pic.yupoo.com/qianjigui/CeGFmgFA/medish.jpg&quot; alt=&quot;http://pic.yupoo.com/qianjigui/CeGFmgFA/medish.jpg&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;代码cache支持

&lt;ul&gt;
&lt;li&gt;跳转TLB(JTLB)

&lt;ul&gt;
&lt;li&gt;&lt;img src=&quot;http://pic.yupoo.com/qianjigui/CeGFefHN/medish.jpg&quot; alt=&quot;http://pic.yupoo.com/qianjigui/CeGFefHN/medish.jpg&quot; /&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src=&quot;http://pic.yupoo.com/qianjigui/CeGF8NrK/medish.jpg&quot; alt=&quot;http://pic.yupoo.com/qianjigui/CeGF8NrK/medish.jpg&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;双地址的返回地址栈

&lt;ul&gt;
&lt;li&gt;&lt;img src=&quot;http://pic.yupoo.com/qianjigui/CeGFnBbX/medish.jpg&quot; alt=&quot;http://pic.yupoo.com/qianjigui/CeGFnBbX/medish.jpg&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;实现精确陷阱

&lt;ul&gt;
&lt;li&gt;检查点硬件支持

&lt;ul&gt;
&lt;li&gt;&lt;img src=&quot;http://pic.yupoo.com/qianjigui/CeGFbe1C/medish.jpg&quot; alt=&quot;http://pic.yupoo.com/qianjigui/CeGFbe1C/medish.jpg&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;页错误兼容

&lt;ul&gt;
&lt;li&gt;积极页错误检测

&lt;ul&gt;
&lt;li&gt;LoopCheckAndReflesh&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;懒惰页错误检测

&lt;ul&gt;
&lt;li&gt;CodeCacheUsedReflesh&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;img src=&quot;http://pic.yupoo.com/qianjigui/CeGFd4qE/medish.jpg&quot; alt=&quot;http://pic.yupoo.com/qianjigui/CeGFd4qE/medish.jpg&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;IO

&lt;ul&gt;
&lt;li&gt;&lt;img src=&quot;http://pic.yupoo.com/qianjigui/CeGFiabB/medish.jpg&quot; alt=&quot;http://pic.yupoo.com/qianjigui/CeGFiabB/medish.jpg&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;系统虚拟机&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;应用

&lt;ul&gt;
&lt;li&gt;实现多道程序设计&lt;/li&gt;
&lt;li&gt;多个安全环境&lt;/li&gt;
&lt;li&gt;管理应用环境&lt;/li&gt;
&lt;li&gt;混合操作系统环境&lt;/li&gt;
&lt;li&gt;遗留的应用程序&lt;/li&gt;
&lt;li&gt;跨平台应用开发&lt;/li&gt;
&lt;li&gt;新系统过渡&lt;/li&gt;
&lt;li&gt;系统软件开发&lt;/li&gt;
&lt;li&gt;操作系统培训&lt;/li&gt;
&lt;li&gt;客户帮助支持&lt;/li&gt;
&lt;li&gt;操作系统分析&lt;/li&gt;
&lt;li&gt;事件监控&lt;/li&gt;
&lt;li&gt;系统封装&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;关键概念

&lt;ul&gt;
&lt;li&gt;外观

&lt;ul&gt;
&lt;li&gt;&lt;img src=&quot;http://pic.yupoo.com/qianjigui/CeGWMr2z/medish.jpg&quot; alt=&quot;http://pic.yupoo.com/qianjigui/CeGWMr2z/medish.jpg&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;状态管理

&lt;ul&gt;
&lt;li&gt;&lt;img src=&quot;http://pic.yupoo.com/qianjigui/CeGWKs3X/medish.jpg&quot; alt=&quot;http://pic.yupoo.com/qianjigui/CeGWKs3X/medish.jpg&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;资源控制

&lt;ul&gt;
&lt;li&gt;&lt;img src=&quot;http://pic.yupoo.com/qianjigui/CeGWG36A/medish.jpg&quot; alt=&quot;http://pic.yupoo.com/qianjigui/CeGWG36A/medish.jpg&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;本地虚拟机和宿主虚拟机

&lt;ul&gt;
&lt;li&gt;&lt;img src=&quot;http://pic.yupoo.com/qianjigui/CeGWO13S/medish.jpg&quot; alt=&quot;http://pic.yupoo.com/qianjigui/CeGWO13S/medish.jpg&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;资源虚拟化

&lt;ul&gt;
&lt;li&gt;CPU&lt;/li&gt;
&lt;li&gt;Mem&lt;/li&gt;
&lt;li&gt;IO&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;性能提升

&lt;ul&gt;
&lt;li&gt;下降原因

&lt;ul&gt;
&lt;li&gt;建立&lt;/li&gt;
&lt;li&gt;仿真&lt;/li&gt;
&lt;li&gt;中断处理&lt;/li&gt;
&lt;li&gt;状态保存&lt;/li&gt;
&lt;li&gt;记录&lt;/li&gt;
&lt;li&gt;时间延长&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;VMM辅助手段

&lt;ul&gt;
&lt;li&gt;ContextSwitchByHardware&lt;/li&gt;
&lt;li&gt;特权指令译码ByHardware&lt;/li&gt;
&lt;li&gt;虚拟间隔计时器&lt;/li&gt;
&lt;li&gt;扩展指令集&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;客户系统的性能提升

&lt;ul&gt;
&lt;li&gt;不分页模式&lt;/li&gt;
&lt;li&gt;伪缺页处理&lt;/li&gt;
&lt;li&gt;假脱机文件&lt;/li&gt;
&lt;li&gt;VMM间通信&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;专用系统

&lt;ul&gt;
&lt;li&gt;虚实相等虚拟机&lt;/li&gt;
&lt;li&gt;旁路影像页表辅助&lt;/li&gt;
&lt;li&gt;优先机辅助&lt;/li&gt;
&lt;li&gt;段共享&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;多处理器虚拟化&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;目的

&lt;ul&gt;
&lt;li&gt;工作负载合并&lt;/li&gt;
&lt;li&gt;SMP&lt;/li&gt;
&lt;li&gt;系统移植&lt;/li&gt;
&lt;li&gt;减少系统停机时间&lt;/li&gt;
&lt;li&gt;异构系统&lt;/li&gt;
&lt;li&gt;提高系统利用率&lt;/li&gt;
&lt;li&gt;多时区需求&lt;/li&gt;
&lt;li&gt;故障隔离&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;划分

&lt;ul&gt;
&lt;li&gt;物理

&lt;ul&gt;
&lt;li&gt;好处

&lt;ul&gt;
&lt;li&gt;故障隔离&lt;/li&gt;
&lt;li&gt;安全隔离&lt;/li&gt;
&lt;li&gt;满足系统级需求&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;逻辑

&lt;ul&gt;
&lt;li&gt;分配

&lt;ul&gt;
&lt;li&gt;CPU&lt;/li&gt;
&lt;li&gt;Storage&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;实际机器&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Hardware

&lt;ul&gt;
&lt;li&gt;&lt;img src=&quot;http://pic.yupoo.com/qianjigui/CeJsprNf/medish.jpg&quot; alt=&quot;http://pic.yupoo.com/qianjigui/CeJsprNf/medish.jpg&quot; /&gt;&lt;/li&gt;
&lt;li&gt;CPU

&lt;ul&gt;
&lt;li&gt;&lt;img src=&quot;http://pic.yupoo.com/qianjigui/CeJsrljX/medish.jpg&quot; alt=&quot;http://pic.yupoo.com/qianjigui/CeJsrljX/medish.jpg&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Storage

&lt;ul&gt;
&lt;li&gt;&lt;img src=&quot;http://pic.yupoo.com/qianjigui/CeJsxZtb/medish.jpg&quot; alt=&quot;http://pic.yupoo.com/qianjigui/CeJsxZtb/medish.jpg&quot; /&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src=&quot;http://pic.yupoo.com/qianjigui/CeJsvSNl/medish.jpg&quot; alt=&quot;http://pic.yupoo.com/qianjigui/CeJsvSNl/medish.jpg&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;IO

&lt;ul&gt;
&lt;li&gt;&lt;img src=&quot;http://pic.yupoo.com/qianjigui/CeJstqED/medish.jpg&quot; alt=&quot;http://pic.yupoo.com/qianjigui/CeJstqED/medish.jpg&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ISA

&lt;ul&gt;
&lt;li&gt;用户

&lt;ul&gt;
&lt;li&gt;运算

&lt;ul&gt;
&lt;li&gt;Register

&lt;ul&gt;
&lt;li&gt;通用&lt;/li&gt;
&lt;li&gt;特殊&lt;/li&gt;
&lt;li&gt;专用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Storage&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;系统

&lt;ul&gt;
&lt;li&gt;资源管理

&lt;ul&gt;
&lt;li&gt;特权级别

&lt;ul&gt;
&lt;li&gt;System&lt;/li&gt;
&lt;li&gt;User&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;SystemRegister

&lt;ul&gt;
&lt;li&gt;SystemTimer&lt;/li&gt;
&lt;li&gt;Interupt&amp;amp;Halt&lt;/li&gt;
&lt;li&gt;MarkInterupt&lt;/li&gt;
&lt;li&gt;AddressTransferPointer&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;CPU

&lt;ul&gt;
&lt;li&gt;系统调用&lt;/li&gt;
&lt;li&gt;返回指令&lt;/li&gt;
&lt;li&gt;可产生中断的时间间隔计时器&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Storage

&lt;ul&gt;
&lt;li&gt;Structure

&lt;ul&gt;
&lt;li&gt;Fragment大小任意&lt;/li&gt;
&lt;li&gt;Page大小固定&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;PageTable

&lt;ul&gt;
&lt;li&gt;TLB&lt;/li&gt;
&lt;li&gt;prot&lt;/li&gt;
&lt;li&gt;&lt;img src=&quot;http://pic.yupoo.com/qianjigui/CeJsxG80/medish.jpg&quot; alt=&quot;http://pic.yupoo.com/qianjigui/CeJsxG80/medish.jpg&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;IO

&lt;ul&gt;
&lt;li&gt;IOStorageMapping&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Interupt&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;OS

&lt;ul&gt;
&lt;li&gt;Structure

&lt;ul&gt;
&lt;li&gt;&lt;img src=&quot;http://pic.yupoo.com/qianjigui/CeJsvf75/medish.jpg&quot; alt=&quot;http://pic.yupoo.com/qianjigui/CeJsvf75/medish.jpg&quot; /&gt;&lt;/li&gt;
&lt;li&gt;CPUManagement&lt;/li&gt;
&lt;li&gt;StorageManagement&lt;/li&gt;
&lt;li&gt;IOManagement

&lt;ul&gt;
&lt;li&gt;&lt;img src=&quot;http://pic.yupoo.com/qianjigui/CeJsuM6X/medish.jpg&quot; alt=&quot;http://pic.yupoo.com/qianjigui/CeJsuM6X/medish.jpg&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Interface

&lt;ul&gt;
&lt;li&gt;Process

&lt;ul&gt;
&lt;li&gt;fork&lt;/li&gt;
&lt;li&gt;exec&lt;/li&gt;
&lt;li&gt;exit&lt;/li&gt;
&lt;li&gt;wait&lt;/li&gt;
&lt;li&gt;sleep&lt;/li&gt;
&lt;li&gt;wakeup&lt;/li&gt;
&lt;li&gt;setpriority&lt;/li&gt;
&lt;li&gt;getrusage&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Storage

&lt;ul&gt;
&lt;li&gt;sbrk&lt;/li&gt;
&lt;li&gt;malloc&lt;/li&gt;
&lt;li&gt;free&lt;/li&gt;
&lt;li&gt;mprotect&lt;/li&gt;
&lt;li&gt;shmget&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;IO

&lt;ul&gt;
&lt;li&gt;&lt;img src=&quot;http://pic.yupoo.com/qianjigui/CeJssy1x/medish.jpg&quot; alt=&quot;http://pic.yupoo.com/qianjigui/CeJssy1x/medish.jpg&quot; /&gt;&lt;/li&gt;
&lt;li&gt;read&lt;/li&gt;
&lt;li&gt;open&lt;/li&gt;
&lt;li&gt;close&lt;/li&gt;
&lt;li&gt;write&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Signal

&lt;ul&gt;
&lt;li&gt;sigvec&lt;/li&gt;
&lt;li&gt;kill&lt;/li&gt;
&lt;li&gt;sigblock&lt;/li&gt;
&lt;li&gt;sigsetmask&lt;/li&gt;
&lt;li&gt;sigreturn&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Init&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;MultiCPUs

&lt;ul&gt;
&lt;li&gt;集群计算&lt;/li&gt;
&lt;li&gt;共享存储多处理器&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;tags: VM JVM&lt;/h2&gt;
</content>
 </entry>
 
 <entry>
   <title>Java 标注</title>
   <link href="http://www.5wpc.info/it/technical/language/java/2012/08/06/Annotation"/>
   <updated>2012-08-06T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/technical/language/java/2012/08/06/Annotation</id>
   <content type="html">&lt;h1&gt;目前的主要项目&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/it/technical/language/java/2014/08/19/JavaCompileTransform/&quot;&gt;利用标注做代码生成&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Java Annotations&lt;/h1&gt;

&lt;h2&gt;Class Annotations&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface MyAnnotation {
    public String name();
    public String value();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;@MyAnnotation(name=&quot;someName&quot;,  value = &quot;Hello World&quot;)
public class TheClass {
}

Class aClass = TheClass.class;
Annotation[] annotations = aClass.getAnnotations();

for(Annotation annotation : annotations){
    if(annotation instanceof MyAnnotation){
        MyAnnotation myAnnotation = (MyAnnotation) annotation;
        System.out.println(&quot;name: &quot; + myAnnotation.name());
        System.out.println(&quot;value: &quot; + myAnnotation.value());
    }
}

Class aClass = TheClass.class;
Annotation annotation = aClass.getAnnotation(MyAnnotation.class);

if(annotation instanceof MyAnnotation){
    MyAnnotation myAnnotation = (MyAnnotation) annotation;
    System.out.println(&quot;name: &quot; + myAnnotation.name());
    System.out.println(&quot;value: &quot; + myAnnotation.value());
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Method Annotations&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public class TheClass {
  @MyAnnotation(name=&quot;someName&quot;,  value = &quot;Hello World&quot;)
  public void doSomething(){}
}

Method method = ... //obtain method object
Annotation[] annotations = method.getDeclaredAnnotations();

for(Annotation annotation : annotations){
    if(annotation instanceof MyAnnotation){
        MyAnnotation myAnnotation = (MyAnnotation) annotation;
        System.out.println(&quot;name: &quot; + myAnnotation.name());
        System.out.println(&quot;value: &quot; + myAnnotation.value());
    }
}

Method method = ... // obtain method object
Annotation annotation = method.getAnnotation(MyAnnotation.class);

if(annotation instanceof MyAnnotation){
    MyAnnotation myAnnotation = (MyAnnotation) annotation;
    System.out.println(&quot;name: &quot; + myAnnotation.name());
    System.out.println(&quot;value: &quot; + myAnnotation.value());
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Paramenter Annotations&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public class TheClass {
  public static void doSomethingElse(
        @MyAnnotation(name=&quot;aName&quot;, value=&quot;aValue&quot;) String parameter){
  }
}
Method method = ... //obtain method object
Annotation[][] parameterAnnotations = method.getParameterAnnotations();
Class[] parameterTypes = method.getParameterTypes();

int i=0;
for(Annotation[] annotations : parameterAnnotations){
  Class parameterType = parameterTypes[i++];

  for(Annotation annotation : annotations){
    if(annotation instanceof MyAnnotation){
        MyAnnotation myAnnotation = (MyAnnotation) annotation;
        System.out.println(&quot;param: &quot; + parameterType.getName());
        System.out.println(&quot;name : &quot; + myAnnotation.name());
        System.out.println(&quot;value: &quot; + myAnnotation.value());
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Field Annotations&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public class TheClass {

  @MyAnnotation(name=&quot;someName&quot;,  value = &quot;Hello World&quot;)
  public String myField = null;
}

Field field = ... //obtain field object
Annotation[] annotations = field.getDeclaredAnnotations();

for(Annotation annotation : annotations){
    if(annotation instanceof MyAnnotation){
        MyAnnotation myAnnotation = (MyAnnotation) annotation;
        System.out.println(&quot;name: &quot; + myAnnotation.name());
        System.out.println(&quot;value: &quot; + myAnnotation.value());
    }
}

Field field = ... // obtain method object
Annotation annotation = field.getAnnotation(MyAnnotation.class);

if(annotation instanceof MyAnnotation){
    MyAnnotation myAnnotation = (MyAnnotation) annotation;
    System.out.println(&quot;name: &quot; + myAnnotation.name());
    System.out.println(&quot;value: &quot; + myAnnotation.value());
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;User defined Annotation&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;//Twizzle.java
package demo;

/*
 * Annotation提供了一条与程序元素关联任何信息或者任何元数据（metadata）的途径。
 * 从某些方面看，annotation就像修饰符一样被使用，并应用于包、类型、构造方法、方法、成员变量、参数、本地变量的声明中。
 * 这些信息被存储在annotation的“name=value”结构对中。annotation类型是一种接口，能够通过java反射API的方式提供对其信息的访问。
 * 
 * 
 * 
 */

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/*
 * annotation的target是一个被标注的程序元素。
 * target说明了annotation所修饰的对象范围：
 *   annotation可被用于packages、types（类、接口、枚举、annotation类型）、
 *   类型成员（方法、构造方法、成员变量、枚举值）、
 *   方法参数和本地变量（如循环变量、catch参数）。
 * 在annotation类型的声明中使用了target可更加明晰其修饰的目标。
 * 如果不添加则默认为都可以修饰
 */
@Target(ElementType.TYPE)
/*
 * annotation的retention定义了该annotation被保留的时间长短：
 *   某些annotation仅出现在源代码中，而被编译器丢弃；
 *   而另一些却被编译在class文件中；
 *   编译在class文件中的annotation可能会被虚拟机忽略，
 *   而另一些在class被装载时将被读取（请注意并不影响class的执行，因为annotation与class在使用上是被分离的）。
 * 使用这个meta-annotation可以对annotation的“生命周期”限制。
 */
@Retention(RetentionPolicy.RUNTIME)
    public @interface Twizzle {
        @Edible
            int mem() default 1;

        /*
         * annotation的成员在annotation类型中以无参数的方法的形式被声明。其方法名和返回值定义了该成员的名字和类型
         * 在此有一个特定的默认语法
         * ：允许声明任何annotation成员的默认值：一个annotation可以将name=value对作为没有定义默认值的annotation成员的值
         * ， 当然也可以使用name=value对来覆盖其它成员默认值。
         * 这一点有些近似类的继承特性，父类的构造函数可以作为子类的默认构造函数，但是也可以被子类覆盖 。
         */
        String name() default &quot;Jack&quot;;
    }

@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
@interface Edible {
    boolean value() default false;

    String name() default &quot;John&quot;;
}

//A.java
package demo;

import java.lang.annotation.Annotation;
import java.lang.reflect.AnnotatedElement;
import java.lang.reflect.Method;

//针对类的标注
@Twizzle
public class A {

    //marker annotation
    @Deprecated
        public void run()
        {

        }

    public void test()
    {
        AnnotatedElement target = B.class;
        Twizzle t = target.getAnnotation(Twizzle.class);
        //访问字段
        System.out.println(t);
        for(Annotation a : Twizzle.class.getAnnotations()){
            System.out.println(a);
        }
        System.out.println(&quot;----------------&quot;);
        target = Twizzle.class;
        for(Annotation a:target.getDeclaredAnnotations()){
            System.out.println(a);
        }
    }

    public static void main(String[] args)
    {
        (new A()).test();
    }
}

//自定义默认值的标注
@Twizzle(
        name=&quot;Lucy&quot;,
        mem = 2
        )
class B{

}
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>信息的表示和处理</title>
   <link href="http://www.5wpc.info/it/technical/language/2012/07/24/DataRepresentation"/>
   <updated>2012-07-24T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/technical/language/2012/07/24/DataRepresentation</id>
   <content type="html">&lt;h1&gt;信息的表示和存储&lt;/h1&gt;

&lt;h2&gt;数据存储&lt;/h2&gt;

&lt;h3&gt;数据长短&lt;/h3&gt;

&lt;h3&gt;寻址和直接顺序&lt;/h3&gt;

&lt;p&gt;表示数据0x12345678,数据中0x12为数据最高位:
* 大端:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;  地址 &lt;/th&gt;
&lt;th&gt;  0x100&lt;/th&gt;
&lt;th&gt;  0x101&lt;/th&gt;
&lt;th&gt;  0x102&lt;/th&gt;
&lt;th&gt;  0x103 &lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;  数据 &lt;/td&gt;
&lt;td&gt;   12  &lt;/td&gt;
&lt;td&gt;   34  &lt;/td&gt;
&lt;td&gt;   56  &lt;/td&gt;
&lt;td&gt;   78   &lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;


&lt;ul&gt;
&lt;li&gt;小端:&lt;/li&gt;
&lt;/ul&gt;


&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;  地址 &lt;/th&gt;
&lt;th&gt;  0x100&lt;/th&gt;
&lt;th&gt;  0x101&lt;/th&gt;
&lt;th&gt;  0x102&lt;/th&gt;
&lt;th&gt;  0x103 &lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;  数据 &lt;/td&gt;
&lt;td&gt;   78  &lt;/td&gt;
&lt;td&gt;   56  &lt;/td&gt;
&lt;td&gt;   34  &lt;/td&gt;
&lt;td&gt;   12   &lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;


&lt;h3&gt;C中的移位运算&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;左移(0xff&amp;lt;&amp;lt;8=0xff0)&lt;/li&gt;
&lt;li&gt;右移(0xff000000&gt;&gt;8):

&lt;ul&gt;
&lt;li&gt;无符号数据(unsigned int/long): 逻辑右移(=0x 0f f0 00 00)&lt;/li&gt;
&lt;li&gt;符号数据(int/long): 算术(左端补最高有效位的拷贝)右移(=0x ff f0 00 00)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;整数表示&lt;/h3&gt;

&lt;p&gt;在C语言中,主要有有符号数字和无符号数字标示。
现做如下规约:
* B:binary(位表示)
* U:unsigned(无符号表示)
* T:有符号表示
* 负数为二进制补码表示&lt;/p&gt;

&lt;p&gt;数据组织:
| 位        |  w-1 |  w-2 |  ...... |  3 |  2 |  1 |  0 |
|------|------|------|------|------|------|------|------|
| 数据(=0/1)|  x,,w-1,, |  x,,w-2,, |  ...... |  x,,3,, |  x,,2,, |  x,,1,, |  x,,0,, |&lt;/p&gt;

&lt;p&gt;结果:
* B2U,,w,,(&lt;em&gt;x&lt;/em&gt;) = sum(i:0..(w-1)){x,,i,,2&lt;sup&gt;i&lt;/sup&gt;^}
* B2T,,w,,(&lt;em&gt;x&lt;/em&gt;) = -x,,w-1,,2&lt;sup&gt;w&lt;/sup&gt;-1^ + sum(i:0..(w-2)){x,,i,,2&lt;sup&gt;i&lt;/sup&gt;^}
* T2U,,w,,(&lt;em&gt;x&lt;/em&gt;) , 原则是基本的位表示保持不变 = B2U,,w,,(T2B,,w,,(&lt;em&gt;x&lt;/em&gt;)) = x,,w-1,,2&lt;sup&gt;w&lt;/sup&gt;^ + &lt;em&gt;x&lt;/em&gt; = &lt;em&gt;x&lt;/em&gt; + 2&lt;sup&gt;w&lt;/sup&gt;^ (x &amp;lt; 0), x (x&gt;=0)
* 对于含有符号和无符号的一个比较运算时，C会隐含地将有符号强制转换为无符号数。这种方法对于标准的算术运算来说并没有差异，但是对于像&amp;lt;&gt;的关系运算存在问题:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;  0==0U &lt;/th&gt;
&lt;th&gt;    1   &lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;  -1 is smaller than 0  &lt;/td&gt;
&lt;td&gt;    1   &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;  -1 is smaller than 0U &lt;/td&gt;
&lt;td&gt;    &lt;em&gt;0&lt;/em&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;


&lt;ul&gt;
&lt;li&gt;扩展一个数字的位:

&lt;ul&gt;
&lt;li&gt;无符号数字转换为一个更大的数据类型，在头部补0--&lt;em&gt;零扩展&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;将一个二进制补码数字转换成更大的数据类型，采用&lt;em&gt;符号扩展&lt;/em&gt;--头部添加最高有效位的值&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;截断数字:

&lt;ul&gt;
&lt;li&gt;[x,,w-1,, , x,,w-2,, , ... , x,,2,, , x,,1,, , x,,0,,] ＝截断只剩K位=&gt; [x,,k-1,, , x,,k-2,, , ... , x,,2,, , x,,1,, , x,,0,,]&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;浮点数据表示&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/FlyingBread/archive/2009/02/15/660206.html&quot;&gt;浮点数表示和基本运算&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;基于数据位的操作&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://graphics.stanford.edu/~seander/bithacks.html&quot;&gt;Bit Twiddling Hacks&lt;/a&gt; :
    * 基于最高位的符号数判断&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;int v;
int sign;
sign = v &amp;gt;&amp;gt; (sizeof(int)*CHAR_BIT-1);//v&amp;gt;&amp;gt;31
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;* 判断符号位是否相同
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;int x,y;
bool f = ((x^y)&amp;lt;0);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;不需要跳转&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;语句处理绝对值&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code class=&quot;c &quot;&gt;int v;
unsigned int r;
int const mask = v &amp;gt;&amp;gt; sizeof(int)*CHAR_BIT - 1;
r = (v+mask) ^ mask;
r = (v^mask) - mask;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;计算两个数的较大者/较小者&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code class=&quot;c &quot;&gt;int x;
int y;
int r;
r = y^((x^y)&amp;amp;-(x&amp;lt;y));//min(x,y)
r = x^((x^y)&amp;amp;-(x&amp;lt;y));//max(x,y)

r = y + ((x - y) &amp;amp; ((x - y) &amp;gt;&amp;gt; (sizeof(int) * CHAR_BIT - 1))); // min(x, y)
r = x - ((x - y) &amp;amp; ((x - y) &amp;gt;&amp;gt; (sizeof(int) * CHAR_BIT - 1))); // max(x, y)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;判断一个数是否为2的幂&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code class=&quot;c &quot;&gt;unsigned int v;
bool f;
f = (v&amp;amp;(v-1))==0;//v==0时有问题，0不是2的幂次
f = v &amp;amp;&amp;amp; !(v &amp;amp; (v - 1));
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;位标识处理&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code class=&quot;c &quot;&gt;bool f;         // conditional flag
unsigned int m; // the bit mask
unsigned int w; // the word to modify:  if (f) w |= m; else w &amp;amp;= ~m;

w ^= (-f ^ w) &amp;amp; m;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;统计1-bit的个数&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code class=&quot;c &quot;&gt;unsigned int v; // count the number of bits set in v
unsigned int c; // c accumulates the total bits set in v
for (c = 0; v; c++)
{
  v &amp;amp;= v - 1; // clear the least significant bit set
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;数据交换&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code class=&quot;c &quot;&gt;#define SWAP(a, b) (((a) ^= (b)), ((b) ^= (a)), ((a) ^= (b)))
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>散列表</title>
   <link href="http://www.5wpc.info/it/technical/algorithm/2012/07/15/HashTable"/>
   <updated>2012-07-15T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/technical/algorithm/2012/07/15/HashTable</id>
   <content type="html">&lt;h1&gt;散列表&lt;/h1&gt;

&lt;h2&gt;数据组织方法&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.chinaunix.net/uid-26822401-id-3169705.html&quot;&gt;算法导论散列表笔记&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* 直接寻址法:避免碰撞的方法:链接法
* 全域散列
    * 开放寻址法(将数据存放在线性结构上,譬如数组.在合适的时侯进行扩容):
        * 一次探测(线性探测): h(k, i) = (h&#39;(k) + i) mod m, i = 0, 1, ..., m-1
        * 二次探测: h(k, i) = (h&#39;(k) + c1*i + c2*i^2) mod m
        * 双重探测: h(k, i) = (h1(k) + i*h2(k)) mod m
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Hash函数&lt;/h2&gt;

&lt;h3&gt;字符串&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://www.byvoid.com/blog/string-hash-compare/&quot;&gt;各种字符串hash函数比较&lt;/a&gt;&lt;/p&gt;

&lt;h4&gt;BKDRH&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;//BKDR Hash Function
unsigned int BKDRHash(char *str)
{
    unsigned int seed = 131; // 31 131 1313 13131 131313 etc..
    unsigned int hash = 0;

    while (*str){
        hash = hash * seed + (*str++);
    }

    return (hash &amp;amp; 0x7FFFFFFF);
}
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>时间管理</title>
   <link href="http://www.5wpc.info/it/living/selfmanagement/2012/07/09/TimeManagement"/>
   <updated>2012-07-09T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/living/selfmanagement/2012/07/09/TimeManagement</id>
   <content type="html">&lt;h1&gt;第五代时间管理&lt;/h1&gt;

&lt;h2&gt;目录&lt;/h2&gt;

&lt;p&gt;新千年的时间管理——范例的变化 --我们拥有的时间比我们想象的要多得多 --五代时间管理&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;M如同观海

&lt;ol&gt;
&lt;li&gt;第1天：关于时间的7个谎言&lt;/li&gt;
&lt;li&gt;第2天：宁静——宇宙间最强大的力量&lt;/li&gt;
&lt;li&gt;第3天：你是在受驱使还是在为自己而活&lt;/li&gt;
&lt;li&gt;第4天：播种与收获&lt;/li&gt;
&lt;li&gt;第5天：你是哪种时间类型的人&lt;/li&gt;
&lt;li&gt;第6天：心流——新的时间感&lt;/li&gt;
&lt;li&gt;第7天：时间——衡量万物的尺度&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;E如同效率

&lt;ol&gt;
&lt;li&gt;第8天：以目标为基础进行时间管理&lt;/li&gt;
&lt;li&gt;第9天：为什么仅仅有效率是不够的&lt;/li&gt;
&lt;li&gt;第10天：我的时间计划里哪件事最优先&lt;/li&gt;
&lt;li&gt;第11天：平衡地生活——合理分配时间&lt;/li&gt;
&lt;li&gt;第12天：养成良好的习惯——赢得时间&lt;/li&gt;
&lt;li&gt;第13天：摆脱信息泛滥的困扰 101&lt;/li&gt;
&lt;li&gt;第14天：时间管理系统工具——纸还是电子工具&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;E如同阶段

&lt;ol&gt;
&lt;li&gt;第15天：第1条地平线——日&lt;/li&gt;
&lt;li&gt;第16天：第2条地平线——周&lt;/li&gt;
&lt;li&gt;第17天：第3条地平线——季&lt;/li&gt;
&lt;li&gt;第18天：第4条地平线——年&lt;/li&gt;
&lt;li&gt;第19天：第5条地平线——7年&lt;/li&gt;
&lt;li&gt;第20天：第6条地平线——退休&lt;/li&gt;
&lt;li&gt;第21天：第7条地平线——生命的终结&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;R如同财富

&lt;ol&gt;
&lt;li&gt;第22天：优化时间——通过环境&lt;/li&gt;
&lt;li&gt;第23天：优化时间——通过信任&lt;/li&gt;
&lt;li&gt;第24天：优化时间——通过性格&lt;/li&gt;
&lt;li&gt;第25天：优化时间——通过人际交往&lt;/li&gt;
&lt;li&gt;第26天：优化时间——通过奉献&lt;/li&gt;
&lt;li&gt;第27天：优化时间——通过意义&lt;/li&gt;
&lt;li&gt;第28天：优化时间——通过勇气迈出第二步&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;后记&lt;/li&gt;
&lt;li&gt;致谢&lt;/li&gt;
&lt;/ol&gt;


&lt;h3&gt;MEER&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;M观海:
 修改成见，重新审视时间观念&lt;/li&gt;
&lt;li&gt;E效率:
 学习时间管理的基本技巧：确立明确的目标，设定优先次序，养成好习惯，兼顾生活各个方面的平衡，等等。&lt;/li&gt;
&lt;li&gt;E阶段:
 制定规划进行实施&lt;/li&gt;
&lt;li&gt;R财富:
 和周围人交流，获取更大的时间财富&lt;/li&gt;
&lt;/ol&gt;


&lt;h3&gt;五代时间管理的特点&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;效能：效率+正确的方向&lt;/li&gt;
&lt;li&gt;潜能导向：发挥潜力&lt;/li&gt;
&lt;li&gt;工作－生活－平衡&lt;/li&gt;
&lt;li&gt;分享－生活－平衡&lt;/li&gt;
&lt;/ol&gt;


&lt;h3&gt;关于时间的7个谎言&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;时间正在逐年减少：转变思维，去享受时间&lt;/li&gt;
&lt;li&gt;别人把事情推给我：又是一个感知问题&lt;/li&gt;
&lt;li&gt;自我定义个人，人生开始的时间：从现在开始&lt;/li&gt;
&lt;li&gt;工作狂：平衡工作和生活&lt;/li&gt;
&lt;li&gt;计划中的突发事件：通过计划来转化偏差&lt;/li&gt;
&lt;li&gt;我没有时间：其实是没有兴趣&lt;/li&gt;
&lt;li&gt;只按计划不顾意外：合理放置每个事情的位置&lt;/li&gt;
&lt;/ol&gt;


&lt;h3&gt;宁静&lt;/h3&gt;

&lt;p&gt;给自己时间去休息，去呼吸～&lt;/p&gt;

&lt;h3&gt;不要被驱使，我们要为自己而活！&lt;/h3&gt;

&lt;p&gt;很多时候，很多人不能够因为自己想做什么就去做什么。&lt;/p&gt;

&lt;p&gt;在这种情况下，我们都成了：可怜虫（期盼来生）、世界的拯救者（婆婆妈妈，说这说那，却不自己行动），控诉者（抱怨天天）、干实事者（通过行动来麻痹自己）。&lt;/p&gt;

&lt;p&gt;我们需要负责任地生活（家庭、上司、下属）。&lt;/p&gt;

&lt;h3&gt;播种和收获&lt;/h3&gt;

&lt;p&gt;首先是咱们得学会活在当下：把握现在，向过去学习，去创造未来。&lt;/p&gt;

&lt;p&gt;那么我们就得有方向的去选择播种，然后不要为周围的XXX所动（创造性的忽视），并且需要防止出现工作倦怠。&lt;/p&gt;

&lt;h3&gt;识别自己属于哪种时间类型&lt;/h3&gt;

&lt;p&gt;DISC&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;                &lt;/th&gt;
&lt;th&gt;  支配 &lt;/th&gt;
&lt;th&gt;  影响 &lt;/th&gt;
&lt;th&gt;  稳健 &lt;/th&gt;
&lt;th&gt;  服从 &lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;  对环境的反应  &lt;/td&gt;
&lt;td&gt;  退缩 &lt;/td&gt;
&lt;td&gt;  退缩 &lt;/td&gt;
&lt;td&gt;  主动 &lt;/td&gt;
&lt;td&gt;  主动 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;  对环境的感受  &lt;/td&gt;
&lt;td&gt;  紧张 &lt;/td&gt;
&lt;td&gt;  轻松 &lt;/td&gt;
&lt;td&gt;  轻松 &lt;/td&gt;
&lt;td&gt;  紧张 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;                &lt;/td&gt;
&lt;td&gt; 有压力&lt;/td&gt;
&lt;td&gt;有压力 &lt;/td&gt;
&lt;td&gt;无压力 &lt;/td&gt;
&lt;td&gt; 无压力&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;


&lt;h3&gt;使自己处在良好的时间状态中：心流&lt;/h3&gt;

&lt;p&gt;处于心流状态的方法：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;寻找挑战&lt;/li&gt;
&lt;li&gt;对目标执行情况进行反馈&lt;/li&gt;
&lt;li&gt;分散注意力（为消除内心的混乱）&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;管理时间需要&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;注意做到恰如其分&lt;/li&gt;
&lt;li&gt;找到集中注意力的勇气（有意识的从大量的可能性中确定出一个明确的目标并不受干扰地努力）&lt;/li&gt;
&lt;li&gt;认识到并划定有益的界线&lt;/li&gt;
&lt;li&gt;找到正确尺度的方法：重构，不断尝试、观察周围的人和进行批判性的自我反省。&lt;/li&gt;
&lt;li&gt;有决心有信心去做好，并且设定正确的目标。&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;以目标（可衡量-&gt;以文字性为基础、可行）为基础进行时间管理&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;不仅需要效率，更需要方向。&lt;/li&gt;
&lt;li&gt;事情的分类：

&lt;ul&gt;
&lt;li&gt;重要：使自己越来越接近个人目标的事情&lt;/li&gt;
&lt;li&gt;紧急：需要集中注意力的一切事情

&lt;ol&gt;
&lt;li&gt;重要且紧急(全力以赴)&lt;/li&gt;
&lt;li&gt;重要但不紧急（认真安排，做出投资）&lt;/li&gt;
&lt;li&gt;紧急但不重要（安排他人去做如果可以的话）&lt;/li&gt;
&lt;li&gt;不紧急也不重要（放弃）&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;事情的排序：ABC优先顺序设定法

&lt;ol&gt;
&lt;li&gt; A：必须今天完成的任务-&gt;紧急且重要&lt;/li&gt;
&lt;li&gt; B：重要但不必今天完成-&gt;规定好完成的期限&lt;/li&gt;
&lt;li&gt; C：看似紧急其实不太重要的工作-&gt;授权他人、搁着&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;采用8/2原则&lt;/h3&gt;

&lt;p&gt;20%任务--&gt;80%成果&lt;/p&gt;

&lt;h3&gt;合理分配时间：生命的意义、工作、身体、家庭&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;养成良好的习惯：

&lt;ul&gt;
&lt;li&gt;每天花10min做计划&lt;/li&gt;
&lt;li&gt;形成惯例&lt;/li&gt;
&lt;li&gt;列出检查清单&lt;/li&gt;
&lt;li&gt;采用待办事务清单和时间计划&lt;/li&gt;
&lt;li&gt;文字书面化&lt;/li&gt;
&lt;li&gt;保持体力、多运动&lt;/li&gt;
&lt;li&gt;有针对性地使用媒体&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;形成新习惯的关键

&lt;ul&gt;
&lt;li&gt;与过去决裂&lt;/li&gt;
&lt;li&gt;克服拖延&lt;/li&gt;
&lt;li&gt;拒绝例外&lt;/li&gt;
&lt;li&gt;时常审视自己的习惯（一日三省吾身）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;摆脱信息泛滥的困扰

&lt;ul&gt;
&lt;li&gt;整洁&lt;/li&gt;
&lt;li&gt;专注&lt;/li&gt;
&lt;li&gt;善于舍弃&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;有阶段的进行时间管理&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;第一个阶段：日

&lt;ul&gt;
&lt;li&gt;列出书面计划（前一天晚上做出计划和检查清单）&lt;/li&gt;
&lt;li&gt;设定优先级&lt;/li&gt;
&lt;li&gt;切合实际地安排时间段（仅为有效时间的50%）&lt;/li&gt;
&lt;li&gt;利用心流的状态，根据自己的生物节律安排&lt;/li&gt;
&lt;li&gt;设定完成期限&lt;/li&gt;
&lt;li&gt;同一类的事情最好一次做完&lt;/li&gt;
&lt;li&gt;检查清单&lt;/li&gt;
&lt;li&gt;制定日计划&lt;/li&gt;
&lt;li&gt;写下完成期限&lt;/li&gt;
&lt;li&gt;将报告中还没进行的活动记下来&lt;/li&gt;
&lt;li&gt;将待办事项清单上的任务写下来&lt;/li&gt;
&lt;li&gt;看看今天的人物能否交给其他人完成&lt;/li&gt;
&lt;li&gt;确定优先次序&lt;/li&gt;
&lt;li&gt;我今天能让谁快乐&lt;/li&gt;
&lt;li&gt;其他私事&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;第二个阶段：周

&lt;ul&gt;
&lt;li&gt;制定周计划（小石子原理）&lt;/li&gt;
&lt;li&gt;制定每周工作任务清单（插入重要的事情）&lt;/li&gt;
&lt;li&gt;调整每周罗盘指南（需要多角色转换、最好不要超过7个）&lt;/li&gt;
&lt;li&gt;学会说&quot;不&quot;&lt;/li&gt;
&lt;li&gt;做好月计划&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;一个季度：

&lt;ul&gt;
&lt;li&gt;学会畅想，&quot;做白日梦&quot;(从繁忙的工作中摆脱出来，反思，检查，寻找)&lt;/li&gt;
&lt;li&gt;发现宝贵的时光&lt;/li&gt;
&lt;li&gt;可以从价值观的角度考虑自己的目标&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;一年：

&lt;ul&gt;
&lt;li&gt;根据季节计划时间&lt;/li&gt;
&lt;li&gt;方向更大更全面（工作绩效、家庭关系、身体健康、心智与信仰）&lt;/li&gt;
&lt;li&gt;年度工作任务清单（人生目标、年度、检查、学习）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;7年&lt;/li&gt;
&lt;li&gt;退休&lt;/li&gt;
&lt;li&gt;一生&lt;/li&gt;
&lt;/ol&gt;


&lt;h3&gt;防止遗忘&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;提醒&lt;/li&gt;
&lt;li&gt;利用检查清单&lt;/li&gt;
&lt;li&gt;观察自己所处的环境&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;有效沟通的小技巧&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;基本态度&lt;/li&gt;
&lt;li&gt;注意倾听&lt;/li&gt;
&lt;li&gt;集中注意力听&lt;/li&gt;
&lt;li&gt;经常、不断地确认沟通的讯息&lt;/li&gt;
&lt;li&gt;正确的回应对方的话语&lt;/li&gt;
&lt;li&gt;不要说不良的口头禅或者是使用威胁的语句&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;感悟&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;要更快的提高，则需要自己在每天、每小时都学会去重构自己的行为、思想和目标。&lt;/li&gt;
&lt;li&gt;静以修身，俭以养德。&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>Linux内核源代码阅读基础知识</title>
   <link href="http://www.5wpc.info/it/technical/kernel/linux/2011/12/10/basic"/>
   <updated>2011-12-10T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/technical/kernel/linux/2011/12/10/basic</id>
   <content type="html">&lt;h1&gt;CPU各种模式&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt; 保护模式&lt;/li&gt;
&lt;li&gt; 实模式&lt;/li&gt;
&lt;li&gt; 有关 PC 机硬件接口控制编程&lt;/li&gt;
&lt;li&gt; 80386 32 位保护模式的编程方法&lt;/li&gt;
&lt;li&gt; Page 55&lt;/li&gt;
&lt;/ol&gt;

</content>
 </entry>
 
 <entry>
   <title>男人来自火星女人来自金星</title>
   <link href="http://www.5wpc.info/it/living/life/2011/12/10/MenWomenAndRelationships"/>
   <updated>2011-12-10T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/living/life/2011/12/10/MenWomenAndRelationships</id>
   <content type="html">&lt;h1&gt;男人来自火星女人来自金星&lt;/h1&gt;

&lt;h2&gt;爱“外星人”的艺术&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;接受差异性

&lt;ul&gt;
&lt;li&gt;人人与众不同&lt;/li&gt;
&lt;li&gt;认识存在的不同&lt;/li&gt;
&lt;li&gt;重新评估我们的设想&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;领导的艺术

&lt;ul&gt;
&lt;li&gt;接受不同点&lt;/li&gt;
&lt;li&gt;扩大相同面&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;建立美妙的两性关系&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;关键

&lt;ul&gt;
&lt;li&gt;有目的的沟通

&lt;ul&gt;
&lt;li&gt;带着理解对方、并且让自己被对方理解的目的去沟通&lt;/li&gt;
&lt;li&gt;让对方理解自己&lt;/li&gt;
&lt;li&gt;压抑愤恨会把事情弄得更糟&lt;/li&gt;
&lt;li&gt;仅有好的意图是不够的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;正确的理解

&lt;ul&gt;
&lt;li&gt;理解、欣赏、尊重我们的不同之处&lt;/li&gt;
&lt;li&gt;误解会毁灭沟通&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;放弃指责

&lt;ul&gt;
&lt;li&gt;放弃对自己以及对方的负面评判&lt;/li&gt;
&lt;li&gt;消极评价会毁灭亲密关系&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;承担责任

&lt;ul&gt;
&lt;li&gt;承担起你所期望的那种关系的责任，学会宽容&lt;/li&gt;
&lt;li&gt;不以受害者自居&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;男人和女人基本的心理差异&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;女人“扩散”，男人“收缩”

&lt;ul&gt;
&lt;li&gt;通过不擅加评断的聆听来善待和支持女人释放内在情绪的需要&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;女人絮絮叨叨，男人直指重点&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;男人和女人用不同的眼光看世界&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;男人

&lt;ul&gt;
&lt;li&gt;聚焦式

&lt;ul&gt;
&lt;li&gt;感兴趣

&lt;ul&gt;
&lt;li&gt;产生结果&lt;/li&gt;
&lt;li&gt;达到目的&lt;/li&gt;
&lt;li&gt;权力&lt;/li&gt;
&lt;li&gt;竞争&lt;/li&gt;
&lt;li&gt;工作&lt;/li&gt;
&lt;li&gt;逻辑&lt;/li&gt;
&lt;li&gt;效率&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;打断并完全获取男人的注意力才能起到沟通效果&lt;/li&gt;
&lt;li&gt;压力使男人心不在焉

&lt;ul&gt;
&lt;li&gt;更关注于问题&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;寻求帮助时，男人需要办法&lt;/li&gt;
&lt;li&gt;在处理问题时，男人直奔目的

&lt;ul&gt;
&lt;li&gt;采购&lt;/li&gt;
&lt;li&gt;处事&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;女人

&lt;ul&gt;
&lt;li&gt;发散式

&lt;ul&gt;
&lt;li&gt;感兴趣

&lt;ul&gt;
&lt;li&gt;爱情&lt;/li&gt;
&lt;li&gt;关系&lt;/li&gt;
&lt;li&gt;沟通&lt;/li&gt;
&lt;li&gt;分享&lt;/li&gt;
&lt;li&gt;合作&lt;/li&gt;
&lt;li&gt;直觉&lt;/li&gt;
&lt;li&gt;协调&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;女人心烦意乱时，并非想抱怨或指责

&lt;ul&gt;
&lt;li&gt;女人这时需要的只是倾听&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;寻求帮助时，女人需要分享&lt;/li&gt;
&lt;li&gt;在处理问题时，女人享受过程

&lt;ul&gt;
&lt;li&gt;逛街&lt;/li&gt;
&lt;li&gt;抱怨事情&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;对待压力&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;男人需要时间和空间，以寻求客观的解决之道&lt;/li&gt;
&lt;li&gt;女人需要时间和他人的关爱，去发现主观的解决之道&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;tags: Love&lt;/h2&gt;
</content>
 </entry>
 
 <entry>
   <title>JS-V8引擎</title>
   <link href="http://www.5wpc.info/it/technical/os/chromev8/2011/12/10/ChromeV8Engine"/>
   <updated>2011-12-10T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/technical/os/chromev8/2011/12/10/ChromeV8Engine</id>
   <content type="html">&lt;h1&gt;JS-V8引擎&lt;/h1&gt;

&lt;h2&gt;设计理念&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;译文地址 &lt;a href=&quot;http://blog.pluskid.org/?p=186&quot;&gt;V8 Javascript 引擎设计理念&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;快速属性访问

&lt;ul&gt;
&lt;li&gt;动态地为对象创建隐藏类

&lt;ul&gt;
&lt;li&gt;当一个新的属性被添加到对象中时，对象所对应的隐藏类会随之改变。&lt;/li&gt;
&lt;li&gt;属性访问不再需要动态字典查找了&lt;/li&gt;
&lt;li&gt;为 V8 使用经典的基于类的优化和内联缓存技术创造了条件。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;利用类转移信息，隐藏类可以被重用。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;动态机器码生成

&lt;ul&gt;
&lt;li&gt;V8 在第一次执行 JavaScript 代码的时候会将其直接编译为本地机器码，而不是使用中间字节码的形式，因此也没有解释器的存在。&lt;/li&gt;
&lt;li&gt;属性访问由内联缓存代码来完成，这些代码通常会在运行时由 V8 修改为合适的机器指令。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;高效的垃圾收集

&lt;ul&gt;
&lt;li&gt;在执行垃圾回收的时候会中断程序的执行&lt;/li&gt;
&lt;li&gt;大部分情况下，每个垃圾收集周期只处理整个对象堆的一部分，这让程序中断造成的影响得以减轻。&lt;/li&gt;
&lt;li&gt;总是知道内存中所有的对象和指针所在的位置，这避免了非 accurate 的垃圾收集器中普遍存在的由于错误地把对象当作指针而造成的内存溢出的情况。&lt;/li&gt;
&lt;li&gt;在 V8 中，对象堆被分成两部分：用于为新创建的对象分配空间的部分和用于存放在垃圾收集周期中生存下来的那些老的对象的部分。如果一个对象在垃圾收集的过程中被移动了，V8 会更新所有指向这个对象的指针到新的地址。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;API&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;基本概念 http://www.2009fly.com/index/a/bianchengyuyan/javascript/V8_Javascript_Engine/2011/0326/844.html

&lt;ul&gt;
&lt;li&gt;句柄（Handle）

&lt;ul&gt;
&lt;li&gt;从实质上来说，每一个句柄就是一个指向v8对象的指针，所有的v8对象必须使用句柄来操作。&lt;/li&gt;
&lt;li&gt;如果一个v8对象没有任何句柄与之相关联，那么这个对象很快就会被垃圾回收器给干掉（句柄跟对象的引用计数有很大关系）。&lt;/li&gt;
&lt;li&gt;具体使用

&lt;ul&gt;
&lt;li&gt;Local

&lt;ul&gt;
&lt;li&gt;存放在函数调用栈中

&lt;ul&gt;
&lt;li&gt;HandleScope

&lt;ul&gt;
&lt;li&gt;只能通过栈申请，不能使用new&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Local&lt;SomeType&gt;

&lt;ul&gt;
&lt;li&gt;父类 Handle&lt;SomeType&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Persistent

&lt;ul&gt;
&lt;li&gt;申请 Persistent::New&lt;/li&gt;
&lt;li&gt;释放 Persistent::Dispose&lt;/li&gt;
&lt;li&gt;Persistent&lt;SomeType&gt;

&lt;ul&gt;
&lt;li&gt;父类 Handle&lt;SomeType&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;作用域（Scope）

&lt;ul&gt;
&lt;li&gt;从概念上理解，作用域可以看成是一个句柄的容器，在一个作用域里面可以有很多很多个句柄（也就是说，一个scope里面可以包含很多很多个v8引擎相关的对象）&lt;/li&gt;
&lt;li&gt;句柄指向的对象是可以一个一个单独地释放的，但是很多时候（尤其是写一些“有用”的程序的时候），一个一个地释放句柄过于繁琐，取而代之的是，可以释放一个scope，那么包含在这个scope中的所有handle就都会被统一释放掉了。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;上下文环境（Context）

&lt;ul&gt;
&lt;li&gt;可以理解为运行环境&lt;/li&gt;
&lt;li&gt;在执行javascript脚本的时候，总要有一些环境变量或者全局函数。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;API实例 http://www.cppblog.com/corelito/category/8535.html

&lt;ul&gt;
&lt;li&gt;全局模板（Global Template） http://www.cppblog.com/corelito/archive/2008/10/19/64435.html

&lt;ul&gt;
&lt;li&gt;构造一个自己系统需要的环境&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;访问器——访问脚本中的变量 http://www.cppblog.com/corelito/archive/2008/10/19/64445.html

&lt;ul&gt;
&lt;li&gt;提供哦你数据访问的接口&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;自定义函数-打印 http://www.cppblog.com/corelito/archive/2008/10/20/64545.html

&lt;ul&gt;
&lt;li&gt;扩展函数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;使用访问器访问 C++ 对象 http://www.cppblog.com/corelito/archive/2008/10/23/64654.html

&lt;ul&gt;
&lt;li&gt;相互访问&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;关键技术

&lt;ul&gt;
&lt;li&gt;相互调用与通信&lt;/li&gt;
&lt;li&gt;数据共享&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;JS引擎基本&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;已经成为一个独立的基础平台而单独存在&lt;/li&gt;
&lt;li&gt;API的基本要求

&lt;ul&gt;
&lt;li&gt;数据类型可操作&lt;/li&gt;
&lt;li&gt;运行时环境可控制&lt;/li&gt;
&lt;li&gt;数据对象集合可管理&lt;/li&gt;
&lt;li&gt;可以执行函数与脚本&lt;/li&gt;
&lt;li&gt;支持String操作

&lt;ul&gt;
&lt;li&gt;字符串基本操作&lt;/li&gt;
&lt;li&gt;正则表达式引擎&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;错误处理&lt;/li&gt;
&lt;li&gt;安全控制&lt;/li&gt;
&lt;li&gt;Debug支持&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;tags: VM&lt;/h2&gt;
</content>
 </entry>
 
 <entry>
   <title>笔试面试总结与思考</title>
   <link href="http://www.5wpc.info/it/study/whu/2011/10/13/ThinkingInFindJob"/>
   <updated>2011-10-13T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/study/whu/2011/10/13/ThinkingInFindJob</id>
   <content type="html">&lt;h1&gt;写在前面&lt;/h1&gt;

&lt;p&gt;网上已经有很多朋友分享了笔试面试的感受和经验，我也根据自己的情况做个简要的回顾。
这些文字既是对目前找工作情况的一个回顾，也是对自己今后发展的一种提示和指南。&lt;/p&gt;

&lt;h1&gt;个人状况&lt;/h1&gt;

&lt;p&gt;作为一名普通的硕士研究生，前前后后大学这五年也确实经历了不少事情：学生工作、技术开发，义务劳动等。
自己也确实对自己的计算机方向很感兴趣，从高中开始便开始了自己的程序开发之路，虽然没有取得很大的成绩，但是在一定层面上也算是培养了自己动手与思考的习惯。&lt;/p&gt;

&lt;p&gt;为了满足自己对这个领域开发的了解欲望，我前前后后做过ACM题目、VHDL硬件语言开发、C51嵌入式开发、C++系统开发、JavaWeb开发、RoR开发，也算是从最底层到高层全面接触。
其中也有不少商业项目，从中也获得了不少经济回报和能力提高。
但是总体来说，我做的大多数工作都是对于业务逻辑的研究与讨论，而很少涉及底层的技术难点研究和挖掘。
这一点对我目前找工作造成了一定影响。&lt;/p&gt;

&lt;h1&gt;目前参加的笔试和面试&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt; 淘宝笔试，直接挂了。我感觉就一个最小公共祖先的问题没有答上来。这次笔试，让我从先前的复习中警醒过来，目前的笔试面试水平已经远远不只是要求基础过硬，还需要专项的训练(譬如《编程之美》)。&lt;/li&gt;
&lt;li&gt; 人人网笔试: 当时做的是Java开发，题目主要是涉及Java的基本语言属性，多线程，各种集合类的实现区别与联系。&lt;/li&gt;
&lt;li&gt; 人人网面试: 由于仍然是Java开发，和面试官交流的多为Java的语法点、线程池、各种集合以及一些很有技巧的编程题目: 寻找单链表的环、O(1)复杂度的Min栈操作。&lt;/li&gt;
&lt;li&gt; 百度笔试: 软件研发工程师方向，考察的多为基础的数据结构算法题以及海量数据处理的设计题。&lt;/li&gt;
&lt;li&gt; 腾讯笔试: 由于签订了保密协定，在这里就不做透露了。&lt;/li&gt;
&lt;li&gt; 阿里云笔试: 同样不方便透露。&lt;/li&gt;
&lt;li&gt; 百度面试: 一面二面都是算法题，由于大量涉及海量数据处理，基于字典的字符数据查找和对于你自己简历中涉及到的项目的深入讨论。&lt;/li&gt;
&lt;li&gt; 阿里云面试: 从简历出发不断挖深。&lt;/li&gt;
&lt;li&gt; 腾讯面试: 也是从简历出发，兼顾开放的思维交流。&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;小结与建议&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt; 在撰写自己简历的时候，三思而后行。不要急求于简历内容的扩张，要真正挖掘自己所经历项目、活动、比赛中的具体收获与真正提高。这也要求我们在今后参与项目开发时，不但能够很好的完成自己的业务逻辑需求，更多地是从专业眼光出发挖掘其中的技术难点和原理，俗话说知其然更要知其所以然嘛。&lt;/li&gt;
&lt;li&gt; 在个人复习时从基础出发，我这里主要是谈谈技术开发。语言关自然不多说，C系自然需要融会贯通于指针、链表、虚类等语言构件；然后就是把语言很好运用起来的数据结构与算法: &lt;a href=&quot;/it/technical/algorithm/2011/10/08/DataStructuresLinks/&quot;&gt;数据结构相关知识&lt;/a&gt;&lt;/li&gt;
&lt;li&gt; HR等: 这个我没有做相关练习，求高人指点。&lt;/li&gt;
&lt;li&gt; 通过《程序员面试宝典》、《编程之美》拓展思路总结自己&lt;/li&gt;
&lt;li&gt; 多动手写实际代码&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;相关材料&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt; &lt;a href=&quot;/it/study/whu/2011/09/22/FindJob/&quot;&gt;笔试面试题汇总&lt;/a&gt;&lt;/li&gt;
&lt;li&gt; &lt;a href=&quot;/it/technical/algorithm/2011/09/15/DataStructures/&quot;&gt;数据结构代码&lt;/a&gt;&lt;/li&gt;
&lt;li&gt; &lt;a href=&quot;/it/technical/design/2011/09/22/DesignPattern/&quot;&gt;设计模式相关&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

</content>
 </entry>
 
 <entry>
   <title>数据结构</title>
   <link href="http://www.5wpc.info/it/technical/algorithm/2011/10/08/DataStructuresLinks"/>
   <updated>2011-10-08T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/technical/algorithm/2011/10/08/DataStructuresLinks</id>
   <content type="html">&lt;h1&gt;数据结构&lt;/h1&gt;

&lt;h2&gt;图&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;搜索

&lt;ul&gt;
&lt;li&gt;广度&lt;/li&gt;
&lt;li&gt;深度&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;拓扑排序&lt;/li&gt;
&lt;li&gt;最小生成树&lt;/li&gt;
&lt;li&gt;最短路径&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;树形结构&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;二叉树

&lt;ul&gt;
&lt;li&gt;遍历

&lt;ul&gt;
&lt;li&gt;前序&lt;/li&gt;
&lt;li&gt;中序

&lt;ul&gt;
&lt;li&gt;和另外一个序一起还原二叉树

&lt;ul&gt;
&lt;li&gt;排序二叉树思维加权&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;转换成双向链表&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;后序&lt;/li&gt;
&lt;li&gt;层次&lt;/li&gt;
&lt;li&gt;结果序列配合排序二叉树判断合法性

&lt;ul&gt;
&lt;li&gt;利用根节点对序列进行切割&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;霍夫曼&lt;/li&gt;
&lt;li&gt;共同祖先

&lt;ul&gt;
&lt;li&gt;离线&lt;/li&gt;
&lt;li&gt;在线&lt;/li&gt;
&lt;li&gt;含有父亲节点

&lt;ul&gt;
&lt;li&gt;链表相交问题&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;遍历查询&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;线索&lt;/li&gt;
&lt;li&gt;排序二叉树

&lt;ul&gt;
&lt;li&gt;平衡二叉树&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;m叉树

&lt;ul&gt;
&lt;li&gt;B树&lt;/li&gt;
&lt;li&gt;B+树&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;线性结构&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;数组

&lt;ul&gt;
&lt;li&gt;循环左移

&lt;ul&gt;
&lt;li&gt;(A&lt;sup&gt;B&lt;/sup&gt;^)^=BA&lt;/li&gt;
&lt;li&gt;二分查找

&lt;ul&gt;
&lt;li&gt;分类讨论&lt;/li&gt;
&lt;li&gt;注意边界值&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;排序

&lt;ul&gt;
&lt;li&gt;插入

&lt;ul&gt;
&lt;li&gt;升序O(n)&lt;/li&gt;
&lt;li&gt;降序O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;冒泡

&lt;ul&gt;
&lt;li&gt;升序O(n&lt;sup&gt;2&lt;/sup&gt;)

&lt;ul&gt;
&lt;li&gt;加标记改进

&lt;ul&gt;
&lt;li&gt;O(n)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;降序O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;选择

&lt;ul&gt;
&lt;li&gt;升序O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/li&gt;
&lt;li&gt;降序O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;希尔

&lt;ul&gt;
&lt;li&gt;O(n&lt;sup&gt;1&lt;/sup&gt;.25)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;快速

&lt;ul&gt;
&lt;li&gt;Partition思维

&lt;ul&gt;
&lt;li&gt;两边夹交换处理&lt;/li&gt;
&lt;li&gt;双前进推进处理

&lt;ul&gt;
&lt;li&gt;最长数字&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;归并&lt;/li&gt;
&lt;li&gt;堆排序

&lt;ul&gt;
&lt;li&gt;结构&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;线性时间

&lt;ul&gt;
&lt;li&gt;基数&lt;/li&gt;
&lt;li&gt;桶排&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;可伸缩数组

&lt;ul&gt;
&lt;li&gt;平摊分析

&lt;ul&gt;
&lt;li&gt;Java

&lt;ul&gt;
&lt;li&gt;Vector

&lt;ul&gt;
&lt;li&gt;线程安全&lt;/li&gt;
&lt;li&gt;翻倍增长&lt;/li&gt;
&lt;li&gt;Stack&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ArrayList

&lt;ul&gt;
&lt;li&gt;150%增长&lt;/li&gt;
&lt;li&gt;Object[]&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Hash

&lt;ul&gt;
&lt;li&gt;Map

&lt;ul&gt;
&lt;li&gt;允许null，即null value和null key&lt;/li&gt;
&lt;li&gt;WeakHashMap

&lt;ul&gt;
&lt;li&gt;如果一个key不再被外部所引用，那么该key可以被GC回收&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Table

&lt;ul&gt;
&lt;li&gt;线程安全&lt;/li&gt;
&lt;li&gt;任何非空（non-null）的对象都可作为key或者value&lt;/li&gt;
&lt;li&gt;default-size=101&lt;/li&gt;
&lt;li&gt;icrease-factor=0.75&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;按照散列函数的定义，如果两个对象相 同，即obj1.equals(obj2)=true，则它们的hashCode必须相同，但如果两个对象不同，则它们的hashCode不一定不同，如 果两个不同对象的hashCode相同，这种现象称为冲突，冲突会导致操作哈希表的时间开销增大，所以尽量定义好的hashCode()方法，能加快哈希 表的操作&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Set

&lt;ul&gt;
&lt;li&gt;任意的两个元素e1和e2都有e1.equals(e2)=false&lt;/li&gt;
&lt;li&gt;HashSet

&lt;ul&gt;
&lt;li&gt;HashSet 是一个由 HashMap 组装出的类,自己的值做key , static final Object PRESENT做value&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;链表

&lt;ul&gt;
&lt;li&gt;Java

&lt;ul&gt;
&lt;li&gt;LinkedList

&lt;ul&gt;
&lt;li&gt;无同步方法

&lt;ul&gt;
&lt;li&gt;List list = Collections.synchronizedList(new LinkedList(...));&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;找环&lt;/li&gt;
&lt;li&gt;找交叉&lt;/li&gt;
&lt;li&gt;双开:一起跑

&lt;ul&gt;
&lt;li&gt;倒数第K个&lt;/li&gt;
&lt;li&gt;x/y&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;排序

&lt;ul&gt;
&lt;li&gt;冒泡

&lt;ul&gt;
&lt;li&gt;向后冒泡:最大值&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;有序链表合并&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;时间插入、删除

&lt;ul&gt;
&lt;li&gt;替代O(1)&lt;/li&gt;
&lt;li&gt;遍历O(n)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;栈

&lt;ul&gt;
&lt;li&gt;O(1):Min,Max&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;队列&lt;/li&gt;
&lt;li&gt;BitMap&lt;/li&gt;
&lt;li&gt;串

&lt;ul&gt;
&lt;li&gt;所有处理与数组一样&lt;/li&gt;
&lt;li&gt;后缀数组

&lt;ul&gt;
&lt;li&gt;最长重复字符串&lt;/li&gt;
&lt;li&gt;后缀化处理&lt;/li&gt;
&lt;li&gt;排序&lt;/li&gt;
&lt;li&gt;相邻比较&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Trie树

&lt;ul&gt;
&lt;li&gt;http://apps.hi.baidu.com/share/detail/15692486&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ASCII

&lt;ul&gt;
&lt;li&gt;A在a前面并且不连续&lt;/li&gt;
&lt;li&gt;脚标数组&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;模式匹配

&lt;ul&gt;
&lt;li&gt;有限自动机&lt;/li&gt;
&lt;li&gt;KMP

&lt;ul&gt;
&lt;li&gt;next&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;算法&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;动态规划

&lt;ul&gt;
&lt;li&gt;最长公共子序列&lt;/li&gt;
&lt;li&gt;最长上升子序列&lt;/li&gt;
&lt;li&gt;等等，总结基本模式

&lt;ul&gt;
&lt;li&gt;分治&lt;/li&gt;
&lt;li&gt;公共子结构&lt;/li&gt;
&lt;li&gt;递推计算&lt;/li&gt;
&lt;li&gt;回溯结果&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;贪心&lt;/li&gt;
&lt;li&gt;Search

&lt;ul&gt;
&lt;li&gt;二分&lt;/li&gt;
&lt;li&gt;索引&lt;/li&gt;
&lt;li&gt;Hash&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;并查集&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;tags: DataStructure&lt;/h2&gt;
</content>
 </entry>
 
 <entry>
   <title>笔试面试杂题汇总</title>
   <link href="http://www.5wpc.info/it/study/whu/2011/09/22/FindJob"/>
   <updated>2011-09-22T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/study/whu/2011/09/22/FindJob</id>
   <content type="html">&lt;h1&gt;设计模式&lt;/h1&gt;

&lt;h2&gt;观察者&lt;/h2&gt;

&lt;p&gt;http://www.riabook.cn/doc/designpattern/images/observer-1.jpg&lt;/p&gt;

&lt;h2&gt;策略&lt;/h2&gt;

&lt;p&gt;http://www.riabook.cn/doc/designpattern/images/strategy-2.jpg&lt;/p&gt;

&lt;h2&gt;装饰者&lt;/h2&gt;

&lt;p&gt;http://www.riabook.cn/doc/designpattern/images/decorator-3.jpg&lt;/p&gt;

&lt;h2&gt;工厂&lt;/h2&gt;

&lt;p&gt;http://qjg-wiki.googlecode.com/files/AbstractFactoryDP.jpg&lt;/p&gt;

&lt;h2&gt;单例&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public class Singleton {
    private static Singleton instance = new Singleton();

    private Singleton() {
        // ....
    }

    public static Singleton getInstance() {
        return instance;
    }

    // 其它实作
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public class Singleton {
    private static Singleton instance = null;
    private Singleton(){}
    public static Singleton getInstance() {
        if (instance == null){
            synchronized(Singleton.class){
                if(instance == null) {
                     instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;http://qjg-wiki.googlecode.com/files/SingletonDP.jpg&lt;/p&gt;

&lt;h2&gt;命令&lt;/h2&gt;

&lt;p&gt;http://www.riabook.cn/doc/designpattern/images/command-2.jpg&lt;/p&gt;

&lt;h2&gt;适配器&lt;/h2&gt;

&lt;p&gt;http://www.riabook.cn/doc/designpattern/images/adapter-2.jpg&lt;/p&gt;

&lt;p&gt;http://www.riabook.cn/doc/designpattern/images/adapter-4.jpg&lt;/p&gt;

&lt;h2&gt;模板&lt;/h2&gt;

&lt;p&gt;http://www.riabook.cn/doc/designpattern/images/templateMethod-1.jpg&lt;/p&gt;

&lt;h2&gt;迭代器&lt;/h2&gt;

&lt;p&gt;http://www.riabook.cn/doc/designpattern/images/iterator-2.jpg&lt;/p&gt;

&lt;h2&gt;状态&lt;/h2&gt;

&lt;p&gt;http://www.riabook.cn/doc/designpattern/images/state-1.jpg&lt;/p&gt;

&lt;h2&gt;代理&lt;/h2&gt;

&lt;p&gt;http://www.riabook.cn/doc/designpattern/images/proxy-2.jpg&lt;/p&gt;

&lt;p&gt;http://www.riabook.cn/doc/designpattern/images/proxy-3.jpg&lt;/p&gt;

&lt;h1&gt;数据结构&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt; 寻找公共祖先: &lt;a href=&quot;http://www.cppblog.com/myjfm/archive/2011/05/12/146282.aspx&quot;&gt;寻找最近公共祖先&lt;/a&gt;&lt;/li&gt;
&lt;li&gt; 树的层次遍历: 前序、中序、后序、层次(利用队列)&lt;/li&gt;
&lt;li&gt; 单向链表的环寻找法: 互质遍历&lt;/li&gt;
&lt;li&gt; 实现一个支持O(1)时间push,pop,min,max的Stack: 在每个节点中添加数据项(目前的min、max)&lt;/li&gt;
&lt;li&gt; 堆结构以及在操作系统中的应用&lt;/li&gt;
&lt;li&gt; 有向图求环、直径、割点: 环---拓扑排序，直径---？，割点---去掉后图不再连通的点&lt;/li&gt;
&lt;li&gt; 贝叶斯分类: http://www.cnblogs.com/leoo2sk/archive/2010/09/17/naive-bayesian-classifier.html&lt;/li&gt;
&lt;li&gt; 语义网&lt;/li&gt;
&lt;li&gt; Lucence&lt;/li&gt;
&lt;li&gt; 字符串处理: 大小比较、最长公共子串、排序、Hash&lt;/li&gt;
&lt;li&gt; 给字符串s1、s2,在s1中找包含s2里所有字符的最小子串: &amp;lt;编程之美&gt;, http://topic.csdn.net/u/20101017/12/3b1dcc05-3ba0-4220-aca6-1775bff0f0b1.html&lt;/li&gt;
&lt;li&gt; 背包问题&lt;/li&gt;
&lt;li&gt; 二分搜索: &lt;a href=&quot;http://blog.csdn.net/cxh342968816/article/details/6672537&quot;&gt;递减偏移数组&lt;/a&gt;&lt;/li&gt;
&lt;li&gt; 栈与队列: &lt;a href=&quot;http://daimajishu.iteye.com/blog/1091066&quot;&gt;用两个栈实现一个队列的功能&amp;amp;&amp;amp;两个队列实现一个栈的功能&lt;/a&gt;&lt;/li&gt;
&lt;li&gt; 从尾到头输出单链表: 借助栈结构、翻转、递归、借助数组结构&lt;/li&gt;
&lt;li&gt; Tie树如何实现&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;数据库&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt; MySQL 调优、索引&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;语言相关&lt;/h1&gt;

&lt;h2&gt;Java&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt; ArrayList, LinkedList, HashSet, HashMap, Vector, HashTable: http://hi.baidu.com/whufengchen/blog/item/7e9c59ffd2b7e00708244d48.html&lt;/li&gt;
&lt;li&gt; 动态代理: RTTI&lt;/li&gt;
&lt;li&gt; 静态代理: 通过包装类来实现&lt;/li&gt;
&lt;li&gt; 框架区别与联系&lt;/li&gt;
&lt;li&gt; 线程池&lt;/li&gt;
&lt;/ol&gt;


&lt;h3&gt;Java IO&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;  BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(new File(&quot;abc&quot;))));
  reader.close();
  BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(new File(&quot;bb&quot;))));
  writer.close();
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;C/C++&lt;/h2&gt;

&lt;h3&gt;二进制1的个数&lt;/h3&gt;

&lt;p&gt;主要是需要考虑各种类型，负数:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;template&amp;lt;typename T&amp;gt;
int countbits1(T x)
{
  int count = 0;
  while(x){
    count++;
    x &amp;amp;= (x- ((T)1));
  }
  return count;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;名词&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt; DOM: Document Object Model&lt;/li&gt;
&lt;li&gt; SAX: Simple API for XML&lt;/li&gt;
&lt;li&gt; SOAP:Simple Object Access Protocol&lt;/li&gt;
&lt;li&gt; DOM,SAX,SOAP: http://apps.hi.baidu.com/share/detail/34673620&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;操作系统&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt; 内存管理&lt;/li&gt;
&lt;li&gt; 任务调度&lt;/li&gt;
&lt;li&gt; 进程:

&lt;ol&gt;
&lt;li&gt;死锁:&lt;/li&gt;
&lt;li&gt; 必要条件:

&lt;ol&gt;
&lt;li&gt;互斥&lt;/li&gt;
&lt;li&gt;请求和保持&lt;/li&gt;
&lt;li&gt;不剥夺&lt;/li&gt;
&lt;li&gt;环路等待&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt; 处理方法:

&lt;ol&gt;
&lt;li&gt;预防&lt;/li&gt;
&lt;li&gt;避免&lt;/li&gt;
&lt;li&gt;检测&lt;/li&gt;
&lt;li&gt;解除&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;硬件&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt; 硬盘到四种接口: SATA(串口), SCSI，FC，SAS&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;专题&lt;/h1&gt;

&lt;h2&gt;常见的海量数据处理方法&lt;/h2&gt;

&lt;p&gt;从思路上考虑，首先是普通内存空间是否可以存储。
可以存储则可以考虑使用平衡树/Hash等进行处理，如果不行则需要利用检索的数据处理思路。
将数据通过Hash存储到相对较小的空间单元(可以放在内存中)，然后通过进一步的二叉树进行处理。&lt;/p&gt;

&lt;h3&gt;给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？&lt;/h3&gt;

&lt;p&gt;方案1：
可以估计每个文件的大小为50G×64=320G，远远大于内存限制的4G。
所以不可能将其完全加载到内存中处理。
考虑采取分而治之的方法。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt; 遍历文件a，对每个url求取Hash，然后根据所取得的值将url分别存储到1000个小文件（记为A）中。这样每个小文件的大约为300M。&lt;/li&gt;
&lt;li&gt; 遍历文件b，采取和a相同的方式将url分别存储到1000各小文件（记为B）。这样处理后，所有可能相同的url都在对应的小文件中，不对应的小文件不可能有相同的url。然后我们只要求出1000对小文件中相同的url即可。&lt;/li&gt;
&lt;li&gt; 求每对小文件中相同的url时，可以把其中一个小文件的url存储到hash_set中。然后遍历另一个小文件的每个url，看其是否在刚才构建的hash_set中，如果是，那么就是共同的url，存到文件里面就可以了。&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;方案2：
如果允许有一定的错误率，可以使用Bloom filter，4G内存大概可以表示340亿bit。
将其中一个文件中的url使用Bloom filter映射为这340亿bit，然后挨个读取另外一个文件的url，检查是否与Bloom filter，如果是，那么该url应该是共同的url（注意会有一定的错误率）。&lt;/p&gt;

&lt;h3&gt;有10个文件，每个文件1G，每个文件的每一行存放的都是用户的query，每个文件的query都可能重复。要求你按照query的频度排序。&lt;/h3&gt;

&lt;p&gt;方案1：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt; 顺序读取10个文件，按照hash(query)%10的结果将query写入到另外10个文件（记为A）中。这样新生成的文件每个的大小大约也1G（假设hash函数是随机的）。&lt;/li&gt;
&lt;li&gt; 找一台内存在2G左右的机器，依次对A用hash_map(query, query_count)来统计每个query出现的次数。利用快速/堆/归并排序按照出现次数进行排序。将排序好的query和对应的 query_cout输出到文件中。这样得到了10个排好序的文件（记为B）。&lt;/li&gt;
&lt;li&gt; 对B这10个文件进行归并排序（内排序与外排序相结合）。&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;方案2：&lt;/p&gt;

&lt;p&gt;一般query的总量是有限的，只是重复的次数比较多而已，可能对于所有的query，一次性就可以加入到内存了。这样，我们就可以采用trie树/hash_map等直接来统计每个query出现的次数，然后按出现次数做快速/堆/归并排序就可以了。&lt;/p&gt;

&lt;p&gt;方案3：&lt;/p&gt;

&lt;p&gt;与方案1类似，但在做完hash，分成多个文件后，可以交给多个文件来处理，采用分布式的架构来处理（比如MapReduce），最后再进行合并。&lt;/p&gt;

&lt;h3&gt;有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词。&lt;/h3&gt;

&lt;p&gt;方案1：顺序读文件中，对于每个词x，取Hash(x)%5000，然后按照该值存到5000个小文件（记为A）中。这样每个文件大概是200k左右。如果其中的有的文件超过了1M大小，还可以按照类似的方法继续往下分，知道分解得到的小文件的大小都不超过1M。对A每个小文件，统计每个文件中出现的词以及相应的频率（可以采用trie树/hash_map等），并取出出现频率最大的100个词（可以用含100个结点的最小堆），并把100词及相应的频率存入文件，这样又得到了5000个文件。下一步就是把这5000个文件进行归并（类似与归并排序）的过程了。&lt;/p&gt;

&lt;h3&gt;海量日志数据，提取出某日访问百度次数最多的那个IP。&lt;/h3&gt;

&lt;p&gt;方案1：首先是这一天，并且是访问百度的日志中的IP取出来，逐个写入到一个大文件中。注意到IP是32位的，最多有2&lt;sup&gt;32&lt;/sup&gt;个IP。同样可以采用映射的方法，比如模1000，把整个大文件映射为1000个小文件，再找出每个小文中出现频率最大的IP（可以采用hash_map进行频率统计，然后再找出频率最大的几个）及相应的频率。然后再在这1000个最大的IP中，找出那个频率最大的IP，即为所求。&lt;/p&gt;

&lt;h3&gt;在2.5亿个整数中找出不重复的整数，内存不足以容纳这2.5亿个整数。&lt;/h3&gt;

&lt;p&gt;方案1：采用2-Bitmap（每个数分配2bit，00表示不存在，01表示出现一次，10表示多次，11无意义）进行，共需内存2.5G*2/32&amp;lt;&amp;lt;2.5G，还可以接受。然后扫描这2.5亿个整数，查看Bitmap中相对应位，如果是00变01，01变10，10保持不变。所描完事后，查看 bitmap，把对应位是01的整数输出即可。
方案2：也可采用上题类似的方法，进行划分小文件的方法。然后在小文件中找出不重复的整数，并排序。然后再进行归并，注意去除重复的元素。&lt;/p&gt;

&lt;h3&gt;海量数据分布在100台电脑中，想个办法高校统计出这批数据的TOP10。&lt;/h3&gt;

&lt;p&gt;方案1：&lt;/p&gt;

&lt;p&gt;s 在每台电脑上求出TOP10，可以采用包含10个元素的堆完成（TOP10小，用最大堆，TOP10大，用最小堆）。比如求TOP10大，我们首先取前 10个元素调整成最小堆，如果发现，然后扫描后面的数据，并与堆顶元素比较，如果比堆顶元素大，那么用该元素替换堆顶，然后再调整为最小堆。最后堆中的元 素就是TOP10大。&lt;/p&gt;

&lt;p&gt;s 求出每台电脑上的TOP10后，然后把这100台电脑上的TOP10组合起来，共1000个数据，再利用上面类似的方法求出TOP10就可以了。&lt;/p&gt;

&lt;h3&gt;怎么在海量数据中找出重复次数最多的一个？&lt;/h3&gt;

&lt;p&gt;方案1：先做hash，然后求模映射为小文件，求出每个小文件中重复次数最多的一个，并记录重复次数。然后找出上一步求出的数据中重复次数最多的一个就是所求（具体参考前面的题）。&lt;/p&gt;

&lt;h3&gt;上千万或上亿数据（有重复），统计其中出现次数最多的前N个数据。&lt;/h3&gt;

&lt;p&gt;方案1：上千万或上亿的数据，现在的机器的内存应该能存下。所以考虑采用hash_map/搜索二叉树/红黑树等来进行统计次数。然后就是取出前N个出现次数最多的数据了，可以用第6题提到的堆机制完成。&lt;/p&gt;

&lt;h3&gt;1000万字符串，其中有些是重复的，需要把重复的全部去掉，保留没有重复的字符串。请怎么设计和实现？&lt;/h3&gt;

&lt;p&gt;方案1：这题用trie树比较合适，hash_map也应该能行。&lt;/p&gt;

&lt;h3&gt;一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词，请给出思想，给出时间复杂度分析。&lt;/h3&gt;

&lt;p&gt;方案1：这题是考虑时间效率。用trie树统计每个词出现的次数，时间复杂度是O(n*le)（le表示单词的平准长度）。然后是找出出现最频繁的 前10个词，可以用堆来实现，前面的题中已经讲到了，时间复杂度是O(n*lg10)。所以总的时间复杂度，是O(n*le)与O(n*lg10)中较大 的哪一个。&lt;/p&gt;

&lt;h3&gt;一个文本文件，找出前10个经常出现的词，但这次文件比较长，说是上亿行或十亿行，总之无法一次读入内存，问最优解。&lt;/h3&gt;

&lt;p&gt;方案1：首先根据用hash并求模，将文件分解为多个小文件，对于单个文件利用上题的方法求出每个文件件中10个最常出现的词。然后再进行归并处理，找出最终的10个最常出现的词。&lt;/p&gt;

&lt;h3&gt;100w个数中找出最大的100个数。&lt;/h3&gt;

&lt;p&gt;方案1：在前面的题中，我们已经提到了，用一个含100个元素的最小堆完成。复杂度为O(100w*lg100)。&lt;/p&gt;

&lt;p&gt;方案2：采用快速排序的思想，每次分割之后只考虑比轴大的一部分，知道比轴大的一部分在比100多的时候，采用传统排序算法排序，取前100个。复杂度为O(100w*100)。&lt;/p&gt;

&lt;p&gt;方案3：采用局部淘汰法。选取前100个元素，并排序，记为序列L。然后一次扫描剩余的元素x，与排好序的100个元素中最小的元素比，如果比这个 最小的要大，那么把这个最小的元素删除，并把x利用插入排序的思想，插入到序列L中。依次循环，知道扫描了所有的元素。复杂度为O(100w*100)。&lt;/p&gt;

&lt;h3&gt;寻找热门查询：&lt;/h3&gt;

&lt;p&gt;搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节。假设目前有一千万个记录，这些查询串的重复 读比较高，虽然总数是1千万，但是如果去除重复和，不超过3百万个。一个查询串的重复度越高，说明查询它的用户越多，也就越热门。请你统计最热门的10个 查询串，要求使用的内存不能超过1G。&lt;/p&gt;

&lt;p&gt;(1) 请描述你解决这个问题的思路；&lt;/p&gt;

&lt;p&gt;(2) 请给出主要的处理流程，算法，以及算法的复杂度。&lt;/p&gt;

&lt;p&gt;方案1：采用trie树，关键字域存该查询串出现的次数，没有出现为0。最后用10个元素的最小推来对出现频率进行排序。&lt;/p&gt;

&lt;h3&gt;一共有N个机器，每个机器上有N个数。每个机器最多存O(N)个数并对它们操作。如何找到 个数中的中数？&lt;/h3&gt;

&lt;p&gt;方案1：先大体估计一下这些数的范围，比如这里假设这些数都是32位无符号整数（共有 个）。我们把0到 的整数划分为N个范围段，每个段包含 个整数。比如，第一个段位0到 ，第二段为 到 ，…，第N个段为 到 。 然后，扫描每个机器上的N个数，把属于第一个区段的数放到第一个机器上，属于第二个区段的数放到第二个机器上，…，属于第N个区段的数放到第N个机器上。 注意这个过程每个机器上存储的数应该是O(N)的。下面我们依次统计每个机器上数的个数，一次累加，直到找到第k个机器，在该机器上累加的数大于或等于 ，而在第k-1个机器上的累加数小于 ，并把这个数记为x。那么我们要找的中位数在第k个机器中，排在第 位。然后我们对第k个机器的数排序，并找出第 个数，即为所求的中位数。复杂度是 的。&lt;/p&gt;

&lt;p&gt;方案2：先对每台机器上的数进行排序。排好序后，我们采用归并排序的思想，将这N个机器上的数归并起来得到最终的排序。找到第n个便是所求。复杂度是n(i)的。&lt;/p&gt;

&lt;h3&gt;最大间隙问题&lt;/h3&gt;

&lt;p&gt;给定n个实数 ，求着n个实数在实轴上向量2个数之间的最大差值，要求线性的时间算法。&lt;/p&gt;

&lt;p&gt;方案1：最先想到的方法就是先对这n个数据进行排序，然后一遍扫描即可确定相邻的最大间隙。但该方法不能满足线性时间的要求。故采取如下方法：&lt;/p&gt;

&lt;p&gt;s 找到n个数据中最大和最小数据max和min。&lt;/p&gt;

&lt;p&gt;s 用n-2个点等分区间&lt;code&gt;[&lt;/code&gt;min, max&lt;code&gt;]&lt;/code&gt;，即将&lt;code&gt;[&lt;/code&gt;min, max&lt;code&gt;]&lt;/code&gt;等分为n-1个区间（前闭后开区间），将这些区间看作桶，编号为 ，且桶 的上界和桶i+1的下届相同，即每个桶的大小相同。每个桶的大小为： 。实际上，这些桶的边界构成了一个等差数列（首项为min，公差为 ），且认为将min放入第一个桶，将max放入第n-1个桶。&lt;/p&gt;

&lt;p&gt;s 将n个数放入n-1个桶中：将每个元素 分配到某个桶（编号为index），其中 ，并求出分到每个桶的最大最小数据。&lt;/p&gt;

&lt;p&gt;s 最大间隙：除最大最小数据max和min以外的n-2个数据放入n-1个桶中，由抽屉原理可知至少有一个桶是空的，又因为每个桶的大小相同，所以最大间隙 不会在同一桶中出现，一定是某个桶的上界和气候某个桶的下界之间隙，且该量筒之间的桶（即便好在该连个便好之间的桶）一定是空桶。也就是说，最大间隙在桶 i的上界和桶j的下界之间产生 。一遍扫描即可完成。&lt;/p&gt;

&lt;h3&gt;将多个集合合并成没有交集的集合：给定一个字符串的集合，格式如： 。要求将其中交集不为空的集合合并，要求合并完成的集合之间无交集，例如上例应输出 。&lt;/h3&gt;

&lt;p&gt;(1) 请描述你解决这个问题的思路；&lt;/p&gt;

&lt;p&gt;(2) 给出主要的处理流程，算法，以及算法的复杂度；&lt;/p&gt;

&lt;p&gt;(3) 请描述可能的改进。&lt;/p&gt;

&lt;p&gt;方案1：采用并查集。首先所有的字符串都在单独的并查集中。然后依扫描每个集合，顺序合并将两个相邻元素合并。例如，对于 ， 首先查看aaa和bbb是否在同一个并查集中，如果不在，那么把它们所在的并查集合并，然后再看bbb和ccc是否在同一个并查集中，如果不在，那么也把 它们所在的并查集合并。接下来再扫描其他的集合，当所有的集合都扫描完了，并查集代表的集合便是所求。复杂度应该是O(NlgN)的。改进的话，首先可以 记录每个节点的根结点，改进查询。合并的时候，可以把大的和小的进行合，这样也减少复杂度。&lt;/p&gt;

&lt;h3&gt;最大子序列与最大子矩阵问题&lt;/h3&gt;

&lt;p&gt;数组的最大子序列问题：给定一个数组，其中元素有正，也有负，找出其中一个连续子序列，使和最大。&lt;/p&gt;

&lt;p&gt;方案1：这个问题可以动态规划的思想解决。设 表示以第i个元素 结尾的最大子序列，那么显然 。基于这一点可以很快用代码实现。&lt;/p&gt;

&lt;p&gt;最大子矩阵问题：给定一个矩阵（二维数组），其中数据有大有小，请找一个子矩阵，使得子矩阵的和最大，并输出这个和。&lt;/p&gt;

&lt;p&gt;方案1：可以采用与最大子序列类似的思想来解决。如果我们确定了选择第i列和第j列之间的元素，那么在这个范围内，其实就是一个最大子序列问题。如何确定第i列和第j列可以词用暴搜的方法进行。&lt;/p&gt;

&lt;h1&gt;题库&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.wangxinxin.com/archives/html/2011/09-24-post_id_591.html&quot;&gt;2012百度校园招聘笔试题（长春）通用RD-1技术研发&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/heaad/archive/2011/01/02/1924195.html&quot;&gt;那些优雅的数据结构(1):BloomFilter——大规模数据处理利器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/v_JULY_v&quot;&gt;结构之法算法之道&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>设计模式</title>
   <link href="http://www.5wpc.info/it/technical/design/2011/09/22/DesignPattern"/>
   <updated>2011-09-22T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/technical/design/2011/09/22/DesignPattern</id>
   <content type="html">&lt;h1&gt;设计模式&lt;/h1&gt;

&lt;p&gt;以下图片多来自&lt;a href=&quot;http://www.riabook.cn/doc/designpattern/&quot;&gt; 非关语言: 设计模式&lt;/a&gt;.&lt;/p&gt;

&lt;h2&gt;Creational 模式&lt;/h2&gt;

&lt;p&gt;物件的产生需要消耗系统资源，所以如何有效率的产生、管理与操作物件，一直都是值得讨论的课题， Creational 模式即与物件的建立相关，在这个分类下的模式给出了一些指导原则及设计的方向。&lt;/p&gt;

&lt;h3&gt;Simple Factory 模式&lt;/h3&gt;

&lt;p&gt;所有对象到生成都是通过普通工厂进行，消除和屏蔽大面积到New方法。&lt;/p&gt;

&lt;p&gt;http://qjg-wiki.googlecode.com/files/SimpleFactoryDP.jpg&lt;/p&gt;

&lt;h3&gt;Abstract Factory 模式&lt;/h3&gt;

&lt;p&gt;http://qjg-wiki.googlecode.com/files/AbstractFactoryDP.jpg&lt;/p&gt;

&lt;h3&gt;Builder 模式&lt;/h3&gt;

&lt;p&gt;http://qjg-wiki.googlecode.com/files/BuilderDP.jpg&lt;/p&gt;

&lt;h3&gt;Factory Method 模式&lt;/h3&gt;

&lt;p&gt;http://qjg-wiki.googlecode.com/files/FactoryMethodDP.jpg&lt;/p&gt;

&lt;h3&gt;Prototype 模式&lt;/h3&gt;

&lt;p&gt;http://qjg-wiki.googlecode.com/files/ProtoTypeDP.jpg&lt;/p&gt;

&lt;h3&gt;Singleton 模式&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public class Singleton {
    private static Singleton instance = new Singleton();

    private Singleton() {
        // ....
    }

    public static Singleton getInstance() {
        return instance;
    }

    // 其它实作
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public class Singleton {
    private static Singleton instance = null;
    private Singleton(){}
    public static Singleton getInstance() {
        if (instance == null){
            synchronized(Singleton.class){
                if(instance == null) {
                     instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;http://qjg-wiki.googlecode.com/files/SingletonDP.jpg&lt;/p&gt;

&lt;h3&gt;Registry of Singleton 模式&lt;/h3&gt;

&lt;h2&gt;Structural 模式&lt;/h2&gt;

&lt;p&gt;如何设计物件之间的静态结构，如何完成物件之间的继承、实现与依赖关系，这关乎着系统设计出来是否健壮（robust）：像是易懂、易维护、易修改、耦合度低等等议题。
Structural 模式正如其名，其分类下的模式给出了在不同场合下所适用的各种物件关系结构。&lt;/p&gt;

&lt;h3&gt;Default Adapter 模式&lt;/h3&gt;

&lt;p&gt;http://www.riabook.cn/doc/designpattern/images/defaultAdapter-2.jpg&lt;/p&gt;

&lt;h3&gt;Adapter 模式 - Object Adapter&lt;/h3&gt;

&lt;p&gt;http://www.riabook.cn/doc/designpattern/images/adapter-2.jpg&lt;/p&gt;

&lt;h3&gt;Adapter 模式 - Class Adapter&lt;/h3&gt;

&lt;p&gt;http://www.riabook.cn/doc/designpattern/images/adapter-4.jpg&lt;/p&gt;

&lt;h3&gt;Bridge 模式&lt;/h3&gt;

&lt;p&gt;http://www.riabook.cn/doc/designpattern/images/bridge-4.jpg&lt;/p&gt;

&lt;h3&gt;Composite 模式&lt;/h3&gt;

&lt;p&gt;http://www.riabook.cn/doc/designpattern/images/composite-2.jpg&lt;/p&gt;

&lt;h3&gt;Decorator 模式&lt;/h3&gt;

&lt;p&gt;http://www.riabook.cn/doc/designpattern/images/decorator-3.jpg&lt;/p&gt;

&lt;h3&gt;Facade 模式&lt;/h3&gt;

&lt;p&gt;http://www.riabook.cn/doc/designpattern/images/facade-3.jpg&lt;/p&gt;

&lt;h3&gt;Flyweight 模式&lt;/h3&gt;

&lt;p&gt;http://www.riabook.cn/doc/designpattern/images/flyweight-1.jpg&lt;/p&gt;

&lt;h3&gt;Proxy 模式（一）&lt;/h3&gt;

&lt;p&gt;http://www.riabook.cn/doc/designpattern/images/proxy-2.jpg&lt;/p&gt;

&lt;p&gt;http://www.riabook.cn/doc/designpattern/images/proxy-3.jpg&lt;/p&gt;

&lt;h3&gt;Proxy 模式（二）&lt;/h3&gt;

&lt;h2&gt;Behavioral 模式&lt;/h2&gt;

&lt;p&gt;物件之间的合作行为构成了程式最终的行为，物件之间若有设计良好的行为互动，不仅使得程式执行时更有效率，更可以让物件的职责更为清晰、整个程式的动态结构（像是物件调度）更有弹性。&lt;/p&gt;

&lt;h3&gt;Chain of Responsibility 模式&lt;/h3&gt;

&lt;p&gt;http://www.riabook.cn/doc/designpattern/images/chainOfResponsibility-1.jpg&lt;/p&gt;

&lt;h3&gt;Command 模式&lt;/h3&gt;

&lt;p&gt;http://www.riabook.cn/doc/designpattern/images/command-2.jpg&lt;/p&gt;

&lt;h3&gt;Interpreter 模式&lt;/h3&gt;

&lt;p&gt;http://www.riabook.cn/doc/designpattern/images/interpreter-1.jpg&lt;/p&gt;

&lt;h3&gt;Iterator 模式&lt;/h3&gt;

&lt;p&gt;http://www.riabook.cn/doc/designpattern/images/iterator-2.jpg&lt;/p&gt;

&lt;h3&gt;Mediator 模式&lt;/h3&gt;

&lt;p&gt;http://www.riabook.cn/doc/designpattern/images/mediator-4.jpg&lt;/p&gt;

&lt;h3&gt;Memento 模式&lt;/h3&gt;

&lt;p&gt;http://www.riabook.cn/doc/designpattern/images/memento-1.jpg&lt;/p&gt;

&lt;h3&gt;Observer 模式&lt;/h3&gt;

&lt;p&gt;http://www.riabook.cn/doc/designpattern/images/observer-1.jpg&lt;/p&gt;

&lt;h3&gt;State 模式&lt;/h3&gt;

&lt;p&gt;http://www.riabook.cn/doc/designpattern/images/state-1.jpg&lt;/p&gt;

&lt;h3&gt;Strategy 模式&lt;/h3&gt;

&lt;p&gt;http://www.riabook.cn/doc/designpattern/images/strategy-2.jpg&lt;/p&gt;

&lt;h3&gt;Template Method 模式&lt;/h3&gt;

&lt;p&gt;http://www.riabook.cn/doc/designpattern/images/templateMethod-1.jpg&lt;/p&gt;

&lt;h3&gt;Visitor 模式&lt;/h3&gt;

&lt;p&gt;http://www.riabook.cn/doc/designpattern/images/visitor-1.jpg&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>课程Courses</title>
   <link href="http://www.5wpc.info/it/study/whu/2011/09/19/Courses"/>
   <updated>2011-09-19T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/study/whu/2011/09/19/Courses</id>
   <content type="html">&lt;h1&gt;课程Courses&lt;/h1&gt;

&lt;h2&gt;SSD&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;信息系统概论（SSD1 Introduction to Information Systems）: 该课程向学员介绍软件开发的基本概念和技巧。

&lt;ul&gt;
&lt;li&gt;什么是计算机&lt;/li&gt;
&lt;li&gt;硬件基础&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;计算机系统概论（SSD2 Introduction to Computer Systems） : 该课程向学员介绍在Internet环境下使用和维护计算机系统的基础知识

&lt;ul&gt;
&lt;li&gt;Java Servlet&lt;/li&gt;
&lt;li&gt;Java Applet&lt;/li&gt;
&lt;li&gt;JSP/Web&lt;/li&gt;
&lt;li&gt;MySQL

&lt;ul&gt;
&lt;li&gt;iBatis&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;面向对象的编程与设计（SSD3 Object－Oriented Programming and Design）: 该课程向学员介绍面向对象的程序设计的基本原理及其实现的方法，重点放在针对具体问题的分析和解决方案的设计、程序编制及实现。

&lt;ul&gt;
&lt;li&gt;Java

&lt;ul&gt;
&lt;li&gt;Thinking In Java&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Design Patterns&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;用户界面设计与测试（SSD4 User-Centered Design and Testing）: 该课程强调软件的人机交互性能，重点训练学员在任务分析和界面评估及设计方面的能力。

&lt;ul&gt;
&lt;li&gt;VB&lt;/li&gt;
&lt;li&gt;UI&lt;/li&gt;
&lt;li&gt;用户可用性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;数据结构和算法（SSD5 Data Structures and Algorithms）: 本课程重点在于让学员理解数据结构和算法的选择对于程序执行时间、带宽和存储量的决定性作用。学员将在实际工作中自觉地考虑数据结构和算法选择的正确性和复杂性问题。

&lt;ul&gt;
&lt;li&gt;算法导论&lt;/li&gt;
&lt;li&gt;基础算法&lt;/li&gt;
&lt;li&gt;数据结构&lt;/li&gt;
&lt;li&gt;Compiler

&lt;ul&gt;
&lt;li&gt;解释器构造&lt;/li&gt;
&lt;li&gt;Ruby&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;系统编程（SSD6 System-Level Programming） : 本课程要求学员站在程序规划者的高度来对待处理器、存储器和操作系统。

&lt;ul&gt;
&lt;li&gt;深入理解计算机&lt;/li&gt;
&lt;li&gt;实用的计算机体系结构&lt;/li&gt;
&lt;li&gt;C/C++&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;数据库系统（SSD7 Database Systems） : 本课程将向学员介绍数据库的概念和设计数据库的相关知识。关系数据模型将被作为教学重点。

&lt;ul&gt;
&lt;li&gt;MySQL&lt;/li&gt;
&lt;li&gt;SQL&lt;/li&gt;
&lt;li&gt;数据库设计&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;网络与分布式系统（SSD8 Networks and Distributed Computing）: 该课程注重讲解网络计算的原则和实践。课程是从支持数据和多媒体通讯的网络技术描述开始，再到面向应用的协议，最后是基于Java，面向对象的分布式程序设计。

&lt;ul&gt;
&lt;li&gt;UNIX&lt;/li&gt;
&lt;li&gt;Socket&lt;/li&gt;
&lt;li&gt;Web Server&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;软件系统规范、测试和维护（SSD9 Software Specification Testing and Maintenance）: 该课程关注基于软件工程实践的软件发展规律。以独立或合作的方式，通过参与基于Internet的软件项目的开发工作，学员将获得涵盖软件产品生命周期所有阶段的宝贵经验。

&lt;ul&gt;
&lt;li&gt;JUnit&lt;/li&gt;
&lt;li&gt;TDD&lt;/li&gt;
&lt;li&gt;BDD&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;软件项目的管理与组织（SSD10 Software Project Organization and Management）: 该课程聚焦在软件项目的管理和组织问题上。学员将通过交互式的观察，检查和比较各种各样的计划和管理方案，学习到软件项目的计划、工作日程安排、成本核算和组织的方法。

&lt;ul&gt;
&lt;li&gt;BDD&lt;/li&gt;
&lt;li&gt;敏捷软件开发

&lt;ul&gt;
&lt;li&gt;RoR&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;针对性学习&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;数字图象处理&lt;/li&gt;
&lt;li&gt;模式识别&lt;/li&gt;
&lt;li&gt;嵌入式开发&lt;/li&gt;
&lt;li&gt;数字逻辑&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;数学基础&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;高数&lt;/li&gt;
&lt;li&gt;线性代数&lt;/li&gt;
&lt;li&gt;概率论&lt;/li&gt;
&lt;li&gt;离散数学&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;外语基础&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;听说读写&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;tags: StudySummary&lt;/h2&gt;
</content>
 </entry>
 
 <entry>
   <title>算法与数据结构小结</title>
   <link href="http://www.5wpc.info/it/technical/algorithm/2011/09/15/DataStructures"/>
   <updated>2011-09-15T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/technical/algorithm/2011/09/15/DataStructures</id>
   <content type="html">&lt;h1&gt;算法与数据结构小结&lt;/h1&gt;

&lt;h2&gt;概述&lt;/h2&gt;

&lt;p&gt;本科阶段学习数据结构与算法主要是受高中NOIP、NOI以及大学ACM等比赛的影响。
另一方面，感觉这些东西能够激发自己的兴趣爱好，何乐而不为呢？&lt;/p&gt;

&lt;p&gt;在大一下学期时，我立下了一个目标: 争取认真阅读《算法导论》并力争完成所有的课后题。
现在翻看过去的笔记，已经是多少年以前的事情了。
至此，我准备借着复习之际将当时的笔记与现在的体会放在这个Wiki上面。&lt;/p&gt;

&lt;h2&gt;算法导论&lt;/h2&gt;

&lt;h3&gt;第一部分 基础知识&lt;/h3&gt;

&lt;h4&gt;分析基础&lt;/h4&gt;

&lt;p&gt;利用渐进分析技术对具体算法的时间复杂度进行分析。&lt;/p&gt;

&lt;h4&gt;基本设计方法&lt;/h4&gt;

&lt;h5&gt;分而治之&lt;/h5&gt;

&lt;p&gt;在算法结构上主要呈递归模式: 为了解决一个给定的问题，算法要一次或多次地递归调用其自身来解决相关的子问题。&lt;/p&gt;

&lt;p&gt;分治策略: 将原文题划分成n个规模较小而结构与原问题相似的子问题；递归地解决这些子问题，然后再合并其结果，就得到原问题的解。&lt;/p&gt;

&lt;p&gt;每一层递归上的基本步骤:
  1. 分解，将原问题分解成一系列子问题
  1. 解决，递归地解各个子问题。若子问题足够小，则直接求解
  1. 合并，将子问题的结果合并成原问题的解&lt;/p&gt;

&lt;h4&gt;随机分析和随机算法&lt;/h4&gt;

&lt;p&gt;在算法中添加随机处理技术，将固有的问题做随机化处理，使其能够有效地呈现出一般趋势。&lt;/p&gt;

&lt;h3&gt;第二部分 排序和顺序统计学&lt;/h3&gt;

&lt;h4&gt;O(n&lt;sup&gt;2&lt;/sup&gt;^)排序方法&lt;/h4&gt;

&lt;h5&gt;插入排序&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;#A[1..length]
INSERTION-SORT(A)
  for j &amp;lt;- 2 to length[A]
  do
    key &amp;lt;- A[j]
    i &amp;lt;- j - 1
    while i&amp;gt;0 and A[i]&amp;gt;key
    do
      A[i+1] &amp;lt;- A[i]
      i &amp;lt;- i - 1
    A[i+1] &amp;lt;- key
&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;冒泡排序&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;#A[1..length]
BUBBLE-SORT(A)
  #注意边界
  for j &amp;lt;- 1 to length[A]
  do
    for i &amp;lt;- length[A] downto j+1
    do
      if A[i]&amp;lt;A[i-1]
      then
        A[i-1] &amp;lt;-&amp;gt; A[i]
&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;选择排序&lt;/h5&gt;

&lt;h5&gt;希尔排序&lt;/h5&gt;

&lt;h4&gt;O(nlog(n))排序方法&lt;/h4&gt;

&lt;h5&gt;归并排序&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;#include &amp;lt;stdio.h&amp;gt;

#define MAX (5)

int data[MAX];
int tmp[MAX];

void merge(int b,int e)
{
  printf(&quot;[%d,%d)\n&quot;,b,e);
  int m = (b+e)/2;
  int p = b;
  int q = m;
  int i = 0;
  while((p&amp;lt;m)&amp;amp;&amp;amp;(q&amp;lt;e)&amp;amp;&amp;amp;(i&amp;lt;e-b+1)){
    if(data[p]&amp;lt;=data[q]) {
      tmp[i]=data[p];
      p++;
    }else{
      tmp[i]=data[q];
      q++;
    }
    i++;
  }
  while(p&amp;lt;m)tmp[i++]=data[p++];
  while(q&amp;lt;e)tmp[i++]=data[q++];
  for(i=b;i&amp;lt;e;i++)
    data[i]=tmp[i-b];
}

void merge_sort(int b,int e)
{
  if(e-b&amp;gt;1){
    int m = (e+b)/2;
    merge_sort(b,m);
    merge_sort(m,e);
    merge(b,e);
  }
}

void msort(int length)
{
  merge_sort(0,length);
}

int main()
{
  int i;
  for(i=0;i&amp;lt;MAX;i++)
    data[i]=MAX-i;
  msort(MAX);
  for(i=0;i&amp;lt;MAX;i++)
    printf(&quot;%d,&quot;,data[i]);
  printf(&quot;\n&quot;);
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;堆排序&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;
#include &amp;lt;stdio.h&amp;gt;

#define MAX (2000)

int data[MAX];
int length;
int heapsize;

inline int left(int i)
{
  return 2*i;
}

inline int right(int i)
{
  return 2*i+1;
}

inline int parent(int i)
{
  return i/2;
}

void swap(int &amp;amp;a , int &amp;amp;b)
{
  int tmp = a;
  a = b;
  b = tmp;
}

void max_heapity(int i)
{
  int l=left(i);
  int r=right(i);
  int largest = i;
  if((l&amp;lt;heapsize)&amp;amp;&amp;amp;(data[largest]&amp;lt;data[l]))largest=l;
  if((r&amp;lt;heapsize)&amp;amp;&amp;amp;(data[largest]&amp;lt;data[r]))largest=r;
  if(i!=largest){
    swap(data[i],data[largest]);
    max_heapity(largest);
  }
}

void build_heap(int len)
{
  int i;
  length = len;
  heapsize=length;
  for(i=length/2;i&amp;gt;=1;i--)
    max_heapity(i);
}

void heap_sort(int len)
{
  int i;
  build_heap(len);
  for(i=len-1;i&amp;gt;=1;i--){
    swap(data[0],data[i]);
    heapsize--;
    max_heapity(0);
  }
}

int extract()
{
  if(heapsize&amp;lt;=0){
    printf(&quot;Heap Empty.\n&quot;);
    return -1;
  }
  int value = data[0];
  data[0] = data[heapsize-1];
  heapsize--;
  max_heapity(0);
  return value;
}

void increase(int i,int key)
{
  data[i] = key;
  int p = parent(i);
  while(data[p]&amp;lt;data[i]){
    swap(data[p],data[i]);
    i=p;
    p = parent(i);
  }
}

void insert(int key)
{
  if(heapsize&amp;gt;=MAX){
    printf(&quot;Heap Full.\n&quot;);
    return;
  }
  increase(heapsize,key);
  heapsize++;
}

int main()
{
  int i;
  int value;
  for(i=0;i&amp;lt;MAX;i++)
    data[i]=MAX-i;
  heap_sort(MAX);
  for(i=0;i&amp;lt;MAX;i++)
    if(i+1!=data[i])
      printf(&quot;%d,&quot;,data[i]);
  printf(&quot;Finish Sort\n&quot;);
  heapsize = 0;
  printf(&quot;%d\n&quot;,extract());
  for(i=0;i&amp;lt;10;i++)
    insert(i);
  for(i=0;i&amp;lt;11;i++)
    if(9-i!=(value=extract()))
      printf(&quot;Er:%d,&quot;,value);
  printf(&quot;Finish IO\n&quot;);

  return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;快速排序&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;
#include &amp;lt;stdio.h&amp;gt;

#define MAX (2000000)

int data[MAX];
void swap(int &amp;amp;a , int &amp;amp;b)
{
  int tmp = a;
  a = b;
  b = tmp;
}

void qsort(int l,int r)
{
  int mid = (l+r)/2;
  int m=l;
  int n=r;
  while(m&amp;lt;=n){
    while(data[m]&amp;lt;data[mid])m++;
    while(data[n]&amp;gt;data[mid])n--;
    if(m&amp;lt;=n){
      swap(data[m],data[n]);
      m++;
      n--;
    }
  }
  if(m&amp;lt;r) qsort(m,r);
  if(l&amp;lt;n) qsort(l,n);
}

int main()
{
  int i;
  for(i=0;i&amp;lt;MAX;i++)
    data[i]=MAX-i;
  qsort(0,MAX-1);
  for(i=0;i&amp;lt;MAX;i++)
    if(i+1!=data[i])
      printf(&quot;%d,&quot;,data[i]);
  printf(&quot;Finish Sort\n&quot;);
  return 0;
}

int partition(int l, int r)
{
  int i,j;
  int key = data[r-1];
  i = l-1;
  for(j=l;j&amp;lt;r-1;j++){
    if(data[j]&amp;lt;key){
      i++;
      swap(data[i],data[j]);
    }
  }
  swap(data[i+1],data[r-1]);
  return i+1;
}

void qpsort(int l, int r)
{
  int i;
  if(l&amp;lt;r){
    i = partition(l,r);
    qpsort(l,i);
    qpsort(i+1,r);
  }
}

void random_qsort(int l,int r)
{
  int i;
  if(l&amp;lt;r){
    i = rand()%(r-l)+l;
    swap(data[i],data[r-1]);
    i = partition(l,r);
    qpsort(l,i);
    qpsort(i+1,r);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;线性查找&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;int select(int index, int l, int r)
{
  int i;
  if(l==r-1)
    return data[l];
  i = random_partition(l,r);
  if(index&amp;lt;i)
    return select(index,l,i);
  else if(index==i)
    return data[i];
  else return select(index,i+1,r);
}

int select(int index)
{
  return select(index, 0, MAX);
}
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>ComputerNetworking</title>
   <link href="http://www.5wpc.info/it/study/whu/2011/09/15/ComputerNetworking"/>
   <updated>2011-09-15T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/study/whu/2011/09/15/ComputerNetworking</id>
   <content type="html">&lt;h1&gt;ComputerNetworking&lt;/h1&gt;

&lt;h2&gt;运输层&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;服务

&lt;ul&gt;
&lt;li&gt;不同进程间看似直接相连的逻辑通信&lt;/li&gt;
&lt;li&gt;主要存在于端系统&lt;/li&gt;
&lt;li&gt;多路

&lt;ul&gt;
&lt;li&gt;复用

&lt;ul&gt;
&lt;li&gt;统一发送到网络链路中&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;分解

&lt;ul&gt;
&lt;li&gt;端系统的各进程发布与集合&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;原理

&lt;ul&gt;
&lt;li&gt;可靠数据传输

&lt;ul&gt;
&lt;li&gt;机制与用途

&lt;ul&gt;
&lt;li&gt;检验和

&lt;ul&gt;
&lt;li&gt;用于检测在一个传输分组中的比特错误&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;定时器

&lt;ul&gt;
&lt;li&gt;用于检测超时/重传一个分组，可能因为该分组(或其ACK)在信道中丢失了。由于当一个分组延时但未丢失(过早超时)，或当一个分组已被接收方收到但从接收方到发送方的ACK丢失时，可能产生超时事件，所以接收方可能会收到一个分组的多个冗余拷贝&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;序号

&lt;ul&gt;
&lt;li&gt;用于为从发送方流向接收方的数据分组按顺序编号。&lt;/li&gt;
&lt;li&gt;所接收分组的序号间的空隙可使该接收方检测出丢失的分组。具有相同序号的分组可使接收方检测出一个分组的冗余拷贝&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;确认/否定确认&lt;/li&gt;
&lt;li&gt;窗口、流水线&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;典型

&lt;ul&gt;
&lt;li&gt;TCP&lt;/li&gt;
&lt;li&gt;UDP&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;tags: Network&lt;/h2&gt;
</content>
 </entry>
 
 <entry>
   <title>GCC使用知识</title>
   <link href="http://www.5wpc.info/it/technical/continuousintegration/2011/08/25/gcc"/>
   <updated>2011-08-25T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/technical/continuousintegration/2011/08/25/gcc</id>
   <content type="html">&lt;h1&gt;GCC&lt;/h1&gt;

&lt;h2&gt;编译的各个阶段&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/iterzebra/article/details/6203067&quot;&gt;用GCC编译链接程序--编译链接器GCC常用功能（菜鸟级）&lt;/a&gt;
&lt;a href=&quot;http://grin.is-programmer.com/posts/2655&quot;&gt;如何得到 GCC 编译时各阶段的结果&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>MercurialSCM使用知识</title>
   <link href="http://www.5wpc.info/it/technical/continuousintegration/2011/08/24/mercurial"/>
   <updated>2011-08-24T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/technical/continuousintegration/2011/08/24/mercurial</id>
   <content type="html">&lt;h1&gt;MercurialSCM&lt;/h1&gt;

&lt;h2&gt;Add a footprint for a url&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt; 获取fingerprint(注意空格位置等):&lt;/li&gt;
&lt;/ol&gt;


&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;openssl s_client -connect &amp;lt;host&amp;gt;:&amp;lt;port&amp;gt; &amp;lt; /dev/null 2&amp;gt;/dev/null | openssl x509 -fingerprint -noout -in /dev/stdin
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt; 在~/.hgrc文件的hostfingerprints部分添加一行: host=fingerprint&lt;/li&gt;
&lt;/ol&gt;


&lt;h2&gt;Ubuntu hg-git plugin 配置&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://bugs.launchpad.net/ubuntu/+source/hg-git/+bug/666292&quot;&gt;修复方法&lt;/a&gt;
添加如下信息到~/.hgrc:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;bash &quot;&gt;[extensions]
hgext.bookmarks =
hggit = /usr/share/pyshared/hgext/git
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从本地文件夹转移过来，需要将git文件夹名字改为XXX.git.
&lt;a href=&quot;http://stackoverflow.com/questions/5785158/mercurial-hg-git-clone-from-a-local-directory&quot;&gt;本地同步&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;hgrc&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://www.selenic.com/mercurial/hgrc.5.html&quot;&gt;配置详解&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;认真利用:
  1. .hg/hgrc
  1. 缩写路径，存储登录帐号与密码:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;[paths]
default = https://code.google.com/p/project/default
gitserver = git+ssh://xxxx@demo.com/directory/github/xxx.git

[auth]
googlecode.prefix=https://code.google.com/p/project/default
googlecode.password=password
googlecode.username=username

gitserver.prefix=git+ssh://xxxx@demo.com/directory/github/xxx.git
gitserver.password=password
gitserver.username=username
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>Latex使用知识</title>
   <link href="http://www.5wpc.info/it/technical/language/2011/08/14/latex"/>
   <updated>2011-08-14T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/technical/language/2011/08/14/latex</id>
   <content type="html">&lt;h1&gt;Latex&lt;/h1&gt;

&lt;h2&gt;目录控制&lt;/h2&gt;

&lt;h3&gt;经典用例&lt;/h3&gt;

&lt;p&gt;充分利用自定义目录、标号和修正。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;latex&quot;&gt;\documentclass[a4paper,jounral]{report}
\usepackage{../paper/sty/dcuappendices}
\input{../paper/src/config}
\usepackage[top=\finalReporttoptextmargin, bottom=\finalReportbottomtextmargin, left=\finalReportinnersidemargin, right=\finalReportoutersidemargin]{geometry}
\usepackage{pdfpages}
\input{src/global}
\input{src/config}

% Set link in the document
\usepackage{hyperref}
\hypersetup{colorlinks,%
            citecolor=black,%
            filecolor=black,%
            linkcolor=black,%
            urlcolor=black,%
            pdfauthor={\finalReportAuthor},
            pdftitle={\finalReportTitle},
            pdfsubject={xxx},
            pdfkeywords={xxx},
            pdftex
}
\usepackage{appendix}


\begin{document}
\pagenumbering{Roman}
\setcounter{page}{1}
\input{coversheet/coversheet}

\newpage
\pagenumbering{roman}
\setcounter{page}{1}
\pagestyle{ieeeheadings}

\input{coversheet/acknowledgements}

\newpage
\input{coversheet/declaration}

\newpage
\tableofcontents

\newpage
\pagenumbering{arabic}
\setcounter{page}{1}

\phantomsection
\addcontentsline{toc}{chapter}{\finalPaperBaseTitle}
\includepdf[pages=1-5]{../paper/output/main.pdf}

\appendix
\noappendicestocpagenum

\newpage
\setcounter{page}{0}

\phantomsection
\addcontentsline{toc}{chapter}{Appendices}

\renewcommand{\thepage}{A}
\phantomsection
\addcontentsline{toc}{section}{\finalPaperAppATitle}
\includepdf[pages=7]{../paper/output/main.pdf}

\renewcommand{\thepage}{A-\arabic{page}}
\includepdf[pages=-]{../../report/output/main-final.pdf}

\newpage
\setcounter{page}{0}

\renewcommand{\thepage}{B}
\phantomsection
\addcontentsline{toc}{section}{\finalPaperAppBTitle}
\includepdf[pages=9]{../paper/output/main.pdf}

\renewcommand{\thepage}{B-\arabic{page}}
\includepdf[pages=10-11]{../paper/output/main.pdf}

\newpage
\setcounter{page}{0}

\renewcommand{\thepage}{C}
\phantomsection
\addcontentsline{toc}{section}{\finalPaperAppCTitle}
\includepdf[pages=13]{../paper/output/main.pdf}

\renewcommand{\thepage}{C-\arabic{page}}
\includepdf[pages=14-16]{../paper/output/main.pdf}

\end{document}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;页面布局&lt;/h2&gt;

&lt;h3&gt;自定义布局&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;latex&quot;&gt;\ProvidesPackage{dcuappendices}

%Set Header &amp;amp; Footer
\def\ps@ieeeheadings{
\def\@oddhead{\mbox{}\scriptsize\MakeUppercase{\finalReportLeftheaderTitle} \hfil \thepage}%
\def\@evenhead{\mbox{}\scriptsize\MakeUppercase{\finalReportLeftheaderTitle} \hfil \thepage}%
\def\@oddfoot{}%
\def\@evenfoot{}}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;页面边距设置&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;latex&quot;&gt;\usepackage[top=1in, bottom=1in, left=1.25in, right=1.25in]{geometry}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;强制figure,table进行放置停止float&lt;/h3&gt;

&lt;p&gt;Try the placeins package: it defines a \FloatBarrier command beyond which floats may not pass.
A package option allows you to declare that floats may not pass a \section command, but you can place \FloatBarriers wherever you choose.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;latex&quot;&gt;\usepackage[section]{placeins}
% Let the subsection can FloatBarrier
\let \oldsubsection \subsection
\renewcommand{\subsection}[2][]{
  \FloatBarrier
  \oldsubsection#1{#2}
}

% Let the subsubsection can FloatBarrier
\let \oldsubsubsection \subsubsection
\renewcommand{\subsubsection}[2][]{
  \FloatBarrier
  \oldsubsubsection#1{#2}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;How do I vertically center the text on a page?&lt;/h3&gt;

&lt;p&gt;纵向居中:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;latex&quot;&gt;\begin{document}
%
\vspace*{\fill}
text
\vspace*{\fill}
%
\end{document}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;合并PDF&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;latex&quot;&gt;\usepackage{pdfpages}
\includepdf[pages=1-5]{../paper/output/main.pdf}
\includepdf[pages=-]{../paper/output/main.pdf}
\includepdf[pages=3-]{../paper/output/main.pdf}
\includepdf[pages=13]{../paper/output/main.pdf}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;字号字体&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://qianjigui.iteye.com/blog/841052&quot;&gt;字体大小对照表&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;标准文档类型中字体的绝对大小&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;  &lt;em&gt;size&lt;/em&gt;         &lt;/th&gt;
&lt;th&gt;     10pt (default)&lt;/th&gt;
&lt;th&gt;   11pt option&lt;/th&gt;
&lt;th&gt;  12pt option &lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;  \tiny          &lt;/td&gt;
&lt;td&gt;          5pt      &lt;/td&gt;
&lt;td&gt;     6pt      &lt;/td&gt;
&lt;td&gt;    6pt       &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;  \scriptsize    &lt;/td&gt;
&lt;td&gt;          7pt      &lt;/td&gt;
&lt;td&gt;     8pt      &lt;/td&gt;
&lt;td&gt;    8pt       &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;  \footnotesize  &lt;/td&gt;
&lt;td&gt;          8pt      &lt;/td&gt;
&lt;td&gt;     9pt      &lt;/td&gt;
&lt;td&gt;   10pt       &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;  \small         &lt;/td&gt;
&lt;td&gt;          9pt      &lt;/td&gt;
&lt;td&gt;    10pt      &lt;/td&gt;
&lt;td&gt;   11pt       &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;  \normalsize    &lt;/td&gt;
&lt;td&gt;         10pt      &lt;/td&gt;
&lt;td&gt;    11pt      &lt;/td&gt;
&lt;td&gt;   12pt       &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;  \large         &lt;/td&gt;
&lt;td&gt;         12pt      &lt;/td&gt;
&lt;td&gt;    12pt      &lt;/td&gt;
&lt;td&gt;   14pt       &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;  \Large         &lt;/td&gt;
&lt;td&gt;         14pt      &lt;/td&gt;
&lt;td&gt;    14pt      &lt;/td&gt;
&lt;td&gt;   17pt       &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;  \LARGE         &lt;/td&gt;
&lt;td&gt;         17pt      &lt;/td&gt;
&lt;td&gt;    17pt      &lt;/td&gt;
&lt;td&gt;   20pt       &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;  \huge          &lt;/td&gt;
&lt;td&gt;         20pt      &lt;/td&gt;
&lt;td&gt;    20pt      &lt;/td&gt;
&lt;td&gt;   25pt       &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;  \Huge          &lt;/td&gt;
&lt;td&gt;         25pt      &lt;/td&gt;
&lt;td&gt;    25pt      &lt;/td&gt;
&lt;td&gt;   25pt       &lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;


&lt;h3&gt;印刷字号、磅数和级数一览表&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;  &lt;em&gt;号数&lt;/em&gt;      &lt;/th&gt;
&lt;th&gt;     &lt;em&gt;磅数(pt)&lt;/em&gt; &lt;/th&gt;
&lt;th&gt;          &lt;em&gt;尺寸（mm）&lt;/em&gt;    &lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;  大特号    &lt;/td&gt;
&lt;td&gt;      63  &lt;/td&gt;
&lt;td&gt;        22.142          &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;  特号      &lt;/td&gt;
&lt;td&gt;      54  &lt;/td&gt;
&lt;td&gt;        18.979          &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;  初号      &lt;/td&gt;
&lt;td&gt;      42  &lt;/td&gt;
&lt;td&gt;        14.761          &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;  小初号    &lt;/td&gt;
&lt;td&gt;      36  &lt;/td&gt;
&lt;td&gt;        12.653          &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;  大一号    &lt;/td&gt;
&lt;td&gt;     31.5 &lt;/td&gt;
&lt;td&gt;        11.071          &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;  一（头）号&lt;/td&gt;
&lt;td&gt;       28 &lt;/td&gt;
&lt;td&gt;         9.841          &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;  小一号    &lt;/td&gt;
&lt;td&gt;      24  &lt;/td&gt;
&lt;td&gt;              很好匹配  &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;  二号      &lt;/td&gt;
&lt;td&gt;      22  &lt;/td&gt;
&lt;td&gt;        7.381           &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;  小二号    &lt;/td&gt;
&lt;td&gt;      18  &lt;/td&gt;
&lt;td&gt;        6.326  一般匹配 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;  三号      &lt;/td&gt;
&lt;td&gt;      16  &lt;/td&gt;
&lt;td&gt;        5.62  很好匹配  &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;  小三      &lt;/td&gt;
&lt;td&gt;  15      &lt;/td&gt;
&lt;td&gt;  较好匹配              &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;  四号      &lt;/td&gt;
&lt;td&gt;      14  &lt;/td&gt;
&lt;td&gt;        4.920 完美匹配  &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;  小四号    &lt;/td&gt;
&lt;td&gt;      12  &lt;/td&gt;
&lt;td&gt;        4.218 完美匹配  &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;  五号      &lt;/td&gt;
&lt;td&gt;    10.5  &lt;/td&gt;
&lt;td&gt;        3.690 很好匹配  &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;  小五号    &lt;/td&gt;
&lt;td&gt;       9  &lt;/td&gt;
&lt;td&gt;         3.163 很好匹配 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;  六号      &lt;/td&gt;
&lt;td&gt;       8  &lt;/td&gt;
&lt;td&gt;        2.812 完美匹配  &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;  小六号    &lt;/td&gt;
&lt;td&gt;    6.875 &lt;/td&gt;
&lt;td&gt;      2.416   很好匹配  &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;  七号      &lt;/td&gt;
&lt;td&gt;     5.25 &lt;/td&gt;
&lt;td&gt;       1.845            &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;  八号      &lt;/td&gt;
&lt;td&gt;     4.5  &lt;/td&gt;
&lt;td&gt;        1.581           &lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;


&lt;h2&gt;Counter设置&lt;/h2&gt;

&lt;p&gt;http://www.personal.ceu.hu/tex/counters.htm&lt;/p&gt;

&lt;h2&gt;IEEE模板常见问题&lt;/h2&gt;

&lt;h3&gt;IEEE模板的尾页如何平衡&lt;/h3&gt;

&lt;p&gt;http://bbs.ctex.org/viewthread.php?tid=52302&lt;/p&gt;

&lt;p&gt;使用LaTeX的双栏(twocolumn)格式在最后一页如果不加修改，通常会左面到底，右面悬空这样的两边不齐的样子，这通常不是我们想要的输出。如何使双栏的底端找齐呢？基本上有如下方法:
  1. 如果文章到最后是进入到参考文献的部分，可以在你觉得应该拐弯儿的地方加入\newpage命令。可是如果你的参考文献是用BibTeX来嵌入的话，就不好办了，虽然可以在.bbl文件里面加入，但是如果重新编译了BibTeX的话，.bbl文件会被重新刷新。如果是使用IEEEtran（用来向IEEE 会刊投稿的样式）的style的话，可以使用IEEE提供的\IEEEtriggeratref{x}命令，这个命令放在bibliography的前面，x就是你想要断开的文献号码。他会在第x个参考文献前面自动加入\newpage。
  1. 如果你的文档没有参考文献，或者很少，上面的方法就不适用了。这种情况下可以用\enlargethispage{-X.Yin}命令来使最后一页的左面栏的长度缩短。这个命令需要放在你最后一页第一栏的文字顶部某处，X.Y就是要缩小的量。在IEEEtran中命令变成了\IEEEtriggercmd{\enlargethispage{-5.35in}}的格式。
  1. 使用第三方的package。如：balance.sty或者flushend.sty。虽然他们都可以很方便的得到，但是不少杂志都不太接受这种非官方的包，因为这样也许会使排版变得不够标准。所以，很多目的都必须通过很传统的LaTeX命令来实现，这也正是深入了解LaTeX的必要性。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>健康与保健</title>
   <link href="http://www.5wpc.info/it/living/life/2011/08/10/FitnessHelp"/>
   <updated>2011-08-10T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/living/life/2011/08/10/FitnessHelp</id>
   <content type="html">&lt;p&gt;页面转移到&lt;a href=&quot;/it/living/sport/2014/01/07/HealthKeep/&quot;&gt;养生与保健&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>情商训练</title>
   <link href="http://www.5wpc.info/it/living/life/2011/08/10/EqLearn"/>
   <updated>2011-08-10T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/living/life/2011/08/10/EqLearn</id>
   <content type="html">&lt;p&gt;页面已经转移到&lt;a href=&quot;/it/living/selfManagement/2014/01/07/EQ/&quot;&gt;个人管理EQ相关&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>OpenMP</title>
   <link href="http://www.5wpc.info/it/technical/multicores/2011/07/21/OpenMP"/>
   <updated>2011-07-21T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/technical/multicores/2011/07/21/OpenMP</id>
   <content type="html">&lt;h1&gt;OpenMP&lt;/h1&gt;

&lt;h2&gt;基本原理&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Fork/Join多线程模型&lt;/li&gt;
&lt;li&gt;在线程级别采用&lt;em&gt;共享内存&lt;/em&gt;并行计算模型&lt;/li&gt;
&lt;li&gt;程序员需要自我处理好并行逻辑问题&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;基础API&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Construct构建语句(和编程语句一样，引导编译器做处理)

&lt;ul&gt;
&lt;li&gt;Parallel声明下面的代码块将进行并行处理

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;blockquote&gt;
    &lt;b&gt;#pragma omp parallel&lt;/b&gt; &lt;i&gt;&lt;code&gt;[&lt;/code&gt;clause&lt;code&gt;[``[&lt;/code&gt;,&lt;code&gt;]&lt;/code&gt; clause&lt;code&gt;]&lt;/code&gt;...&lt;code&gt;]&lt;/code&gt;&lt;/i&gt;
        &lt;i&gt;structured block&lt;/i&gt;
&lt;/blockquote&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;clauses

&lt;ul&gt;
&lt;li&gt;if(scalar-expression)&lt;/li&gt;
&lt;li&gt;num_threads(integer-expression)&lt;/li&gt;
&lt;li&gt;private(list)&lt;/li&gt;
&lt;li&gt;firstprivate(list)&lt;/li&gt;
&lt;li&gt;shared(list)&lt;/li&gt;
&lt;li&gt;default(none|shared)&lt;/li&gt;
&lt;li&gt;copyin(list)&lt;/li&gt;
&lt;li&gt;reduction(operator:list)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Work-Sharing以下代码将进行多线程改写

&lt;ul&gt;
&lt;li&gt;iterations over the threads 不依赖迭代

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;blockquote&gt;
    &lt;b&gt;#pragma omp for &lt;/b&gt;&lt;i&gt;&lt;code&gt;[&lt;/code&gt;clause&lt;code&gt;[``[&lt;/code&gt;,&lt;code&gt;]&lt;/code&gt; clause&lt;code&gt;]&lt;/code&gt;...&lt;code&gt;]&lt;/code&gt; &lt;/i&gt;
        &lt;i&gt;for-loop&lt;/i&gt;
&lt;/blockquote&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;clauses

&lt;ul&gt;
&lt;li&gt;private(list)&lt;/li&gt;
&lt;li&gt;firstprivate(list)&lt;/li&gt;
&lt;li&gt;lastprivate(list)&lt;/li&gt;
&lt;li&gt;reduction(operator:list)&lt;/li&gt;
&lt;li&gt;ordered&lt;/li&gt;
&lt;li&gt;schedule(kind&lt;code&gt;[&lt;/code&gt;,chunk_size&lt;code&gt;]&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;nowait&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;independent work units相互独立的代码单元

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;blockquote&gt;
    &lt;b&gt;#pragma omp sections &lt;/b&gt;&lt;i&gt;&lt;code&gt;[&lt;/code&gt;clause&lt;code&gt;[``[&lt;/code&gt;,&lt;code&gt;]&lt;/code&gt; clause&lt;code&gt;]&lt;/code&gt;...&lt;code&gt;]&lt;/code&gt; &lt;/i&gt;
     {
         &lt;code&gt;[&lt;/code&gt;&lt;b&gt;#pragma omp section&lt;/b&gt;&lt;code&gt;]&lt;/code&gt;
               structured block
         &lt;code&gt;[&lt;/code&gt;&lt;b&gt;#pragma omp section&lt;/b&gt;&lt;code&gt;]&lt;/code&gt;
               structured block
         ......
      }
&lt;/blockquote&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;clauses

&lt;ul&gt;
&lt;li&gt;private(list)&lt;/li&gt;
&lt;li&gt;firstprivate(list)&lt;/li&gt;
&lt;li&gt;lastprivate(list)&lt;/li&gt;
&lt;li&gt;reduction(operator:list)&lt;/li&gt;
&lt;li&gt;nowait&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Only one thread executes the code block只有一个线程运行的代码单元

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;blockquote&gt;
    &lt;b&gt;#pragma omp single &lt;/b&gt;&lt;i&gt;&lt;code&gt;[&lt;/code&gt;clause&lt;code&gt;[``[&lt;/code&gt;,&lt;code&gt;]&lt;/code&gt; clause&lt;code&gt;]&lt;/code&gt; ...&lt;code&gt;]&lt;/code&gt; &lt;/i&gt;
         &lt;i&gt;structured block&lt;/i&gt;
&lt;/blockquote&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;clauses

&lt;ul&gt;
&lt;li&gt;private(list)&lt;/li&gt;
&lt;li&gt;firstprivate(list)&lt;/li&gt;
&lt;li&gt;copyprivate(list)&lt;/li&gt;
&lt;li&gt;nowait&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Combined Parallel&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Synchronization用于线程同步

&lt;ul&gt;
&lt;li&gt;barrier

&lt;ul&gt;
&lt;li&gt;&lt;h1&gt;pragma omp barrier&lt;/h1&gt;&lt;/li&gt;
&lt;li&gt;这此处所有线程全部执行完，同步后继续执行&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Ordered

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;blockquote&gt;
    &lt;b&gt;#pragma&lt;/b&gt; &lt;b&gt;omp&lt;/b&gt; &lt;b&gt;ordered&lt;/b&gt;
         &lt;i&gt;structured block&lt;/i&gt;
&lt;/blockquote&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;指定接下來被程式，在被平行化的 for 迴圈將依序的執行。 Specifies that code under a parallelized for loop should be executed like a sequential loop.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;critical

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;blockquote&gt;
    &lt;b&gt;#pragma&lt;/b&gt; &lt;b&gt;omp&lt;/b&gt; &lt;b&gt;critical&lt;/b&gt; &lt;i&gt;&lt;code&gt;[&lt;/code&gt;(name)&lt;code&gt;]&lt;/code&gt; &lt;/i&gt;
         &lt;i&gt;structured block&lt;/i&gt;
&lt;/blockquote&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;block中的语句将通过锁机制来维护执行的单一性&lt;/li&gt;
&lt;li&gt;通过名字name来实现不同地方的锁机制&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;atomic

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;blockquote&gt;
    &lt;b&gt;#pragma&lt;/b&gt; &lt;b&gt;omp&lt;/b&gt; &lt;b&gt;atomic&lt;/b&gt;
        &lt;i&gt;statement&lt;/i&gt;
&lt;/blockquote&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;语句原子化执行&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;master

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;blockquote&gt;
    &lt;b&gt;#pragma&lt;/b&gt; &lt;b&gt;omp&lt;/b&gt; &lt;b&gt;master&lt;/b&gt;
        &lt;i&gt;structured block&lt;/i&gt;
&lt;/blockquote&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;只有主线程执行&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Clauses附加修饰和条款

&lt;ul&gt;
&lt;li&gt;shared(list)

&lt;ul&gt;
&lt;li&gt;利用这个有效区域的变量&lt;/li&gt;
&lt;li&gt;利用指针来达到效果&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;private(list)

&lt;ul&gt;
&lt;li&gt;在各自线程内部创建一个副本&lt;/li&gt;
&lt;li&gt;利用传值的效果&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;lastprivate(list)

&lt;ul&gt;
&lt;li&gt;按逻辑先后将最后一个被赋值的数据作为本数据域的结果&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;firstprivate(list)

&lt;ul&gt;
&lt;li&gt;用于初始化&lt;/li&gt;
&lt;li&gt;在各个线程中可能需要用到外面的初始数据&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;default(none|shared)

&lt;ul&gt;
&lt;li&gt;给下面所有的数据指定默认区间&lt;/li&gt;
&lt;li&gt;none:不指定，需要程序员逐个设置&lt;/li&gt;
&lt;li&gt;shared:默认都为shared(....)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;nowait

&lt;ul&gt;
&lt;li&gt;忽略 barrier（等待）。 Overrides the barrier implicit in a directive.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;schedule(kind&lt;code&gt;[&lt;/code&gt;,chunk_size&lt;code&gt;]&lt;/code&gt;)

&lt;ul&gt;
&lt;li&gt;kind

&lt;ul&gt;
&lt;li&gt;有 dynamic、guided、runtime、static 四種方法。&lt;/li&gt;
&lt;li&gt;各个线程的for迭代范围&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;設定 for 迴圈的平行化方法；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;if(scalar-logical-expression)&lt;/li&gt;
&lt;li&gt;num_threads(scalar-integer-expression)&lt;/li&gt;
&lt;li&gt;reduction(operator:list)

&lt;ul&gt;
&lt;li&gt;operator:initial ization value

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;*&lt;/code&gt;:0&lt;/li&gt;
&lt;li&gt;&lt;code&gt;*&lt;/code&gt;:1&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-&lt;/code&gt;:0&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;:&lt;code&gt;~&lt;/code&gt;0&lt;/li&gt;
&lt;li&gt;&lt;code&gt;|&lt;/code&gt;:0&lt;/li&gt;
&lt;li&gt;&lt;code&gt;^&lt;/code&gt;:0&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;:1&lt;/li&gt;
&lt;li&gt;&lt;code&gt;||&lt;/code&gt;:0&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;对于特殊类型还是得借助critical

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;blockquote&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;sum=0;
            #pragma omp parallel shared(n,a,sum) private(TID,sumLocal)
            {
                  TID = omp_get_thread_num();
                  sumLocal = 0;
                  #pragma omp for
                     for(i=0;i&lt;span class=&quot;ni&quot;&gt;&amp;amp;lt;&lt;/span&gt;n;i++)
                         sumLocal += a`[`i`]`;
                  #pragma omp critical (update_sum)
                  {
                        sum += sumLocal;
                        printf(&lt;span class=&quot;ni&quot;&gt;&amp;amp;quot;&lt;/span&gt;TID=%d: sumLocal=%d sum=%d\n&lt;span class=&quot;ni&quot;&gt;&amp;amp;quot;&lt;/span&gt;,TID,sumLocal,sum);
                  }
            }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;pre&gt;&lt;code&gt;  &amp;lt;/blockquote&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;学习资源&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://kheresy.wordpress.com/2006/06/09/%E7%B0%A1%E6%98%93%E7%9A%84%E7%A8%8B%E5%BC%8F%E5%B9%B3%E8%A1%8C%E5%8C%96%E6%96%B9%E6%B3%95%EF%BC%8Dopenmp%EF%BC%88%E4%B8%80%EF%BC%89%E7%B0%A1%E4%BB%8B/&quot;&gt;OpenMP简介与语法详细列表&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/me115/archive/2011/01/25/1944567.html&quot;&gt;OpenMp编程材料集合&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://cobweb.ecn.purdue.edu/ParaMount/iwomp2008/documents/chapman-underthehood&quot;&gt;OpenMP工作原理&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;tags: MultiCPU&lt;/h2&gt;
</content>
 </entry>
 
 <entry>
   <title>个人兴趣爱好</title>
   <link href="http://www.5wpc.info/it/living/interest/2011/07/15/index"/>
   <updated>2011-07-15T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/living/interest/2011/07/15/index</id>
   <content type="html">&lt;h1&gt;个人兴趣爱好&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;读书&lt;/li&gt;
&lt;li&gt;旅行&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/it/living/interest/2011/07/15/harmonica/&quot;&gt;口琴&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>口琴</title>
   <link href="http://www.5wpc.info/it/living/interest/2011/07/15/harmonica"/>
   <updated>2011-07-15T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/living/interest/2011/07/15/harmonica</id>
   <content type="html">&lt;h1&gt;主要布局&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;http://pic.yupoo.com/qianjigui/DNJfPnO4/62Usa.jpg&quot; alt=&quot;http://pic.yupoo.com/qianjigui/DNJfPnO4/62Usa.jpg&quot; /&gt;&lt;/p&gt;

&lt;h1&gt;口琴&lt;/h1&gt;

&lt;h2&gt;布鲁斯口琴&lt;/h2&gt;

&lt;h3&gt;蓝调口琴每天必做的练习&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;转载&lt;/em&gt;:
很多人反应不知道该做什么练习，我总结了下，大概如下。&lt;/p&gt;

&lt;p&gt;注意：以下内容只涵盖了布鲁斯口气的核心技巧和演奏方式。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt; 长音练习（5到10分钟）

&lt;ol&gt;
&lt;li&gt;这时候的重点放在思考你的气息是否正确，千万不要求快，一定要慢慢的，感觉气流流进流出的感觉，像水流一样。&lt;/li&gt;
&lt;li&gt;并且感觉到腹部的运动，从而让口腔和整个呼吸道放松下来。&lt;/li&gt;
&lt;li&gt;具体可参考这里:http://www.tenholes.com/index.php/lession/show/id/3&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt; 吐音练习（5到10分钟）

&lt;ol&gt;
&lt;li&gt;注意放松舌头，不要力度过大，只是舌尖的瞬间发力，要轻巧，开始不要求快，一定要求稳，能用一个均匀的速度放松的做出三连音和四连音。一开始可以是一拍一个音，然后一拍两个音，然后一拍三连音，然后一拍四连音。&lt;/li&gt;
&lt;li&gt;具体可以参考这里：http://www.tenholes.com/index.php/lession/show/id/10&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt; 压音练习（10到15分钟）

&lt;ol&gt;
&lt;li&gt;包括各种形态的压音方式，上滑音、下滑音、一次到位的压音，压音与正常音的组合等等，注意舌头位置和口腔形状的确定，感觉不同孔和同一孔不同压音时候舌头位置的不同。&lt;/li&gt;
&lt;li&gt;具体练习可以参考这里：http://www.tenholes.com/index.php/lession/show/id/73 和这里：http://www.tenholes.com/index.php/lession/show/id/25&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt; &lt;em&gt;注意&lt;/em&gt;：以上部分是基本技巧的练习，我给出的时间是一个普通进阶者所需的时间，练习的时间因人而异，如果你还没有掌握好压音肯定需要在压音上做更多时间的练习，如果你没有掌握好单音肯定要先学会吹奏单音，不要越过基本技巧的练习，那样会导致你没有更多的提高空间。&lt;/li&gt;
&lt;li&gt; 音阶练习（全部都练习的话四十分钟以上，每条不少于十分钟）不同的阶段需要掌握的音阶不同，大致如下:

&lt;ol&gt;
&lt;li&gt;第一把位的五声音阶，包括大调123561 和小调612356。可以参考这里: http://www.tenholes.com/index.php/lession/show/id/54&lt;/li&gt;
&lt;li&gt;第一把位的自然大调音阶  12345671，掌握好压音后可以做出三个八度的完整音阶，并且可以做一些相关的音阶模进练习，可以参考这里：http://www.tenholes.com/index.php/lession/show/id/24&lt;/li&gt;
&lt;li&gt;第二把位的混合利底亚音阶   1 2 3 4 5 6 b7 1 二把位上这个音阶快速奏出会有一种炫技的错觉哈哈。&lt;/li&gt;
&lt;li&gt;第二把位的大调五声音阶：123561 这是演奏二把位大调的一个很基本的音阶 注意第三孔吸气上23两个音通过压音做出的衔接效果，可以参考这里:  http://www.tenholes.com/index.php/lession/show/id/54&lt;/li&gt;
&lt;li&gt;第二把位的布鲁斯音阶  1 b3 4 b5 5 b7 1  这个是二把位最重要的一条音阶了，一定要对照二把位大调五声音阶来记忆，对照他们的不同和相同，对照他们的色彩变化。主要是3 音5音7音的降低和还原的对比，在演奏布鲁斯时候这三个音决定了你乐句的色彩。可以参考这里：http://www.tenholes.com/index.php/lession/show/id/54&lt;/li&gt;
&lt;li&gt;第三把位的旋律小调音阶：6 1 2 3 #4 #5 6，这是非常“小调”的一个小调音阶，第三把位演奏的最有意思的部分了。具体可以参考这里：http://www.tenholes.com/index.php/lession/show/id/62&lt;/li&gt;
&lt;li&gt;其他把位的练习，如果你上面的都掌握了，应该具备了在其他把位上面做出相关练习的能力。如果你觉得有点晕，就按照顺序慢慢来。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;注意&lt;/em&gt;:
这一部分是真正的跟音乐有关系的练习，你脑子一定要明白自己在做什么练习，练习的内容，每一个音的位置，每一个条音阶的色彩，对于没有全部掌握的同学，可以先练会了的，随着你掌握音阶的增多再慢慢增加新的音阶练习，需要强调的一点是：千万千万不要求快，要把重点放在稳的基础上，等你稳下来了，自然而然就会快起来了。音阶的练习十分重要，它可以让你感觉距离音乐越来越近，感觉自己越来越了解自己，如果不进行这部分练习而是直接演奏曲子，那么你充其量只是多学了几个曲子而已，而没有学会演奏音乐。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt; 练习曲子（练习时间酌情而定）:
包括了短句练习和练习曲子等，练习曲要根据自己在不同阶段所适应的难度而定，并且要结合第一部分的技巧练习和第二部分对应的音阶练习。注意：演奏乐器的目标不是演奏多少个曲子，而是如何能更快更好的上手演奏一类的曲子。&lt;/li&gt;
&lt;li&gt; 关于扒曲子和即兴演奏

&lt;ol&gt;
&lt;li&gt;扒曲子。这是提高演奏能力的一个有效的途径，开始时你可能觉得很难，可以先扒一些简单的，把谱子记录下来，然后逐渐加大难度，关于扒曲子我会在日后的课程里给出详细的介绍。&lt;/li&gt;
&lt;li&gt;即兴演奏。开始可以不需要掌握太多的理论知识，用你已经掌握了的音阶跟着伴奏或者任何一个大师的作品一起演奏，要感觉自己就是录音当中乐队的一员，你会发现有些音和乐句自己做的很好，而有些做的不好，记住你做的好的那些并且分析他们好的原因。关于即兴演奏的基本讲解可以参考这里：http://www.tenholes.com/index.php/lession/show/id/69&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;最后我将上述的六个方面做一个大的分类:
  1. 第一部分是基本技巧的掌握：一、长音。 二、吐音。 三、压音。
  1. 第二部分是有关音阶的：四、音阶练习
  1. 第三部分是关于曲子的：五、练习曲
  1. 第四部分是关于即兴的：六、扒曲子与即兴演奏&lt;/p&gt;

&lt;p&gt;注意:
  1. 以上的内容最好保持每天定时的练习，不要今天只练技巧明天只练曲子之类的。
  1. 当你有一些技巧还没有掌握时（比如压音），可以先做每一部分你已经掌握的练习，但是四个部分的概念要有。
  1. 以上内容只是针对蓝调口琴最基本的一些技巧和演奏方式，诸如超吹和舌堵等技巧，还有其他把位的音阶等没有给出，如果你练上面的基本的东西还没有练好就去做其他方面的练习那样只会是自己迷惑，如果你把上面的基本内容练习好了，其他的技巧好把位对你来所也将迎刃而解。
  1. 记住，我们的目标是演奏音乐，而不是演奏某些孔吸气或者吹气。&lt;/p&gt;

&lt;h3&gt;曲谱练习&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://www.kouqin001.com/a/lishi/2010-08/292264&quot;&gt;布鲁斯口琴BD谱小结&lt;/a&gt;:
  * 黑名单上的人
  * 晓之车简谱
  * 童话
  * 一帘幽梦
  * 让我荡起双桨
  * 红豆
  * 蒲公英的约定
  * 菊花台
  * AIMO
  * 不能说的秘密
  * 千与千寻
  * 巴蒂格林 的 威廉退尔序曲
  * 世界的约束&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>高性能计算</title>
   <link href="http://www.5wpc.info/it/technical/multicores/2011/07/11/HPC"/>
   <updated>2011-07-11T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/technical/multicores/2011/07/11/HPC</id>
   <content type="html">&lt;h1&gt;高性能计算&lt;/h1&gt;

&lt;h2&gt;番外篇&lt;/h2&gt;

&lt;p&gt;我的研究生毕业设计的方向是利用大规模计算平台做分布式高性能计算，这也是我的第一次接触大型机、第一次做科学计算类应用的开发。&lt;/p&gt;

&lt;h2&gt;大视野&lt;/h2&gt;

&lt;p&gt;做高性能计算，需要结合指定的业务领域、利用现有的计算资源做定向开发。
由于业务环境、硬件环境的要求，在做这方面的开发时需要考虑好框架和工具。&lt;/p&gt;

&lt;h2&gt;工具&lt;/h2&gt;

&lt;p&gt;目前主流的、用于并行计算的开源框架有：OpenMPI、OpenMP等相关联产品。
另外可以考虑选用线程模型来做局部的并行处理。&lt;/p&gt;

&lt;h3&gt;多线程模型&lt;/h3&gt;

&lt;h4&gt;入门阅读&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/frozen_fish/article/details/1679491&quot;&gt;手把手教你Linux下的多线程设计－－Linux下多线程编程详解(一) &lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://hi.baidu.com/ivy_jing/blog/item/abe56f123ecab414213f2e1c.html&quot;&gt;类成员函数作pthread_create的函数参数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://hi.baidu.com/jiaju111/blog/item/f896ba2a1049e43f5343c180.html&quot;&gt;Linux多线程模型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.searchtb.com/2011/01/pthreads-mutex-vs-pthread-spinlock.html&quot;&gt;Pthread互斥量与自旋锁的比较&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/motadou/archive/2010/02/13/1668075.html&quot;&gt;Pthread条件变量的调用关系&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;感觉问题的关键是了解专用API，在毕业设计时苦于向Erlang的迁移而发现了Erlang自带的线程API，觉得还是值得尝试的。
  * Fork/Join模型
  * thread_create(...) 创建
  * thread_exit(...) 手动线程退出，返回相关结果
  * thread_join() 阻塞挂起，等待依赖线程退出
  * 利用互斥、信号量做调度
  * 在老API的基础上，参数是类成员函数建议使用static方法&lt;/p&gt;

&lt;h4&gt;同步&lt;/h4&gt;

&lt;p&gt;Futex原语&lt;/p&gt;

&lt;p&gt;http://randu.org/tutorials/threads/&lt;/p&gt;

&lt;h3&gt;OpenMP&lt;/h3&gt;

&lt;p&gt;当我们正在自己组建具有一定通用效果的多线程模型时，已经有了专业的工具帮助我们做并行化处理。这就是&lt;a href=&quot;/it/technical/multicores/2011/07/21/OpenMP/&quot;&gt;OpenMP&lt;/a&gt;.&lt;/p&gt;

&lt;h3&gt;OpenMPI&lt;/h3&gt;

&lt;p&gt;利用多线程进行分布式运算的推荐框架&lt;a href=&quot;/it/technical/multicores/2011/02/26/OpenMPI/&quot;&gt;OpenMPI&lt;/a&gt;.&lt;/p&gt;

&lt;h2&gt;总结与教训&lt;/h2&gt;

&lt;h3&gt;Erlang的选用与问题&lt;/h3&gt;

&lt;p&gt;当时选用Erlang做数值计算是比较主观的，
一方面刚好这个时候开始学习Erlang语言、并用其做了些小的应用程序，发现其的内建并行机制与消息传递特性非常方便，也想用到这个领域；
另一方面也是受到这篇 &lt;a href=&quot;http://www.google.com/url?sa=t&amp;amp;source=web&amp;amp;cd=1&amp;amp;ved=0CBcQFjAA&amp;amp;url=http%3A%2F%2Fwww.erlang.org%2Fworkshop%2F2008%2FSess23.pdf&amp;amp;rct=j&amp;amp;q=High-performance%20technical%20computing%20with%20erlang&amp;amp;ei=0j8bTpybIYPQhAecwIDNBQ&amp;amp;usg=AFQjCNFT9Fh4Lp0QHtWcdCnyHnS3PNpOXw&amp;amp;sig2=vLBrA-MRZxo_PIUrUNHGfg&amp;amp;cad=rja&quot;&gt;讨论文献&lt;/a&gt;的影响。&lt;/p&gt;

&lt;p&gt;在真实使用中发现有如下问题:
  * 数值计算所依赖的数据&lt;em&gt;多&lt;/em&gt;、初期接口数据结构设计不好，就容易导致函数参数过多过长。
  * 涉及大规模数据复制、传递、拷贝等问题时，由于Erlang的特性(做复制拷贝)，速度很慢。可以通过 &lt;em&gt;hipe_bifs&lt;/em&gt; 库临时解决。
  * 通过C扩展完成计算逻辑，这个尝试成功了。但是业务逻辑、语言间交互接口及编码复杂、繁琐，得不偿失。
  * 如果在已经模块划分好的计算逻辑上做修改，由于Erlang的NIF、Driver、Port等接口的限制，很难只利用Erlang的消息传递、进程管理模块。&lt;/p&gt;

&lt;p&gt;如果结合协议业务的编程思路，可以硬性规定数值计算数据摆放格式，通过强制类型转换等手法做到简化接口，整合NIF扩展的问题。不过改动复杂，一旦数据集发生变化都需要大范围更改。&lt;/p&gt;

&lt;p&gt;其Driver PThread的实现多半是基于PThread的底层Library，在利用NIF做pthread构建时可以很好地连接C扩展与Erlang。&lt;/p&gt;

&lt;p&gt;附:
  * &lt;a href=&quot;http://www.mikespook.com/2010/02/%E6%89%AF%E6%B7%A1-erlang-%E7%9A%84%E2%80%9C%E9%80%82%E5%90%88%E2%80%9D%E5%92%8C%E2%80%9C%E4%B8%8D%E9%80%82%E5%90%88%E2%80%9D/&quot;&gt;扯淡-erlang-的“适合”和“不适合”&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;环境&lt;/h2&gt;

&lt;h3&gt;硬件&lt;/h3&gt;

&lt;p&gt;这些计算环境一般都是由多个节点组成，节点内部可能有一个到多个CPU提供计算资源。
节点间通过虚拟化设备共享硬盘，通过专用线路相互连接。&lt;/p&gt;

&lt;p&gt;在这其中，我们需要考虑多层不同的连接方式与主要瓶颈、节点的通信与交互、组成的基本体系结构。
譬如节点内CPU连接方式，节点间网络连接方式:
  1. &lt;a href=&quot;http://www.360doc.com/content/10/1213/19/158286_77795484.shtml&quot;&gt;Intel CPU互联方案初探&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;软件&lt;/h3&gt;

&lt;p&gt;主要是管理类软件。&lt;/p&gt;

&lt;h4&gt;QSub&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;http://www.clusterresources.com/torquedocs/commands/qsub.shtml&quot;&gt;qsub命令介绍&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Erlang</title>
   <link href="http://www.5wpc.info/it/technical/language/erlang/2011/03/31/Syntax"/>
   <updated>2011-03-31T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/technical/language/erlang/2011/03/31/Syntax</id>
   <content type="html">&lt;h1&gt;Erlang&lt;/h1&gt;

&lt;h2&gt;串行编程&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;常量

&lt;ul&gt;
&lt;li&gt;数值

&lt;ul&gt;
&lt;li&gt;Integer&lt;/li&gt;
&lt;li&gt;Float&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Atom&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;复合

&lt;ul&gt;
&lt;li&gt;tuple&lt;/li&gt;
&lt;li&gt;List&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;保护式

&lt;ul&gt;
&lt;li&gt;子句

&lt;ul&gt;
&lt;li&gt;fun() when ...&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;断言

&lt;ul&gt;
&lt;li&gt;atom(X) X 是一个原子式&lt;/li&gt;
&lt;li&gt;constant(X) X 不是列表或元组&lt;/li&gt;
&lt;li&gt;float(X) X 是一个浮点数&lt;/li&gt;
&lt;li&gt;integer(X) X 是一个整数&lt;/li&gt;
&lt;li&gt;list(X) X 是一个列表或 []&lt;/li&gt;
&lt;li&gt;number(X) X 是一个整数或浮点数&lt;/li&gt;
&lt;li&gt;pid(X) X 是一个进程标识符&lt;/li&gt;
&lt;li&gt;port(X) X 是一个端口&lt;/li&gt;
&lt;li&gt;reference(X) X 是一个引用&lt;/li&gt;
&lt;li&gt;tuple(X) X 是一个元组&lt;/li&gt;
&lt;li&gt;binary(X) X 是一段二进制数据&lt;/li&gt;
&lt;li&gt;element/2, float/1, hd/1, length/1, round/1, self/0, size/1 trunc/1, tl/1, abs/1, node/1, node/0, nodes/0&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;比较

&lt;ul&gt;
&lt;li&gt;X &gt; Y     X 大于 Y         coerce&lt;/li&gt;
&lt;li&gt;X &amp;lt; Y     X 小于 Y         coerce&lt;/li&gt;
&lt;li&gt;X =&amp;lt; Y    X 小于或等于 Y   coerce&lt;/li&gt;
&lt;li&gt;X &gt;= Y    X 大于或等于 Y   coerce&lt;/li&gt;
&lt;li&gt;X == Y    X 等于 Y         coerce&lt;/li&gt;
&lt;li&gt;X /= Y    X 不等于 Y       coerce&lt;/li&gt;
&lt;li&gt;X =:= Y   X 等于 Y         exact&lt;/li&gt;
&lt;li&gt;X =/= Y   X 不等于 Y       exact&lt;/li&gt;
&lt;li&gt;number &amp;lt; atom &amp;lt; reference &amp;lt; port &amp;lt; pid &amp;lt; tuple &amp;lt; list&lt;/li&gt;
&lt;li&gt;元组首先按大小排序,然后再按元素排序。列表的比较顺序是先头部,后尾部。&lt;/li&gt;
&lt;li&gt;如果比较运算符的两个参数都是数值类型且运算符为coerce型,则如果一个参数是 integer 另一个是 float , 那么 integer 将被转换为 float 再进行比较。&lt;/li&gt;
&lt;li&gt;exact 类型的运算符则不做这样的转换。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;原语

&lt;ul&gt;
&lt;li&gt;case

&lt;ul&gt;
&lt;li&gt;case Expr of&lt;/li&gt;
&lt;li&gt;Pattern1 [when Guard1] -&gt; Seq1;&lt;/li&gt;
&lt;li&gt;Pattern2 [when Guard2] -&gt; Seq2;&lt;/li&gt;
&lt;li&gt;...&lt;/li&gt;
&lt;li&gt;PatternN [when GuardN] -&gt; SeqN&lt;/li&gt;
&lt;li&gt;_ -&gt; ...&lt;/li&gt;
&lt;li&gt;end&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;If

&lt;ul&gt;
&lt;li&gt;if&lt;/li&gt;
&lt;li&gt;Guard1 -&gt;&lt;/li&gt;
&lt;li&gt;Sequence1 ;&lt;/li&gt;
&lt;li&gt;Guard2 -&gt;&lt;/li&gt;
&lt;li&gt;Sequence2 ;&lt;/li&gt;
&lt;li&gt;...&lt;/li&gt;
&lt;li&gt;true -&gt; ...&lt;/li&gt;
&lt;li&gt;end&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;算术表达式

&lt;ul&gt;
&lt;li&gt;:&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;em&gt;运算符&lt;/em&gt;   &lt;/th&gt;
&lt;th&gt;   &lt;em&gt;描述&lt;/em&gt;               &lt;/th&gt;
&lt;th&gt;  &lt;em&gt;类型&lt;/em&gt;  &lt;/th&gt;
&lt;th&gt;  &lt;em&gt;操作数类型&lt;/em&gt; &lt;/th&gt;
&lt;th&gt; &lt;em&gt;优先&lt;/em&gt; &lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;+ X        &lt;/td&gt;
&lt;td&gt;   + X                  &lt;/td&gt;
&lt;td&gt;  单目    &lt;/td&gt;
&lt;td&gt;   混合        &lt;/td&gt;
&lt;td&gt; 1      &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;- X        &lt;/td&gt;
&lt;td&gt;   - X                  &lt;/td&gt;
&lt;td&gt;  单目    &lt;/td&gt;
&lt;td&gt;   混合        &lt;/td&gt;
&lt;td&gt; 1      &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;X * Y      &lt;/td&gt;
&lt;td&gt;   X * Y                &lt;/td&gt;
&lt;td&gt;  双目    &lt;/td&gt;
&lt;td&gt;   混合        &lt;/td&gt;
&lt;td&gt; 2      &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;X / Y      &lt;/td&gt;
&lt;td&gt;   X / Y (浮点除法)     &lt;/td&gt;
&lt;td&gt;  双目    &lt;/td&gt;
&lt;td&gt;   混合        &lt;/td&gt;
&lt;td&gt; 2      &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;X div Y    &lt;/td&gt;
&lt;td&gt;   X 整除 Y             &lt;/td&gt;
&lt;td&gt;  双目    &lt;/td&gt;
&lt;td&gt;   整数        &lt;/td&gt;
&lt;td&gt; 2      &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;X rem Y    &lt;/td&gt;
&lt;td&gt;   X 除以 Y 的余数      &lt;/td&gt;
&lt;td&gt;  双目    &lt;/td&gt;
&lt;td&gt;   整数        &lt;/td&gt;
&lt;td&gt; 2      &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;X band Y   &lt;/td&gt;
&lt;td&gt;   X 与 Y 的位与        &lt;/td&gt;
&lt;td&gt;  双目    &lt;/td&gt;
&lt;td&gt;   整数        &lt;/td&gt;
&lt;td&gt; 2      &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;X + Y      &lt;/td&gt;
&lt;td&gt;   X + Y                &lt;/td&gt;
&lt;td&gt;  双目    &lt;/td&gt;
&lt;td&gt;   混合        &lt;/td&gt;
&lt;td&gt; 3      &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;X - Y      &lt;/td&gt;
&lt;td&gt;   X - Y                &lt;/td&gt;
&lt;td&gt;  双目    &lt;/td&gt;
&lt;td&gt;   混合        &lt;/td&gt;
&lt;td&gt; 3      &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;X bor Y    &lt;/td&gt;
&lt;td&gt;   X 与 Y 位或          &lt;/td&gt;
&lt;td&gt;  双目    &lt;/td&gt;
&lt;td&gt;   整数        &lt;/td&gt;
&lt;td&gt; 3      &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;X bxor Y   &lt;/td&gt;
&lt;td&gt;   X 与 Y 的位算数异或  &lt;/td&gt;
&lt;td&gt;  双目    &lt;/td&gt;
&lt;td&gt;   整数        &lt;/td&gt;
&lt;td&gt; 3      &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;X bsl N    &lt;/td&gt;
&lt;td&gt;   X 算数左移 N 位      &lt;/td&gt;
&lt;td&gt;  双目    &lt;/td&gt;
&lt;td&gt;   整数        &lt;/td&gt;
&lt;td&gt; 3      &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;X bsr N    &lt;/td&gt;
&lt;td&gt;   X 右移 N 位          &lt;/td&gt;
&lt;td&gt;  双目    &lt;/td&gt;
&lt;td&gt;   整数        &lt;/td&gt;
&lt;td&gt; 3      &lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;


&lt;h2&gt;列表编程&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;BIF

&lt;ul&gt;
&lt;li&gt;:&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;em&gt;函数原型&lt;/em&gt;            &lt;/th&gt;
&lt;th&gt;  &lt;em&gt;作用&lt;/em&gt;                             &lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;atom_to_list(A)       &lt;/td&gt;
&lt;td&gt;  将原子式 A 转换为一个ASCII字符列表 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;float_to_list(F)      &lt;/td&gt;
&lt;td&gt; 将浮点数 F 转换为一个ASCII字符列表  &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;integer_to_list(I)    &lt;/td&gt;
&lt;td&gt; 将整数 I 转换为一个ASCII字符列表    &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;list_to_atom(L)       &lt;/td&gt;
&lt;td&gt; 将ASCII字符列表 L 转换为一个原子式  &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;list_to_float(L)      &lt;/td&gt;
&lt;td&gt; 将ASCII字符列表 L 转换为一个浮点数  &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;list_to_integer(L)    &lt;/td&gt;
&lt;td&gt; 将ASCII字符列表 L 转换为一个整数    &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;hd(L)                 &lt;/td&gt;
&lt;td&gt; 返回列表 L 的第一个元素             &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;tl(L)                 &lt;/td&gt;
&lt;td&gt; 返回列表 L 的尾部                   &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;length(L)             &lt;/td&gt;
&lt;td&gt; 返回列表 L 的长度                   &lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

</content>
 </entry>
 
 <entry>
   <title>LeaderInProductManager</title>
   <link href="http://www.5wpc.info/it/career/manage/2011/03/06/LeaderInProductManager"/>
   <updated>2011-03-06T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/career/manage/2011/03/06/LeaderInProductManager</id>
   <content type="html">&lt;h1&gt;LeaderInProductManager&lt;/h1&gt;

&lt;h2&gt;产品团队&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;将员工个人能力成长与团队业绩发展紧密结合

&lt;ul&gt;
&lt;li&gt;提高员工的核心竞争力，提高抗风险能力&lt;/li&gt;
&lt;li&gt;磨刀不误砍柴工；员工能力成长，可提高效率，保障业绩；&lt;/li&gt;
&lt;li&gt;真正地做到“以人为本”。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;建立与强化团队的文化氛围，价值观&lt;/li&gt;
&lt;li&gt;结果导向，强化实践中培养能力，在水里学会游泳

&lt;ul&gt;
&lt;li&gt;合理的授权，也做好整体的监控&lt;/li&gt;
&lt;li&gt;保证结果风险可控，不至于造成巨大损失&lt;/li&gt;
&lt;li&gt;一旦真的出了问题，Leader也要做好承担责任的准备&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;为员工的能力成长，允许失败，可付出一些尝试成本和代价&lt;/li&gt;
&lt;li&gt;以身作则，对自己高要求，对下属多宽容

&lt;ul&gt;
&lt;li&gt;告诫自己要不断的学习和提高，要有比较高的追求&lt;/li&gt;
&lt;li&gt;严以律己的同时，还要避免给下属造成很大压力&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;严以律己的同时，还要避免给下属造成很大压力

&lt;ul&gt;
&lt;li&gt;当一个团队可以按各自角色分工自我运转时， Leader就可以从团队的圈子中跳离出来，精力集中在外部事务上，协调外部资源来满足团队更大的发展；&lt;/li&gt;
&lt;li&gt;文档化， 文档保证交流与传承；我们每个产品文档都要不断地优化与专业&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;发现与培养人才，加强梯队建设&lt;/li&gt;
&lt;li&gt;强化有效沟通，鼓励向上沟通&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;Products&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;http://www.alibuybuy.com/posts/81537.html

&lt;ul&gt;
&lt;li&gt;如何做一款成功的应用

&lt;ul&gt;
&lt;li&gt;产品概念

&lt;ul&gt;
&lt;li&gt;寻找空白点&lt;/li&gt;
&lt;li&gt;收入问题

&lt;ul&gt;
&lt;li&gt;http://www.alibuybuy.com/posts/79834.html

&lt;ul&gt;
&lt;li&gt;向游戏靠拢&lt;/li&gt;
&lt;li&gt;国际化：哪儿有钱去哪儿&lt;/li&gt;
&lt;li&gt;为其它应用带去下载量&lt;/li&gt;
&lt;li&gt;采用免费增值商业模式&lt;/li&gt;
&lt;li&gt;版权输出和相关商品开发&lt;/li&gt;
&lt;li&gt;奔向企业市场&lt;/li&gt;
&lt;li&gt;把广告也变成一种娱乐&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;关于中国老年消费者你需要了解的五件事

&lt;ul&gt;
&lt;li&gt;http://www.alibuybuy.com/posts/79629.html&lt;/li&gt;
&lt;li&gt;老年消费者不容忽视&lt;/li&gt;
&lt;li&gt;安全、熟悉、宁静&lt;/li&gt;
&lt;li&gt;贴合需求&lt;/li&gt;
&lt;li&gt;保持健康、活力和心情愉快&lt;/li&gt;
&lt;li&gt;庆祝老年时光&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;做出价值声明&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;设计

&lt;ul&gt;
&lt;li&gt;别让我思考&lt;/li&gt;
&lt;li&gt;返璞归真&lt;/li&gt;
&lt;li&gt;考量UI规范&lt;/li&gt;
&lt;li&gt;像人类一样思考&lt;/li&gt;
&lt;li&gt;别让我做事&lt;/li&gt;
&lt;li&gt;进行可用性测试&lt;/li&gt;
&lt;li&gt;富有情感化

&lt;ul&gt;
&lt;li&gt;视觉效果&lt;/li&gt;
&lt;li&gt;音效&lt;/li&gt;
&lt;li&gt;触控的魔力&lt;/li&gt;
&lt;li&gt;文案中的人情味儿&lt;/li&gt;
&lt;li&gt;出众的动画&lt;/li&gt;
&lt;li&gt;不要忽视图标&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;开发编程

&lt;ul&gt;
&lt;li&gt;本地化开发&lt;/li&gt;
&lt;li&gt;代码质量&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;市场营销

&lt;ul&gt;
&lt;li&gt;提早开始&lt;/li&gt;
&lt;li&gt;结交朋友&lt;/li&gt;
&lt;li&gt;宣传造势&lt;/li&gt;
&lt;li&gt;获得推荐&lt;/li&gt;
&lt;li&gt;媒体的力量&lt;/li&gt;
&lt;li&gt;建立用户群&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;Tobe&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;刻意练习

&lt;ul&gt;
&lt;li&gt;http://hi.baidu.com/inetpm/item/93116a18966d2b8e89a956ef&lt;/li&gt;
&lt;li&gt;你需要重新思考自己的价值观和幸福观:本质就是这种对自身的关注和提高自身技能的要求&lt;/li&gt;
&lt;li&gt;你需要主动为自己找一位&quot;师傅&quot;:要持续地做自己做不好的事，精确的在&quot;学习区&quot;内进行，要求高度的针对性&lt;/li&gt;
&lt;li&gt;充分利用网络和开源的力量&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;解读数据？解读“人”！

&lt;ul&gt;
&lt;li&gt;在用户没有表达任何观点，或，还不清楚用户的观点之前，不要有任何想法。&lt;/li&gt;
&lt;li&gt;拿着用户的文字反馈，尝试读懂这个&quot;人&quot;，而不是这些&quot;字&quot;。&lt;/li&gt;
&lt;li&gt;倾听着用户的话语，与其跟他说话，不如听懂他的话。&lt;/li&gt;
&lt;li&gt;与其单独看每个数字，不如串起来读下去，完整地读出一个&quot;人&quot;。&lt;/li&gt;
&lt;li&gt;http://www.alibuybuy.com/posts/78073.html&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;http://www.alibuybuy.com/posts/79010.html

&lt;ul&gt;
&lt;li&gt;心里要有 Ownership，就是要用心。&lt;/li&gt;
&lt;li&gt;将心比心，学会从用户角度看问题。&lt;/li&gt;
&lt;li&gt;处处留心，寻找改善用户体验的机会。&lt;/li&gt;
&lt;li&gt;脸皮厚，不怕骂，没心没肺。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;tags: Leader PD&lt;/h2&gt;
</content>
 </entry>
 
 <entry>
   <title>OpenMPI</title>
   <link href="http://www.5wpc.info/it/technical/multicores/2011/02/26/OpenMPI"/>
   <updated>2011-02-26T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/technical/multicores/2011/02/26/OpenMPI</id>
   <content type="html">&lt;h1&gt;OpenMPI&lt;/h1&gt;

&lt;h2&gt;Concept基本概念&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;单元Unit

&lt;ul&gt;
&lt;li&gt;Process进程(MPI 程序中一个独立参与通信的个体)

&lt;ul&gt;
&lt;li&gt;Communicator&lt;/li&gt;
&lt;li&gt;Rank&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Process Group进程组(一个 MPI 程序中由部分或全部进程构成的一个有序集合)&lt;/li&gt;
&lt;li&gt;Rank 进程号(用于在该组中标识该进程 )

&lt;ul&gt;
&lt;li&gt;MPI_PROC_NULL&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;通信器Communicator

&lt;ul&gt;
&lt;li&gt;域内通信器 (intra-communicator)&lt;/li&gt;
&lt;li&gt;域间通信器 (inter-communicator)&lt;/li&gt;
&lt;li&gt;Property

&lt;ul&gt;
&lt;li&gt;MPI_COMM_WORLD&lt;/li&gt;
&lt;li&gt;MPI_COMM_SELF&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Communication通信

&lt;ul&gt;
&lt;li&gt;Message&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;Structure 基本结构&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;引入头文件&lt;code&gt;#include &quot;mpi.h&quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;int myrank, nprocs;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;初始化，必须首先调用&lt;code&gt;MPI_Init(&amp;amp;argc, &amp;amp;argv);&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;获取指定通信器中进程的数目&lt;code&gt;MPI_Comm_size(MPI_COMM_WORLD, &amp;amp;nprocs);&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;获取在指定通信器中的进程号&lt;code&gt;MPI_Comm_rank(MPI_COMM_WORLD, &amp;amp;myrank);&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;退出MPI系统&lt;code&gt;MPI_Finalize();&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;环境信息&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;MPI_Get_processor_name(processor_name,&amp;amp;namelen); 处理器名称&lt;/li&gt;
&lt;li&gt;  char processor_name[MPI_MAX_PROCESSOR_NAME];&lt;/li&gt;
&lt;li&gt;int namelen;&lt;/li&gt;
&lt;li&gt;startwtime = MPI_Wtime(); 获取墙上时间

&lt;ul&gt;
&lt;li&gt;double startwtime;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;Datatype 原始数据类型(MPI 系统中数据的发送与接收操作都必须指定数据类型 )&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;MPI_INT&lt;/li&gt;
&lt;li&gt;MPI_FLOAT&lt;/li&gt;
&lt;li&gt;MPI_DOUBLE&lt;/li&gt;
&lt;li&gt;MPI_SHORT&lt;/li&gt;
&lt;li&gt;MPI_LONG&lt;/li&gt;
&lt;li&gt;MPI_CHAR&lt;/li&gt;
&lt;li&gt;MPI_UNSIGNED_CHAR&lt;/li&gt;
&lt;li&gt;MPI_UNSIGNED_SHORT&lt;/li&gt;
&lt;li&gt;MPI_UNSIGNED&lt;/li&gt;
&lt;li&gt;MPI_UNSIGNED_LONG&lt;/li&gt;
&lt;li&gt;MPI_LONG_DOUBLE&lt;/li&gt;
&lt;li&gt;MPI_BYTE&lt;/li&gt;
&lt;li&gt;MPI_PACKED&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;Communication通信&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;P2P点对点

&lt;ul&gt;
&lt;li&gt;blocking阻塞

&lt;ul&gt;
&lt;li&gt;MPI_Send&lt;/li&gt;
&lt;li&gt;MPI_Recv&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;non-blocking非阻塞

&lt;ul&gt;
&lt;li&gt;MPI_Isend&lt;/li&gt;
&lt;li&gt;MPI_Irecv&lt;/li&gt;
&lt;li&gt;Check Status

&lt;ul&gt;
&lt;li&gt;MPI_Wait&lt;/li&gt;
&lt;li&gt;MPI_Test&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Mode模式

&lt;ul&gt;
&lt;li&gt;Standard标准

&lt;ul&gt;
&lt;li&gt;MPI_Send&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;buffered缓存

&lt;ul&gt;
&lt;li&gt;MPI_Bsend&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;synchronous 同步

&lt;ul&gt;
&lt;li&gt;MPI_Ssend&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ready 就绪

&lt;ul&gt;
&lt;li&gt;MPI_Rsend&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;聚合通信与同步

&lt;ul&gt;
&lt;li&gt;障碍同步(MPI_Barrier)

&lt;ul&gt;
&lt;li&gt;障碍同步函数 MPI_Barrier 用于一个通信器中所有进程的同步。调用该函数时进程将处于等待状态,直到通信器中所有进程都调用了该函数后才继续执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;广播(MPI_Bcast)

&lt;ul&gt;
&lt;li&gt;一个进程 (称为根进程) 同时发送同样的消息给通信器中的所有其他进程。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;数据收集(MPI_Gather)&lt;/li&gt;
&lt;li&gt;数据散发(MPI_Scatter)&lt;/li&gt;
&lt;li&gt;数据转置(MPI_Alltoall)&lt;/li&gt;
&lt;li&gt;归约(MPI_Reduce)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;tags: MultiCPU&lt;/h2&gt;
</content>
 </entry>
 
 <entry>
   <title>NS-2</title>
   <link href="http://www.5wpc.info/it/study/dcu/2011/02/26/NS2"/>
   <updated>2011-02-26T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/study/dcu/2011/02/26/NS2</id>
   <content type="html">&lt;h1&gt;NS-2&lt;/h1&gt;

&lt;h2&gt;Install&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;http://ns2onubuntu.blogspot.com/2009/11/easiest-way-to-install-ns2-on-ubuntu.html&lt;/li&gt;
&lt;li&gt;Ubuntu 10.04

&lt;ul&gt;
&lt;li&gt;sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys B3F3334F&lt;/li&gt;
&lt;li&gt;Add debs to /etc/apt/sources.list

&lt;ul&gt;
&lt;li&gt;deb http://ppa.launchpad.net/wouterh/ppa/ubuntu lucid main&lt;/li&gt;
&lt;li&gt;deb-src http://ppa.launchpad.net/wouterh/ppa/ubuntu lucid main&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;sudo apt-get update&lt;/li&gt;
&lt;li&gt;sudo apt-get install ns nam xgraph&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;Examples&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;http://nile.wpi.edu/NS/&lt;/li&gt;
&lt;li&gt;http://blogold.chinaunix.net/u3/105477/article_124320_1.html&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;Models&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Traffic and Application

&lt;ul&gt;
&lt;li&gt;Web&lt;/li&gt;
&lt;li&gt;FTP&lt;/li&gt;
&lt;li&gt;Telnet&lt;/li&gt;
&lt;li&gt;Constant-bit Rate&lt;/li&gt;
&lt;li&gt;Real Audio&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Transport Protocol

&lt;ul&gt;
&lt;li&gt;unicast

&lt;ul&gt;
&lt;li&gt;TCP&lt;/li&gt;
&lt;li&gt;UDP&lt;/li&gt;
&lt;li&gt;RTP&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;multicast

&lt;ul&gt;
&lt;li&gt;SRM&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Routing and queueing

&lt;ul&gt;
&lt;li&gt;Routing

&lt;ul&gt;
&lt;li&gt;Wired routing&lt;/li&gt;
&lt;li&gt;ad hoc routing&lt;/li&gt;
&lt;li&gt;directed diffusion&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Queueing protocol

&lt;ul&gt;
&lt;li&gt;drop-tail&lt;/li&gt;
&lt;li&gt;RED&lt;/li&gt;
&lt;li&gt;fair queueing&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Physical media

&lt;ul&gt;
&lt;li&gt;Wired&lt;/li&gt;
&lt;li&gt;Wireless&lt;/li&gt;
&lt;li&gt;satellites&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;http://nile.wpi.edu/NS/Figure/fig6.gif&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;Extension&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;采用直接编译装载

&lt;ul&gt;
&lt;li&gt;依赖源文件&lt;/li&gt;
&lt;li&gt;重新生成软件包&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;tags: Network NS2&lt;/h2&gt;
</content>
 </entry>
 
 <entry>
   <title>Ruby 编程技巧--265式</title>
   <link href="http://www.5wpc.info/it/technical/language/ruby/2011/02/19/ruby265methods"/>
   <updated>2011-02-19T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/technical/language/ruby/2011/02/19/ruby265methods</id>
   <content type="html">&lt;h1&gt;Ruby 265式&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;第1章 Ruby的语法.

&lt;ol&gt;
&lt;li&gt;001 常值（literal） 2&lt;/li&gt;
&lt;li&gt;002 运算符 6&lt;/li&gt;
&lt;li&gt;003 变量与常数 9&lt;/li&gt;
&lt;li&gt;004 代入 11&lt;/li&gt;
&lt;li&gt;005 程序语句的分段 12&lt;/li&gt;
&lt;li&gt;006 备注 13&lt;/li&gt;
&lt;li&gt;007 真假值与条件判断 14&lt;/li&gt;
&lt;li&gt;008 循环 17&lt;/li&gt;
&lt;li&gt;009 调用方法 19&lt;/li&gt;
&lt;li&gt;010 区块（block） 20&lt;/li&gt;
&lt;li&gt;011 方法（Method）定义 21&lt;/li&gt;
&lt;li&gt;012 限制方法的调用 22&lt;/li&gt;
&lt;li&gt;013 类别（Class）定义 23&lt;/li&gt;
&lt;li&gt;014 模块（Module）定义 24&lt;/li&gt;
&lt;li&gt;015 特殊方法 25&lt;/li&gt;
&lt;li&gt;016 例外处理 26&lt;/li&gt;
&lt;li&gt;017 alias与undef 27&lt;/li&gt;
&lt;li&gt;018 保留字 28&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;第2章 字符串

&lt;ol&gt;
&lt;li&gt;019 选择适当的字符串常值 30&lt;/li&gt;
&lt;li&gt;020 设置默认的文字编码 32&lt;/li&gt;
&lt;li&gt;021 变换文字编码 34&lt;/li&gt;
&lt;li&gt;022 推测文字编码 37&lt;/li&gt;
&lt;li&gt;023 复制字符串 39&lt;/li&gt;
&lt;li&gt;024 重复字符串 40&lt;/li&gt;
&lt;li&gt;025 取得字符串长度 41&lt;/li&gt;
&lt;li&gt;026 查找字符串 42&lt;/li&gt;
&lt;li&gt;027 查询正则表达式是否匹配字符串的开头/结尾 45&lt;/li&gt;
&lt;li&gt;028 匹配单字 46&lt;/li&gt;
&lt;li&gt;029 以特定的文字编码来进行正则表达式匹配 48&lt;/li&gt;
&lt;li&gt;030 在正则表达式“.”中匹配\n 50&lt;/li&gt;
&lt;li&gt;031 从上次匹配的部分开始继续匹配 51&lt;/li&gt;
&lt;li&gt;032 计算特定的文字、字符串出现的次数 53&lt;/li&gt;
&lt;li&gt;033 计算字符的出现频率 55&lt;/li&gt;
&lt;li&gt;034 比较字符串 56&lt;/li&gt;
&lt;li&gt;035 对空白进行匹配 57&lt;/li&gt;
&lt;li&gt;036 判断字符串是否为空行 58&lt;/li&gt;
&lt;li&gt;037 判断是否为表示数值的字符串 59&lt;/li&gt;
&lt;li&gt;038 将字符串变换为数值 60&lt;/li&gt;
&lt;li&gt;039 判断字符为大写或小写 62&lt;/li&gt;
&lt;li&gt;040 将字母变换为大写/小写 63&lt;/li&gt;
&lt;li&gt;041 取出字符串的一部分 65&lt;/li&gt;
&lt;li&gt;042 取出正则表达式匹配的部分 67&lt;/li&gt;
&lt;li&gt;043 取出正则表达式匹配部分的前后字符串 69&lt;/li&gt;
&lt;li&gt;044 查询包含特定文字部分的长度 70&lt;/li&gt;
&lt;li&gt;045 将字符串分割为段落 71&lt;/li&gt;
&lt;li&gt;046 将字符串分割为行 73&lt;/li&gt;
&lt;li&gt;047 将字符串分割为单字 74&lt;/li&gt;
&lt;li&gt;048 以正则表达式来分割字符串 76&lt;/li&gt;
&lt;li&gt;049 处理字符串的个别文字 78&lt;/li&gt;
&lt;li&gt;050 处理字符串的单一字节 79&lt;/li&gt;
&lt;li&gt;051 链接字符串 80&lt;/li&gt;
&lt;li&gt;052 置换字符串的一部分内容 81&lt;/li&gt;
&lt;li&gt;053 跳脱字符/除去跳脱字符 83&lt;/li&gt;
&lt;li&gt;054 除去字符串的一部分 85&lt;/li&gt;
&lt;li&gt;055 取出行尾的换行字符 87&lt;/li&gt;
&lt;li&gt;056 除去字符串开头/结尾的空白 89&lt;/li&gt;
&lt;li&gt;057 变换Tab与半角空格符 91&lt;/li&gt;
&lt;li&gt;058 变更缩排 92&lt;/li&gt;
&lt;li&gt;059 将Here Document缩排后编写 94&lt;/li&gt;
&lt;li&gt;060 在字符串结尾加上字符串 95&lt;/li&gt;
&lt;li&gt;061 对字符串的一部分进行破坏性删除 97&lt;/li&gt;
&lt;li&gt;062 在字符串中间破坏性地插入字符串 99&lt;/li&gt;
&lt;li&gt;063 字符与字符编码相互变换 101&lt;/li&gt;
&lt;li&gt;064 将字符串依n个文字来分割 103&lt;/li&gt;
&lt;li&gt;065 将字符串切出最大n字节的部分字符串 104&lt;/li&gt;
&lt;li&gt;066 将字符串切出最大n个文字的部分字符串 106&lt;/li&gt;
&lt;li&gt;067 将字符串切出最大n位的部分字符串 107&lt;/li&gt;
&lt;li&gt;068 以特定文字来隐藏部分字符串 108&lt;/li&gt;
&lt;li&gt;069 建立信息摘要（Message Digest） 109&lt;/li&gt;
&lt;li&gt;070 判断字符串是否可作为正确的正则表达式 111&lt;/li&gt;
&lt;li&gt;071 跳脱正则表达式的Meta文字 112&lt;/li&gt;
&lt;li&gt;072 判断字符串是否同时与多个正则表达式匹配 113&lt;/li&gt;
&lt;li&gt;073 分割正则表达式来记述 114&lt;/li&gt;
&lt;li&gt;074 正则表达式集 116&lt;/li&gt;
&lt;li&gt;075 将字符串整形为各段落 118&lt;/li&gt;
&lt;li&gt;076 解析各种文字格式 119&lt;/li&gt;
&lt;li&gt;077 处理以“,”来分隔的数据（CSV） 122&lt;/li&gt;
&lt;li&gt;078 解析XML 124&lt;/li&gt;
&lt;li&gt;079 解析YAML 127&lt;/li&gt;
&lt;li&gt;080 处理HTML 129&lt;/li&gt;
&lt;li&gt;081 自动补完单字 132&lt;/li&gt;
&lt;li&gt;082 判断是否为有效的E-mail地址 134&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;第3章 数组（Array）与哈希（Hash）

&lt;ol&gt;
&lt;li&gt;083 建立数组 136&lt;/li&gt;
&lt;li&gt;084 复制数组 138&lt;/li&gt;
&lt;li&gt;085 建立多维数组 139&lt;/li&gt;
&lt;li&gt;086 依序处理数组及哈希的所有元素 140&lt;/li&gt;
&lt;li&gt;087 并行处理多个数组 141&lt;/li&gt;
&lt;li&gt;088 多维数组的循环 143&lt;/li&gt;
&lt;li&gt;089 取得数组的元素 144&lt;/li&gt;
&lt;li&gt;090 改变数组的元素 146&lt;/li&gt;
&lt;li&gt;091 删除数组的元素 147&lt;/li&gt;
&lt;li&gt;092 在数组的开头/结尾加入元素 148&lt;/li&gt;
&lt;li&gt;093 取出并除去数组开头/结尾的元素 149&lt;/li&gt;
&lt;li&gt;094 置换数组的元素 150&lt;/li&gt;
&lt;li&gt;095 随机取得数组中的元素 151&lt;/li&gt;
&lt;li&gt;096 随机排列数组中的元素 152&lt;/li&gt;
&lt;li&gt;097 查询数组的元素个数 153&lt;/li&gt;
&lt;li&gt;098 查询数组中元素的出现次数 154&lt;/li&gt;
&lt;li&gt;099 从数组中一次取出多个元素 155&lt;/li&gt;
&lt;li&gt;100 取得数组中索引与元素的配对组 156&lt;/li&gt;
&lt;li&gt;101 将数组中元素填入相同的值 157&lt;/li&gt;
&lt;li&gt;102 由数组中取出并除去重复的元素 158&lt;/li&gt;
&lt;li&gt;103 取得数组中满足条件的元素 159&lt;/li&gt;
&lt;li&gt;104 查找数组的元素 160&lt;/li&gt;
&lt;li&gt;105 比较两个数组 161&lt;/li&gt;
&lt;li&gt;106 找出两个数组中相同的元素 162&lt;/li&gt;
&lt;li&gt;107 取出两个数组间的差 163&lt;/li&gt;
&lt;li&gt;108 连接数组 164&lt;/li&gt;
&lt;li&gt;109 将数组中元素的顺序反转 165&lt;/li&gt;
&lt;li&gt;110 将一定范围的整数作为数组的元素 166&lt;/li&gt;
&lt;li&gt;111 将数组作为（以“,”）连接的字符串 167&lt;/li&gt;
&lt;li&gt;112 二元查找法 168&lt;/li&gt;
&lt;li&gt;113 建立哈希的键值类别 169&lt;/li&gt;
&lt;li&gt;114 在哈希中加入元素 170&lt;/li&gt;
&lt;li&gt;115 查询哈希内键值是否存在 171&lt;/li&gt;
&lt;li&gt;116 删除哈希的元素 172&lt;/li&gt;
&lt;li&gt;117 显示哈希的内容 173&lt;/li&gt;
&lt;li&gt;118 将哈希元素以插入顺序取出 174&lt;/li&gt;
&lt;li&gt;119 建立单一键可对应多值的哈希 176&lt;/li&gt;
&lt;li&gt;120 交替哈希的键与值 177&lt;/li&gt;
&lt;li&gt;121 排序数组及哈希 178&lt;/li&gt;
&lt;li&gt;122 合并哈希 180&lt;/li&gt;
&lt;li&gt;123 找出两个哈希中都有的键/只有一个哈希才有的键 181&lt;/li&gt;
&lt;li&gt;124 设置默认值 182&lt;/li&gt;
&lt;li&gt;125 使用巨大的离散数组 183&lt;/li&gt;
&lt;li&gt;126 建立具有Collection特性的类别 184&lt;/li&gt;
&lt;li&gt;127 使用堆栈与队列 185&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;第4章 文件与目录

&lt;ol&gt;
&lt;li&gt;128 将文件名分割为其组成元素 188&lt;/li&gt;
&lt;li&gt;129 从相对路径求出绝对路径 189&lt;/li&gt;
&lt;li&gt;130 判断路径名是否吻合样式（Pattern）.. 190&lt;/li&gt;
&lt;li&gt;131 取得目录与文件一览 192&lt;/li&gt;
&lt;li&gt;132 取得目前所在的目录名称 194&lt;/li&gt;
&lt;li&gt;133 变更当前目录 195&lt;/li&gt;
&lt;li&gt;134 求得执行脚本所处的路径 196&lt;/li&gt;
&lt;li&gt;135 更改文件名 197&lt;/li&gt;
&lt;li&gt;136 复制文件 198&lt;/li&gt;
&lt;li&gt;137 删除文件 200&lt;/li&gt;
&lt;li&gt;138 判断文件是否可读取、可写入 201&lt;/li&gt;
&lt;li&gt;139 判断文件是否存在/判断其种类 202&lt;/li&gt;
&lt;li&gt;140 取得文件属性 203&lt;/li&gt;
&lt;li&gt;141 变更文件属性 205&lt;/li&gt;
&lt;li&gt;142 建立链接 207&lt;/li&gt;
&lt;li&gt;143 判断两个文件是否相同 209&lt;/li&gt;
&lt;li&gt;144 建立目录 211&lt;/li&gt;
&lt;li&gt;145 对目录内的所有文件进行递归处理 212&lt;/li&gt;
&lt;li&gt;146 递归复制目录 213&lt;/li&gt;
&lt;li&gt;147 删除目录 214&lt;/li&gt;
&lt;li&gt;148 事先确认文件操作 215&lt;/li&gt;
&lt;li&gt;149 新增名称不重复的文件 216&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;第5章 输入/输出

&lt;ol&gt;
&lt;li&gt;150 打开文件 219&lt;/li&gt;
&lt;li&gt;151 以行为单位来处理文件 220&lt;/li&gt;
&lt;li&gt;152 读取文件内容 222&lt;/li&gt;
&lt;li&gt;153 建立新的文件 224&lt;/li&gt;
&lt;li&gt;154 在文件末尾加入数据 226&lt;/li&gt;
&lt;li&gt;155 以单行指令（One-liner）更新文件 227&lt;/li&gt;
&lt;li&gt;156 使输出操作与文件更新同步 228&lt;/li&gt;
&lt;li&gt;157 计算文件的行数 229&lt;/li&gt;
&lt;li&gt;158 将文件由文件末尾开始处理至行单位中 230&lt;/li&gt;
&lt;li&gt;159 读取正在写入的文件 232&lt;/li&gt;
&lt;li&gt;160 建立暂存文件 233&lt;/li&gt;
&lt;li&gt;161 锁定文件 234&lt;/li&gt;
&lt;li&gt;162 将文件转为十六进制 235&lt;/li&gt;
&lt;li&gt;163 在文件中插入一行 236&lt;/li&gt;
&lt;li&gt;164 以二进制模式写入文件 238&lt;/li&gt;
&lt;li&gt;165 处理固定长度的记录 239&lt;/li&gt;
&lt;li&gt;166 切割文件大小 241&lt;/li&gt;
&lt;li&gt;167 删除文件开头的n行 242&lt;/li&gt;
&lt;li&gt;168 删除文件末尾的n行 243&lt;/li&gt;
&lt;li&gt;169 将标准输入/输出接替至文件 245&lt;/li&gt;
&lt;li&gt;170 复制I/O对象 246&lt;/li&gt;
&lt;li&gt;171 以printf来格式化输出 248&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;第6章 数值

&lt;ol&gt;
&lt;li&gt;172 格式化数值 251&lt;/li&gt;
&lt;li&gt;173 位运算 253&lt;/li&gt;
&lt;li&gt;174 在二进制、八进制、十进制、十六进制间相互转换 254&lt;/li&gt;
&lt;li&gt;175 将数值每三位以“,”区隔开来 255&lt;/li&gt;
&lt;li&gt;176 指定次数并重复处理 256&lt;/li&gt;
&lt;li&gt;177 求解最大值、最小值 257&lt;/li&gt;
&lt;li&gt;178 求解数值的总和 258&lt;/li&gt;
&lt;li&gt;179 求绝对值 259&lt;/li&gt;
&lt;li&gt;180 求除法的余数 260&lt;/li&gt;
&lt;li&gt;181 求解指数 262&lt;/li&gt;
&lt;li&gt;182 求最大公因数及最小公倍数 263&lt;/li&gt;
&lt;li&gt;183 求解平方根 264&lt;/li&gt;
&lt;li&gt;184 计算三角函数 265&lt;/li&gt;
&lt;li&gt;185 将直角坐标系转换为极坐标系 266&lt;/li&gt;
&lt;li&gt;186 进行对数计算 267&lt;/li&gt;
&lt;li&gt;187 对浮点数进行四舍五入等处理 268&lt;/li&gt;
&lt;li&gt;188 比较浮点数 270&lt;/li&gt;
&lt;li&gt;189 取得随机数 271&lt;/li&gt;
&lt;li&gt;190 使用矩阵 272&lt;/li&gt;
&lt;li&gt;191 使用复数 274&lt;/li&gt;
&lt;li&gt;192 使用有理数 275&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;第7章 日期与时间

&lt;ol&gt;
&lt;li&gt;193 查询现在的日期与时间 277&lt;/li&gt;
&lt;li&gt;194 由日期时间中取出月份、星期几等 279&lt;/li&gt;
&lt;li&gt;195 日期时间与Epoch秒相互转换 280&lt;/li&gt;
&lt;li&gt;196 求两个日期时间的差 282&lt;/li&gt;
&lt;li&gt;197 格式化日期时间 283&lt;/li&gt;
&lt;li&gt;198 将字符串转换为日期时间 285&lt;/li&gt;
&lt;li&gt;199 求出由1月1日起到目前所经过的天数 286&lt;/li&gt;
&lt;li&gt;200 判断闰年 287&lt;/li&gt;
&lt;li&gt;201 求出一个月最后一天的日期 288&lt;/li&gt;
&lt;li&gt;202 判断是否为假日 289&lt;/li&gt;
&lt;li&gt;203 求出“本月第三个星期一”的日期 290&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;第8章 环境相关

&lt;ol&gt;
&lt;li&gt;204 将Ruby脚本做成一般指令 292&lt;/li&gt;
&lt;li&gt;205 暂时性地在做成指令的Ruby脚本上加入选项后执行 295&lt;/li&gt;
&lt;li&gt;206 取得命令行的参数 296&lt;/li&gt;
&lt;li&gt;207 解析命令行选项 298&lt;/li&gt;
&lt;li&gt;208 存取环境变量 301&lt;/li&gt;
&lt;li&gt;209 让脚本作为指令或者函数库都可以执行 302&lt;/li&gt;
&lt;li&gt;210 控制Ruby的函数库加载器（Library Loader） 303&lt;/li&gt;
&lt;li&gt;211 对Ruby脚本进行除错 304&lt;/li&gt;
&lt;li&gt;212 取得用户及群组相关信息 307&lt;/li&gt;
&lt;li&gt;213 切换使用者ID、群组ID 310&lt;/li&gt;
&lt;li&gt;214 存取Windows登录文件（Registry） 312&lt;/li&gt;
&lt;li&gt;215 调用系统函数库的函数 313&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;第9章 程序间通信

&lt;ol&gt;
&lt;li&gt;216 暂时停止脚本 317&lt;/li&gt;
&lt;li&gt;217 测量脚本的运行时间 318&lt;/li&gt;
&lt;li&gt;218 启动指令 320&lt;/li&gt;
&lt;li&gt;219 产生子程序（fork） 322&lt;/li&gt;
&lt;li&gt;220 设置信号处理器（Signal Handler） 323&lt;/li&gt;
&lt;li&gt;221 Deamo 324&lt;/li&gt;
&lt;li&gt;222 控制Windows的应用程序 325&lt;/li&gt;
&lt;li&gt;223 取得本机名称 327&lt;/li&gt;
&lt;li&gt;224 变换机器名称以及IP位置 328&lt;/li&gt;
&lt;li&gt;225 建立TCP客户端 329&lt;/li&gt;
&lt;li&gt;226 制作一个TCP服务器 330&lt;/li&gt;
&lt;li&gt;227 建立HTTP客户端 332&lt;/li&gt;
&lt;li&gt;228 存取其他程序的Ruby对象 334&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;第10章 CGI

&lt;ol&gt;
&lt;li&gt;229 由窗体中取出输入值 337&lt;/li&gt;
&lt;li&gt;230 取出Query字符串 338&lt;/li&gt;
&lt;li&gt;231 使用Session 339&lt;/li&gt;
&lt;li&gt;232 处理Cookie 341&lt;/li&gt;
&lt;li&gt;233 参照Meta变量 343&lt;/li&gt;
&lt;li&gt;234 输出HTML头文件 344&lt;/li&gt;
&lt;li&gt;235 对URL进行编码/反编码 345&lt;/li&gt;
&lt;li&gt;236 跳脱/不跳脱HTML 346&lt;/li&gt;
&lt;li&gt;237 使用污染模式（taint mode） 347&lt;/li&gt;
&lt;li&gt;238 预防XSS（Cross Site Scripting） 349&lt;/li&gt;
&lt;li&gt;239 在HTML中嵌入Ruby脚本 351&lt;/li&gt;
&lt;li&gt;240 上传文件 352&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;第11章 对象

&lt;ol&gt;
&lt;li&gt;241 判断对象是否相同 354&lt;/li&gt;
&lt;li&gt;242 复制对象 356&lt;/li&gt;
&lt;li&gt;243 查询对象的类别 357&lt;/li&gt;
&lt;li&gt;244 将对象转换为字符串 359&lt;/li&gt;
&lt;li&gt;245 将对象转换为数值 360&lt;/li&gt;
&lt;li&gt;246 将对象转换为数组 362&lt;/li&gt;
&lt;li&gt;247 将对象存储在文件中 363&lt;/li&gt;
&lt;li&gt;248 多重继承 365&lt;/li&gt;
&lt;li&gt;249 委托方法 366&lt;/li&gt;
&lt;li&gt;250 委托区块 368&lt;/li&gt;
&lt;li&gt;251 建立可作为String或Array来操作的类别 369&lt;/li&gt;
&lt;li&gt;252 使用无名函数 371&lt;/li&gt;
&lt;li&gt;253 多载方法 372&lt;/li&gt;
&lt;li&gt;254 使用关键词参数 374&lt;/li&gt;
&lt;li&gt;255 定义模块函数 375&lt;/li&gt;
&lt;li&gt;256 定义类别方法的别名 376&lt;/li&gt;
&lt;li&gt;257 将实例变量依各个类别来设为private 377&lt;/li&gt;
&lt;li&gt;258 查询方法是否存在于对象中 379&lt;/li&gt;
&lt;li&gt;259 取得对象中定义的方法列表 381&lt;/li&gt;
&lt;li&gt;260 保有兼容性并改变方法名 383&lt;/li&gt;
&lt;li&gt;261 保有兼容性并改变参数的个数 384&lt;/li&gt;
&lt;li&gt;262 保有兼容性并加上/移除区块 386&lt;/li&gt;
&lt;li&gt;263 保持兼容性并更改类别名 387&lt;/li&gt;
&lt;li&gt;264 保有兼容性并更改函数库名 388&lt;/li&gt;
&lt;li&gt;265 在旧版Ruby中使用新版Ruby的方法 389&lt;/li&gt;
&lt;li&gt;266 将文件当作Ruby脚本来载入 390&lt;/li&gt;
&lt;li&gt;267 将字符串当作Ruby脚本来执行 391&lt;/li&gt;
&lt;li&gt;268 替代脚本文件名/行编号 392&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;附录A

&lt;ol&gt;
&lt;li&gt;A01 Web上的资源 394&lt;/li&gt;
&lt;li&gt;A02 指令列选项 395&lt;/li&gt;
&lt;li&gt;A03 Ruby参考的环境变量 397&lt;/li&gt;
&lt;li&gt;A04 Ruby标准类别及函数库 398&lt;/li&gt;
&lt;li&gt;A05 printf格式化字符串 401&lt;/li&gt;
&lt;li&gt;A06 pack模板字符串... 403&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>程序员修炼之道 读书笔记</title>
   <link href="http://www.5wpc.info/it/career/coder/2011/02/19/ThePragmaticProgrammer"/>
   <updated>2011-02-19T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/career/coder/2011/02/19/ThePragmaticProgrammer</id>
   <content type="html">&lt;h1&gt;快速参考&lt;/h1&gt;

&lt;h2&gt;列表&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt; &lt;em&gt;关心你的技艺&lt;/em&gt;:
(Care About Your Craft) 如果你不在乎能否漂亮地开发出软件，你又为何要耗费生命去开发软件呢？&lt;/li&gt;
&lt;li&gt; &lt;em&gt;思考！你的工作&lt;/em&gt;:
(Think! About Your Work) 关掉自动驾驶仪，接管操作。不断地批评和评估你的工作。&lt;/li&gt;
&lt;li&gt; &lt;em&gt;提供各种选择，不要找蹩脚的借口&lt;/em&gt;:
(Provide Options, Don&#39;t Make Lame Excuses) 要提供各种选择，而不是借口。不要说事情做不到；说明能够做什么。&lt;/li&gt;
&lt;li&gt; &lt;em&gt;不要容忍破窗户&lt;/em&gt;:
(Don&#39;t Live with Broken Windows) 当你看到糟糕的设计、错误的决策和糟糕的代码时，修正他们。&lt;/li&gt;
&lt;li&gt; &lt;em&gt;做变化的催化剂&lt;/em&gt;:
(Be a Catalyst for Change) 你不能强迫人们改变。相反，要向他们展示未来可能会怎样，并帮助他们参与对未来的创造。&lt;/li&gt;
&lt;li&gt; &lt;em&gt;记住大图景&lt;/em&gt;:
(Remember the Big Picture) 不要太过专注于细节，以致忘了查看你周围正在发生什么。&lt;/li&gt;
&lt;li&gt; &lt;em&gt;使质量成为需求问题&lt;/em&gt;:
(Make Quality a Requirements Issue) 让你的用户参与确定项目真正的需求。&lt;/li&gt;
&lt;li&gt; &lt;em&gt;定期为你的知识资产投资&lt;/em&gt;:
(Invest Regularly in Your Konwledge Portfolio) 让学习成为习惯&lt;/li&gt;
&lt;li&gt; &lt;em&gt;批判的分析你读到的和听到的&lt;/em&gt;:
(Critically Analyze What You Read and Hear) 不要被供应商、媒体炒作、或教条左右。要依照你自己的看法和你的项目的情况去对信息进行分析。&lt;/li&gt;
&lt;li&gt; &lt;em&gt;你说什么和你怎么说同样重要&lt;/em&gt;:
(It&#39;s Both What You Say and the Way You Say It) 如果你不能有效地向他人传递你的了不起的想法，这些想法就毫无用处。&lt;/li&gt;
&lt;li&gt; &lt;em&gt;不要重复你自己&lt;/em&gt;:
(DRY -- Don&#39;t Repeat Yourself) 系统中的每一项知识都必须具有单一、无歧异、权威的表示。&lt;/li&gt;
&lt;li&gt; &lt;em&gt;让复用变得容易&lt;/em&gt;:
(Make It Easy to Reuse) 如果复用很容易，人们就会去复用。创造一个支持复用的环境。&lt;/li&gt;
&lt;li&gt; &lt;em&gt;消除无关事务之间的影响&lt;/em&gt;:
(Eliminate Effects Between Unrelated Things) 设计自足、独立、并具有单一、良好定义的目的的组件。&lt;/li&gt;
&lt;li&gt; &lt;em&gt;不存在最终决策&lt;/em&gt;:
(There Are No Final Decisions) 没有决策是浇铸在石头上的。相反，要把每项决策都视为写在沙滩上的，并为变化作好计划。&lt;/li&gt;
&lt;li&gt; &lt;em&gt;用曳光弹找到目标&lt;/em&gt;:
(Use Tracer Bullets to Find the Target) 曳光弹能通过试验各种事物并检查他们离目标有多远来让你追踪目标。&lt;/li&gt;
&lt;li&gt; &lt;em&gt;为了学习而制作原型&lt;/em&gt;:
(Prototype to Learn) 原型制作是一种学习经验。其价值并不在于所产生的代码，而在于所学到的经验教训。&lt;/li&gt;
&lt;li&gt; &lt;em&gt;靠近问题领域编程&lt;/em&gt;:
(Program Close to the Problem domain) 用你的用户的语言进行设计和编码。&lt;/li&gt;
&lt;li&gt; &lt;em&gt;估算，以避免发生意外&lt;/em&gt;:
(Estimate to Avoid Surprises) 在着手之前先进行估算。你将提前发现潜在的问题。&lt;/li&gt;
&lt;li&gt; &lt;em&gt;通过代码对进度表进行迭代&lt;/em&gt;:
(Iterate the Schedule with the Code) 用你在进行实现时获得的经验提炼项目的时间标度。&lt;/li&gt;
&lt;li&gt; &lt;em&gt;以纯文本保存知识&lt;/em&gt;:
(Keep Knowledge in Plain Text) 纯文本不会过时。它能够帮助你有效利用你的工作，并简化调试和测试。&lt;/li&gt;
&lt;li&gt; &lt;em&gt;利用命令shell的力量&lt;/em&gt;:
(Use the Power of Command Shells) 当图形用户界面无能为力时使用shell&lt;/li&gt;
&lt;li&gt; &lt;em&gt;用好一种编辑器&lt;/em&gt;:
(Use a Single Editor Well) 编辑器应该是你的手的延伸；确保你的编辑器是可配置、可扩展和可编程的。&lt;/li&gt;
&lt;li&gt; &lt;em&gt;总是使用源码控制&lt;/em&gt;:
(Always Use Source Code Control) 源码控制是你的工作时间的机器——你能够回到过去。&lt;/li&gt;
&lt;li&gt; &lt;em&gt;要修正问题，而不是发出指责&lt;/em&gt;:
(Fix the Problem, Not the Blame) Bug是你的过错还是别人的过错，并不是真的很有关系——他仍然是你的问题，他仍然需要修正。&lt;/li&gt;
&lt;li&gt; &lt;em&gt;调试时不要恐慌&lt;/em&gt;:
(Don’t Panic When Debuging) 做一次深呼吸，思考什么可能是bug的原因。&lt;/li&gt;
&lt;li&gt; &lt;em&gt;“Select”没有问题&lt;/em&gt;:
(“Select” Isn’t Broken) 在OS或编译器、甚至或是第三方产品或库中很少发现bug。Bug很可能在应用中。&lt;/li&gt;
&lt;li&gt; &lt;em&gt;不要假定，要证明&lt;/em&gt;:
(Don’t Assume It-Prove It) 在实际环境中——使用真正的数据和边界条件——证明你的假定。&lt;/li&gt;
&lt;li&gt; &lt;em&gt;学习一种文本操纵语言&lt;/em&gt;:
(Learn a Text Manipulation Language) 你们每天的很大一部分时间处理文本，为什么不让计算机替你完成部分工作呢？&lt;/li&gt;
&lt;li&gt; &lt;em&gt;编写能写代码的代码&lt;/em&gt;:
(Write Code That Writes Code) 代码生成器能提高你的生产效率，并有助于避免重复。&lt;/li&gt;
&lt;li&gt; &lt;em&gt;你不可能写出完美的软件&lt;/em&gt;:
(You Can’t Write Perfect Software) 软件不可能完美。保护你的代码和用户，使它（他）们免于能够预见的错误。&lt;/li&gt;
&lt;li&gt; &lt;em&gt;通过合约进行设计&lt;/em&gt;:
(Design with Contracts) 使用合约建立文档，并检查代码所做的事情正好是他声明要做的。&lt;/li&gt;
&lt;li&gt; &lt;em&gt;早崩溃&lt;/em&gt;:
(Crash Early) 死程序造成的危害通常比有问题的程序要小的多。&lt;/li&gt;
&lt;li&gt; &lt;em&gt;用断言避免不可能发生的事情&lt;/em&gt;:
(Use Assertions to Prevent the Impossisble) 断言验证你的各种假定。在一个不确定的世界里，用断言保护你的代码。&lt;/li&gt;
&lt;li&gt; &lt;em&gt;将异常用于异常问题&lt;/em&gt;:
(Use Exceptions for Exceptional Problems) 异常可能会遭受经典的意大利面条式代码的所有可读性和可维护性问题的折磨。将异常保留给异常的事物。&lt;/li&gt;
&lt;li&gt; &lt;em&gt;要有始有终&lt;/em&gt;:
(Finish What You Start) 只要可能，分配某资源的例程或对象也应该负责解除其分配。&lt;/li&gt;
&lt;li&gt; &lt;em&gt;将模块之间的耦合减至最少&lt;/em&gt;:
(Minimize Coupling Between Modules) 通过编写“羞怯的”代码并应用得墨忒耳法则来避免耦合。&lt;/li&gt;
&lt;li&gt; &lt;em&gt;要配置，不要集成&lt;/em&gt;:
(Configure, Don’t Integrate) 要将应用的各种技术选择实现为配置选项，而不是通过集成或工程方法实现。&lt;/li&gt;
&lt;li&gt; &lt;em&gt;将抽象放进代码，细节放进元数据&lt;/em&gt;:
(Put Abstractions in Code, Details in Metadata) 为一般情况编程，将细节放在被编译的代码库之外。&lt;/li&gt;
&lt;li&gt; &lt;em&gt;分析工作流，以改善并发性&lt;/em&gt;:
(Analyze Workflow to Improve Concurrency) 利用你的用户的工作流中的并发性。&lt;/li&gt;
&lt;li&gt; &lt;em&gt;用服务进行设计&lt;/em&gt;:
(Design Using Services) 根据服务——独立的、在良好定义、一致的接口之后的并发对象——进行设计。&lt;/li&gt;
&lt;li&gt; &lt;em&gt;总是为并发进行设计&lt;/em&gt;:
(Always Design for Concurrency) 容许并发，你将会设计出更整洁、具有更少假定的接口。&lt;/li&gt;
&lt;li&gt; &lt;em&gt;视图与模型分离&lt;/em&gt;:
(Separate Views form Models) 要根据模型和视图设计你的应用，从而以低廉的代码获取灵活性。&lt;/li&gt;
&lt;li&gt; &lt;em&gt;用黑板协调工作流&lt;/em&gt;:
(Use Blackboards to Coordinate Workflow) 用黑板协调完成不同的事实和因素，同时又使各参与方保持独立和隔离。&lt;/li&gt;
&lt;li&gt; &lt;em&gt;不要靠巧合编程&lt;/em&gt;:
(Don’t Program by Coincidence) 只依靠可靠的事物。注意偶发的复杂性，不要把幸运的巧合与有目的的计划混为一谈。&lt;/li&gt;
&lt;li&gt; &lt;em&gt;估计你的算法的阶&lt;/em&gt;:
(Estimate the Order of Your Algorithms) 在你编写代码之前，先大致估算事情需要多长时间&lt;/li&gt;
&lt;li&gt; &lt;em&gt;测试你的估计&lt;/em&gt;:
(Test your Estimates) 对算法的数学分析并不会告诉你每一件事情。在你的代码的目标环境中测定他的速度。&lt;/li&gt;
&lt;li&gt; &lt;em&gt;早重构，常重构&lt;/em&gt;:
(Refactor Early, Refactor Often) 就和你会在花园里除草、并重新布置一样，在需要时对代码进行重写、重做和重新架构。要铲除问题的根源。&lt;/li&gt;
&lt;li&gt; &lt;em&gt;为测试而设计&lt;/em&gt;:
(Design to Test) 在你还没有编写代码时就还是思考测试问题。&lt;/li&gt;
&lt;li&gt; &lt;em&gt;测试你的软件，否则你的用户就得测试&lt;/em&gt;:
(Test Your Software, or Your Users Will) 无情地测试。不要让你的用户为你查找bug。&lt;/li&gt;
&lt;li&gt; &lt;em&gt;不要使用你不理解的向导代码&lt;/em&gt;:
(Don’t Use Wizard Code You Don’t Understand) 向导代码可以生成大量代码。在你把它们合并进你的项目之前，确保你理解全部这些代码。&lt;/li&gt;
&lt;li&gt; &lt;em&gt;不要搜集需求——挖掘它们&lt;/em&gt;:
(Don’t Gather Requirements – Dig for Them) 需求很少存在于表面上。它们深深地埋藏在层层假定、误解和政治手段下面。&lt;/li&gt;
&lt;li&gt; &lt;em&gt;与用户一同工作，像用户一样思考&lt;/em&gt;:
(Work with a User to Think Like a User) 要了解系统实际上将如何被使用，这是最好的方法。&lt;/li&gt;
&lt;li&gt; &lt;em&gt;抽象比细节活得更长久&lt;/em&gt;:
(Abstractions Live Longer than Details) “投资”于抽象，而不是现实。抽象能在来自不同的现实和新技术的变化的“攻击”之下存活下去。&lt;/li&gt;
&lt;li&gt; &lt;em&gt;使用项目词汇表&lt;/em&gt;:
(Use a Project Glossary) 创建并维护项目中使用的专用术语和词汇的单一信息源。&lt;/li&gt;
&lt;li&gt; &lt;em&gt;不要在盒子外面思考——要找到盒子&lt;/em&gt;:
(Don’t Think Outside the Box – Find the Box) 在遇到不可能解决的问题时，要确定真正的约束。问问你自己：“它必须以这种方式完成吗？它真的必须完成吗？”&lt;/li&gt;
&lt;li&gt; &lt;em&gt;等你准备好在开始&lt;/em&gt;:
(Start When You’re Ready) 你的一生都在积累经验。不要忽视反复出现的疑虑。&lt;/li&gt;
&lt;li&gt; &lt;em&gt;对有些事情“做”胜于“描述”&lt;/em&gt;:
(Some Things are Better Done than Described) 不要掉进规范的旋涡——在某个时刻，你需要开始编码。&lt;/li&gt;
&lt;li&gt; &lt;em&gt;不要做形式方法的奴隶&lt;/em&gt;:
(Don’t Be a Slave to Formal Methods) 如果你没有把某项技术放进你的开发实践和能力的语境中，不要盲目地采用它。&lt;/li&gt;
&lt;li&gt; &lt;em&gt;昂贵的工具不一定能制作出更好的设计&lt;/em&gt;:
(Costly Tools Don’t produce Better Designs) 小心供应商的炒作，行业教条、以及价格标签的诱惑。要根据工具的价值判断它们。&lt;/li&gt;
&lt;li&gt; &lt;em&gt;围绕功能组织团队&lt;/em&gt;:
(Organize Teams Around Functionality) 不要把设计师与编码员分开，也不要把测试员与数据建模员分开。按照你构建代码的方式构建团队。&lt;/li&gt;
&lt;li&gt; &lt;em&gt;不要使用手工流程&lt;/em&gt;:
(Don’t Use Manual Procedures) Shell脚本或批文件会一次次地以同一顺序执行同样的指令。&lt;/li&gt;
&lt;li&gt; &lt;em&gt;早测试，常测试，自动测试&lt;/em&gt;:
(Test Early. Test Often. Test Automatically) 与呆在书架上的测试计划相比，每次构建时运行的测试要有效的多。&lt;/li&gt;
&lt;li&gt; &lt;em&gt;要通过全部测试，编码才算完成&lt;/em&gt;:
(Coding didn’t Done Until All the Tests Run) 就是这样。&lt;/li&gt;
&lt;li&gt; &lt;em&gt;通过“蓄意破坏”测试你的测试&lt;/em&gt;:
(Use Saboteurs to Test Your Testing) 在单独的软件副本上故意引用bug，以检验测试能够抓住它们。&lt;/li&gt;
&lt;li&gt; &lt;em&gt;测试状态覆盖，而不是代码覆盖&lt;/em&gt;:
(Test State Coverage, Not Code Coverage) 确定并测试重要的程序状态。只是测试代码行是不够的。&lt;/li&gt;
&lt;li&gt; &lt;em&gt;一个bug只抓一次&lt;/em&gt;:
(Find Bugs Once) 一旦测试员找到一个bug，这应该是测试员最后一次找到它。此后自动测试应该对应其进行检查。&lt;/li&gt;
&lt;li&gt; &lt;em&gt;英语就是一种编程语言&lt;/em&gt;:
(English is Just a Programming Language) 像你编写代码一样编写文档：遵守DIY原则、使用原数据、MVC、自动生成，等等。&lt;/li&gt;
&lt;li&gt; &lt;em&gt;把文档建在里面，不要拴在外面&lt;/em&gt;:
(Build Documentation In, Don’t Bolt It On) 与代码分离的文档不太可能被修整和更新。&lt;/li&gt;
&lt;li&gt; &lt;em&gt;温和地超出用户的期望&lt;/em&gt;:
(Gently Exceed Your Users’ Expectations) 要理解你的用户的期望，然后给他们的东西要多那么一点。&lt;/li&gt;
&lt;li&gt; &lt;em&gt;在你的作品上签名&lt;/em&gt;:
(Sign Your Work) 过去时代的手工艺人为能在他们的作品上签名而自豪。一夜应该如此。&lt;/li&gt;
&lt;/ol&gt;


&lt;h2&gt;检查清单&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt; 要学习的语言:
厌倦了C、C++和JAVA?试试CLOS、Dylan、Eiffel、Objective C、Prolog、Smalltalk或TOM。他们每一种都有不同的能力和不同的“风味”。用其中的一种或多种语言在家里开发一个小项目。&lt;/li&gt;
&lt;li&gt; WISDOM离合诗:

&lt;ul&gt;
&lt;li&gt;What do you want them to learn? 你想让他们学到什么？&lt;/li&gt;
&lt;li&gt;What is their interest in what you’ve got to say? 他们对你讲的什么感兴趣?&lt;/li&gt;
&lt;li&gt;How sophisticated are they? 他们有多富有经验？&lt;/li&gt;
&lt;li&gt;How much detail do they want? 他们想要多少细节？&lt;/li&gt;
&lt;li&gt;Whom do you want to own the information? 你想要让谁拥有这些信息？&lt;/li&gt;
&lt;li&gt;How can you Motivate them to listen to you? 你如何使他们听你说话？&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt; 怎样维持正交性:

&lt;ul&gt;
&lt;li&gt;设计独立、良好定义的组建。&lt;/li&gt;
&lt;li&gt;使你的代码保持解藕&lt;/li&gt;
&lt;li&gt;避免使用全局数据&lt;/li&gt;
&lt;li&gt;重构相似的函数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt; 应制作原型的事物:

&lt;ul&gt;
&lt;li&gt;构架&lt;/li&gt;
&lt;li&gt;已有系统的新功能&lt;/li&gt;
&lt;li&gt;外部数据的结构或内容&lt;/li&gt;
&lt;li&gt;第三方工具或组建&lt;/li&gt;
&lt;li&gt;性能问题&lt;/li&gt;
&lt;li&gt;用户界面设计&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt; 架构问题:

&lt;ul&gt;
&lt;li&gt;责任是否得到了良好定义？&lt;/li&gt;
&lt;li&gt;写作是否得到了良好定义？&lt;/li&gt;
&lt;li&gt;耦合是否得以最小化？&lt;/li&gt;
&lt;li&gt;你能否确定潜在的重复？&lt;/li&gt;
&lt;li&gt;接口定义和各项约束是否可以接受？&lt;/li&gt;
&lt;li&gt;模块能否在需要时访问所需数据？&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt; 调试检查清单:

&lt;ul&gt;
&lt;li&gt;正在报告的问题是底层bug的直接结果，还是只是症状？&lt;/li&gt;
&lt;li&gt;Bug真的在编译器里？在OS里?或者是在你的代码里？&lt;/li&gt;
&lt;li&gt;如果你向同事详细解释这个问题，你会说什么？&lt;/li&gt;
&lt;li&gt;如果可以代码通过了单元测试，测试是否足够完整？如果你用该数据单元测试，会发生什么？&lt;/li&gt;
&lt;li&gt;造成这个bug的条件是否存在于系统的其他任何地方？&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt; 函数的得墨忒耳法则:

&lt;ul&gt;
&lt;li&gt;某个对象的方法应该值调用属于以下情形的方法：&lt;/li&gt;
&lt;li&gt;它自身&lt;/li&gt;
&lt;li&gt;传入的任何参数&lt;/li&gt;
&lt;li&gt;它创建的对象&lt;/li&gt;
&lt;li&gt;组件对象&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt; 怎样深思熟虑地编程:

&lt;ul&gt;
&lt;li&gt;总是意识到你在做什么&lt;/li&gt;
&lt;li&gt;不要盲目地编程&lt;/li&gt;
&lt;li&gt;按照计划行事&lt;/li&gt;
&lt;li&gt;依靠可靠的事物&lt;/li&gt;
&lt;li&gt;为你的假定建立文档&lt;/li&gt;
&lt;li&gt;不要只是测试你的代码，还要测试你的假定&lt;/li&gt;
&lt;li&gt;为你的工作划分优先级&lt;/li&gt;
&lt;li&gt;不要做历史的奴隶&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt; 何时进行重构:

&lt;ul&gt;
&lt;li&gt;你发现了对DRY原则的违反&lt;/li&gt;
&lt;li&gt;你发现事物可以更为正交&lt;/li&gt;
&lt;li&gt;你的知识扩展了&lt;/li&gt;
&lt;li&gt;需求演变了&lt;/li&gt;
&lt;li&gt;你需要改善性能&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt; 劈开戈尔迪斯结:

&lt;ul&gt;
&lt;li&gt;在解决不可能解决的问题时，问问自己：&lt;/li&gt;
&lt;li&gt;有更容易的方法吗？&lt;/li&gt;
&lt;li&gt;我是在解决正确的问题吗？&lt;/li&gt;
&lt;li&gt;这件事情为什么是一个问题？&lt;/li&gt;
&lt;li&gt;是什么使它如此难以解决？&lt;/li&gt;
&lt;li&gt;它必须以这种方式完成吗？&lt;/li&gt;
&lt;li&gt;它真的必须完成吗？&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt; 测试的各个方面:

&lt;ul&gt;
&lt;li&gt;单元测试&lt;/li&gt;
&lt;li&gt;集成测试&lt;/li&gt;
&lt;li&gt;验证和校验&lt;/li&gt;
&lt;li&gt;资源耗尽、错误及恢复&lt;/li&gt;
&lt;li&gt;性能测试&lt;/li&gt;
&lt;li&gt;可用性测试&lt;/li&gt;
&lt;li&gt;对测试自身进行测试&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;

</content>
 </entry>
 
 <entry>
   <title>重构与模式 读书笔记</title>
   <link href="http://www.5wpc.info/it/technical/design/2011/02/19/RefactoringtoPatterns"/>
   <updated>2011-02-19T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/technical/design/2011/02/19/RefactoringtoPatterns</id>
   <content type="html">&lt;h1&gt;目录&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;本书的写作缘由　1&lt;/li&gt;
&lt;li&gt; 1.1　过度设计　1&lt;/li&gt;
&lt;li&gt; 1.2　模式万灵丹　2&lt;/li&gt;
&lt;li&gt; 1.3　设计不足　2&lt;/li&gt;
&lt;li&gt; 1.4　测试驱动开发和持续重构　3&lt;/li&gt;
&lt;li&gt; 1.5　重构与模式　5&lt;/li&gt;
&lt;li&gt; 1.6　演进式设计　6&lt;/li&gt;
&lt;li&gt;重构　7&lt;/li&gt;
&lt;li&gt; 2.1　何谓重构　7&lt;/li&gt;
&lt;li&gt; 2.2　重构的动机　8&lt;/li&gt;
&lt;li&gt; 2.3　众目睽睽　9&lt;/li&gt;
&lt;li&gt; 2.4　可读性好的代码　10&lt;/li&gt;
&lt;li&gt; 2.5　保持清晰　11&lt;/li&gt;
&lt;li&gt; 2.6　循序渐进　11&lt;/li&gt;
&lt;li&gt; 2.7　设计欠账　12&lt;/li&gt;
&lt;li&gt; 2.8　演变出新的架构　13&lt;/li&gt;
&lt;li&gt; 2.9　复合重构与测试驱动的重构　13&lt;/li&gt;
&lt;li&gt; 2.10　复合重构的优点　15&lt;/li&gt;
&lt;li&gt; 2.11　重构工具　15&lt;/li&gt;
&lt;li&gt;模式　17&lt;/li&gt;
&lt;li&gt; 3.1　何谓模式　17&lt;/li&gt;
&lt;li&gt; 3.2　模式痴迷　18&lt;/li&gt;
&lt;li&gt; 3.3　实现模式的方式不止一种　20&lt;/li&gt;
&lt;li&gt; 3.4　通过重构实现、趋向和去除模式　22&lt;/li&gt;
&lt;li&gt; 3.5　模式是否会使代码更加复杂　24&lt;/li&gt;
&lt;li&gt; 3.6　模式知识　25&lt;/li&gt;
&lt;li&gt; 3.7　使用模式的预先设计　26&lt;/li&gt;
&lt;li&gt;代码坏味　29&lt;/li&gt;
&lt;li&gt; 4.1　重复代码(Duplicated Code)　31&lt;/li&gt;
&lt;li&gt; 4.2　方法过长(Long Method)　31&lt;/li&gt;
&lt;li&gt; 4.3　条件逻辑太复杂(Conditional Complexity)　32&lt;/li&gt;
&lt;li&gt; 4.4　基本类型迷恋(Primitive Obsession)　33&lt;/li&gt;
&lt;li&gt; 4.5　不恰当的暴露(Indecent Exposure)　33&lt;/li&gt;
&lt;li&gt; 4.6　解决方案蔓延(Solution Sprawl)　34&lt;/li&gt;
&lt;li&gt; 4.7　异曲同工的类(Alternative Classes with Different Interfaces)　34&lt;/li&gt;
&lt;li&gt; 4.8　冗赘类(Lazy Class)　34&lt;/li&gt;
&lt;li&gt; 4.9　类过大(Large Class)　34&lt;/li&gt;
&lt;li&gt; 4.10　分支语句(Switch Statement)　35&lt;/li&gt;
&lt;li&gt; 4.11　组合爆炸(Combinatorial Explosion)　35&lt;/li&gt;
&lt;li&gt; 4.12　怪异解决方案(Oddball Solution)　35&lt;/li&gt;
&lt;li&gt;模式导向的重构目录　37&lt;/li&gt;
&lt;li&gt; 5.1　重构的格式　37&lt;/li&gt;
&lt;li&gt; 5.2　本目录中引用的项目　38&lt;/li&gt;
&lt;li&gt; 5.2.1　XML Builder　39&lt;/li&gt;
&lt;li&gt; 5.2.2　HTML Parser　39&lt;/li&gt;
&lt;li&gt; 5.2.3　贷款风险计算程序　40&lt;/li&gt;
&lt;li&gt; 5.3　起点　40&lt;/li&gt;
&lt;li&gt; 5.4　学习顺序　41&lt;/li&gt;
&lt;li&gt;创建　43&lt;/li&gt;
&lt;li&gt; 6.1　用Creation Method替换构造函数　44&lt;/li&gt;
&lt;li&gt; 6.1.1　动机　44&lt;/li&gt;
&lt;li&gt; 6.1.2　做法　46&lt;/li&gt;
&lt;li&gt; 6.1.3　示例　46&lt;/li&gt;
&lt;li&gt; 6.1.4　变体　51&lt;/li&gt;
&lt;li&gt; 6.2　将创建知识搬移到Factory　52&lt;/li&gt;
&lt;li&gt; 6.2.1　动机　53&lt;/li&gt;
&lt;li&gt; 6.2.2　做法　55&lt;/li&gt;
&lt;li&gt; 6.2.3　示例　56&lt;/li&gt;
&lt;li&gt; 6.3　用Factory封装类　61&lt;/li&gt;
&lt;li&gt; 6.3.1　动机　62&lt;/li&gt;
&lt;li&gt; 6.3.2　做法　63&lt;/li&gt;
&lt;li&gt; 6.3.3　示例　63&lt;/li&gt;
&lt;li&gt; 6.3.4　变体　66&lt;/li&gt;
&lt;li&gt; 6.4　用Factory Method引入多态创建　68&lt;/li&gt;
&lt;li&gt; 6.4.1　动机　68&lt;/li&gt;
&lt;li&gt; 6.4.2　做法　69&lt;/li&gt;
&lt;li&gt; 6.4.3　示例　71&lt;/li&gt;
&lt;li&gt; 6.5　用Builder封装Composite　74&lt;/li&gt;
&lt;li&gt; 6.5.1　做法　76&lt;/li&gt;
&lt;li&gt; 6.5.2　示例　77&lt;/li&gt;
&lt;li&gt; 6.5.3　变体　87&lt;/li&gt;
&lt;li&gt; 6.6　内联Singleton　90&lt;/li&gt;
&lt;li&gt; 6.6.1　动机　90&lt;/li&gt;
&lt;li&gt; 6.6.2　做法　92&lt;/li&gt;
&lt;li&gt; 6.6.3　示例　93&lt;/li&gt;
&lt;li&gt;简化　97&lt;/li&gt;
&lt;li&gt; 7.1　组合方法　98&lt;/li&gt;
&lt;li&gt; 7.1.1　动机　98&lt;/li&gt;
&lt;li&gt; 7.1.2　做法　100&lt;/li&gt;
&lt;li&gt; 7.1.3　示例　100&lt;/li&gt;
&lt;li&gt; 7.2　用Strategy替换条件逻辑　103&lt;/li&gt;
&lt;li&gt; 7.2.1　动机　103&lt;/li&gt;
&lt;li&gt; 7.2.2　做法　105&lt;/li&gt;
&lt;li&gt; 7.2.3　示例　106&lt;/li&gt;
&lt;li&gt; 7.3　将装饰功能搬移到Decorator　115&lt;/li&gt;
&lt;li&gt; 7.3.1　动机　115&lt;/li&gt;
&lt;li&gt; 7.3.2　做法　119&lt;/li&gt;
&lt;li&gt; 7.3.3　示例　120&lt;/li&gt;
&lt;li&gt; 7.4　用State替换状态改变条件语句　134&lt;/li&gt;
&lt;li&gt; 7.4.1　动机　134&lt;/li&gt;
&lt;li&gt; 7.4.2　做法　135&lt;/li&gt;
&lt;li&gt; 7.4.3　示例　136&lt;/li&gt;
&lt;li&gt; 7.5　用Composite替换隐含树　144&lt;/li&gt;
&lt;li&gt; 7.5.1　动机　144&lt;/li&gt;
&lt;li&gt; 7.5.2　做法　147&lt;/li&gt;
&lt;li&gt; 7.5.3　示例　148&lt;/li&gt;
&lt;li&gt; 7.6　用Command替换条件调度程序　155&lt;/li&gt;
&lt;li&gt; 7.6.1　动机　156&lt;/li&gt;
&lt;li&gt; 7.6.2　做法　157&lt;/li&gt;
&lt;li&gt; 7.6.3　示例　158&lt;/li&gt;
&lt;li&gt;泛化　165&lt;/li&gt;
&lt;li&gt; 8.1　形成Template Method　166&lt;/li&gt;
&lt;li&gt; 8.1.1　动机　167&lt;/li&gt;
&lt;li&gt; 8.1.2　做法　168&lt;/li&gt;
&lt;li&gt; 8.1.3　示例　168&lt;/li&gt;
&lt;li&gt; 8.2　提取Composite　173&lt;/li&gt;
&lt;li&gt; 8.2.1　动机　173&lt;/li&gt;
&lt;li&gt; 8.2.2　做法　174&lt;/li&gt;
&lt;li&gt; 8.2.3　示例　175&lt;/li&gt;
&lt;li&gt; 8.3　用Composite替换一/多之分　181&lt;/li&gt;
&lt;li&gt; 8.3.1　动机　181&lt;/li&gt;
&lt;li&gt; 8.3.2　做法　183&lt;/li&gt;
&lt;li&gt; 8.3.3　示例　184&lt;/li&gt;
&lt;li&gt; 8.4　用Observer替换硬编码的通知　191&lt;/li&gt;
&lt;li&gt; 8.4.1　动机　191&lt;/li&gt;
&lt;li&gt; 8.4.2　做法　192&lt;/li&gt;
&lt;li&gt; 8.4.3　示例　193&lt;/li&gt;
&lt;li&gt; 8.5　通过Adapter统一接口　200&lt;/li&gt;
&lt;li&gt; 8.5.1　动机　200&lt;/li&gt;
&lt;li&gt; 8.5.2　做法　201&lt;/li&gt;
&lt;li&gt; 8.5.3　示例　202&lt;/li&gt;
&lt;li&gt; 8.6　提取Adapter　209&lt;/li&gt;
&lt;li&gt; 8.6.1　动机　209&lt;/li&gt;
&lt;li&gt; 8.6.2　做法　211&lt;/li&gt;
&lt;li&gt; 8.6.3　示例　211&lt;/li&gt;
&lt;li&gt; 8.6.4　变体　217&lt;/li&gt;
&lt;li&gt; 8.7　用Interpreter替换隐式语言　218&lt;/li&gt;
&lt;li&gt; 8.7.1　动机　218&lt;/li&gt;
&lt;li&gt; 8.7.2　做法　220&lt;/li&gt;
&lt;li&gt; 8.7.3　示例　221&lt;/li&gt;
&lt;li&gt;保护　231&lt;/li&gt;
&lt;li&gt; 9.1　用类替换类型代码　232&lt;/li&gt;
&lt;li&gt; 9.1.1　动机　232&lt;/li&gt;
&lt;li&gt; 9.1.2　做法　234&lt;/li&gt;
&lt;li&gt; 9.1.3　示例　235&lt;/li&gt;
&lt;li&gt; 9.2　用Singleton限制实例化　240&lt;/li&gt;
&lt;li&gt; 9.2.1　动机　240&lt;/li&gt;
&lt;li&gt; 9.2.2　做法　241&lt;/li&gt;
&lt;li&gt; 9.2.3　示例　241&lt;/li&gt;
&lt;li&gt; 9.3　引入Null Object　243&lt;/li&gt;
&lt;li&gt; 9.3.1　动机　244&lt;/li&gt;
&lt;li&gt; 9.3.2　做法　245&lt;/li&gt;
&lt;li&gt; 9.3.3　示例　246&lt;/li&gt;
&lt;li&gt;聚集操作　251&lt;/li&gt;
&lt;li&gt; 10.1　将聚集操作搬移到Collecting Parameter　252&lt;/li&gt;
&lt;li&gt; 10.1.1　动机　252&lt;/li&gt;
&lt;li&gt; 10.1.2　做法　253&lt;/li&gt;
&lt;li&gt; 10.1.3　示例　254&lt;/li&gt;
&lt;li&gt; 10.2　将聚集操作搬移到Visitor　258&lt;/li&gt;
&lt;li&gt; 10.2.1　动机　258&lt;/li&gt;
&lt;li&gt; 10.2.2　做法　262&lt;/li&gt;
&lt;li&gt; 10.2.3　示例　266&lt;/li&gt;
&lt;li&gt;实用重构　273&lt;/li&gt;
&lt;li&gt; 11.1　链构造函数　274&lt;/li&gt;
&lt;li&gt; 11.1.1　动机　274&lt;/li&gt;
&lt;li&gt; 11.1.2　做法　275&lt;/li&gt;
&lt;li&gt; 11.1.3　示例　275&lt;/li&gt;
&lt;li&gt; 11.2　统一接口　277&lt;/li&gt;
&lt;li&gt; 11.2.1　动机　277&lt;/li&gt;
&lt;li&gt; 11.2.2　做法　278&lt;/li&gt;
&lt;li&gt; 11.2.3　示例　278&lt;/li&gt;
&lt;li&gt; 11.3　提取参数　279&lt;/li&gt;
&lt;li&gt; 11.3.1　动机　279&lt;/li&gt;
&lt;li&gt; 11.3.2　做法　279&lt;/li&gt;
&lt;li&gt; 11.3.3　示例　280&lt;/li&gt;
&lt;li&gt;跋　281&lt;/li&gt;
&lt;li&gt;参考文献　283&lt;/li&gt;
&lt;li&gt;索引　287&lt;/li&gt;
&lt;/ol&gt;

</content>
 </entry>
 
 <entry>
   <title>实现模式 读书笔记</title>
   <link href="http://www.5wpc.info/it/technical/design/2011/02/19/ImplementationPatterns"/>
   <updated>2011-02-19T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/technical/design/2011/02/19/ImplementationPatterns</id>
   <content type="html">&lt;h1&gt;简介&lt;/h1&gt;

&lt;p&gt;在《实现模式》中，作者收集了77种模式，用于处理日常编程任务，编写可读性更高的代码这个新的模式集合涵盖了开发中的诸多方面，包括类、状态、行为、方法、容器及框等。图表、故事、示例和随笔的配合使用，使作者笔下的种种模式显得异彩纷呈，从中以发现许多经受过实践检验的解决方案，小至变量命名，大到异常检查。&lt;/p&gt;

&lt;p&gt;《实现模式》包括以下内容:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;通过代码进行交流的重要性和隐藏在模式背后的思想&lt;/li&gt;
&lt;li&gt;何时创建类，如何创建类，类又是怎样书写逻辑的&lt;/li&gt;
&lt;li&gt;存储和获取状态的最佳实践&lt;/li&gt;
&lt;li&gt;行为，即用于表述逻辑（包括可选执行路径）的模式&lt;/li&gt;
&lt;li&gt;编写方法，为方法命名，以及对方法进行分解&lt;/li&gt;
&lt;li&gt;选择和使用容器&lt;/li&gt;
&lt;li&gt;实现模式在用于构建框架时的变体&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;目录&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;第1章　引言　&lt;/li&gt;
&lt;li&gt; 　1.1　导游图　&lt;/li&gt;
&lt;li&gt; 　1.2　那么，现在……　&lt;/li&gt;
&lt;li&gt;第2章　模式　&lt;/li&gt;
&lt;li&gt;第3章　一种编程理论　&lt;/li&gt;
&lt;li&gt; 　3.1　价值观　&lt;/li&gt;
&lt;li&gt; 　3.2　原则　&lt;/li&gt;
&lt;li&gt; 　3.3　小结　&lt;/li&gt;
&lt;li&gt;第4章　动机　&lt;/li&gt;
&lt;li&gt;第5章　类　&lt;/li&gt;
&lt;li&gt; 　5.1　类　&lt;/li&gt;
&lt;li&gt; 　5.2　简单的超类名　&lt;/li&gt;
&lt;li&gt; 　5.3　限定性的子类名　&lt;/li&gt;
&lt;li&gt; 　5.4　抽象接口　&lt;/li&gt;
&lt;li&gt; 　5.5　interface　&lt;/li&gt;
&lt;li&gt; 　5.6　抽象类　&lt;/li&gt;
&lt;li&gt; 　5.7　有版本的interface　&lt;/li&gt;
&lt;li&gt; 　5.8　值对象　&lt;/li&gt;
&lt;li&gt; 　5.9　特化　&lt;/li&gt;
&lt;li&gt; 　5.10　子类　&lt;/li&gt;
&lt;li&gt; 　5.11　实现器　&lt;/li&gt;
&lt;li&gt; 　5.12　内部类　&lt;/li&gt;
&lt;li&gt; 　5.13　实例特有的行为　&lt;/li&gt;
&lt;li&gt; 　5.14　条件语句　&lt;/li&gt;
&lt;li&gt; 　5.15　委派　&lt;/li&gt;
&lt;li&gt; 　5.16　可插拔的选择器　&lt;/li&gt;
&lt;li&gt; 　5.17　匿名内部类　&lt;/li&gt;
&lt;li&gt; 　5.18　库类　&lt;/li&gt;
&lt;li&gt; 　5.19　小结　&lt;/li&gt;
&lt;li&gt;第6章　状态　&lt;/li&gt;
&lt;li&gt;第7章　行为　&lt;/li&gt;
&lt;li&gt;第8章　方法　&lt;/li&gt;
&lt;li&gt;第9章　容器　&lt;/li&gt;
&lt;li&gt;第10章　改进框架　&lt;/li&gt;
&lt;li&gt;附录A　性能度量　&lt;/li&gt;
&lt;li&gt; 　A.1　示例　&lt;/li&gt;
&lt;li&gt; 　A.2　API　&lt;/li&gt;
&lt;li&gt; 　A.3　实现　&lt;/li&gt;
&lt;li&gt; 　A.4　MethodTimer　&lt;/li&gt;
&lt;li&gt; 　A.5　冲抵额外开销　&lt;/li&gt;
&lt;li&gt; 　A.6　测试　

&lt;ol&gt;
&lt;li&gt;　　A.6.1　容器的比较　&lt;/li&gt;
&lt;li&gt;　　A.6.2　ArrayList和LinkedList的比较　&lt;/li&gt;
&lt;li&gt;　　A.6.3　Set之间的比较　&lt;/li&gt;
&lt;li&gt;　　A.6.4　Map之间的比较　&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt; 　A.7　小结　&lt;/li&gt;
&lt;li&gt;参考书目&lt;/li&gt;
&lt;/ol&gt;

</content>
 </entry>
 
 <entry>
   <title>高效人士的116个IT秘诀</title>
   <link href="http://www.5wpc.info/it/living/selfmanagement/2011/02/19/ITSkills"/>
   <updated>2011-02-19T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/living/selfmanagement/2011/02/19/ITSkills</id>
   <content type="html">&lt;h1&gt;掌控电子邮件 1&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt; 秘诀1　清空收件箱（并且保持清空状态） 3&lt;/li&gt;
&lt;li&gt; 秘诀2　减少你的回复时间 6&lt;/li&gt;
&lt;li&gt; 秘诀3　打造高效的邮件 8&lt;/li&gt;
&lt;li&gt; 秘诀4　突出显示那些直接发送给你的消息 13&lt;/li&gt;
&lt;li&gt; 秘诀5　使用一次性的邮件地址 15&lt;/li&gt;
&lt;li&gt; 秘诀6　掌握消息搜索 16&lt;/li&gt;
&lt;li&gt; 秘诀7　保持长期一贯的电子邮件地址 19&lt;/li&gt;
&lt;li&gt; 秘诀8　使用Gmail合并多个电子邮件地址 21&lt;/li&gt;
&lt;li&gt; 秘诀9　为经常重复的回应建立脚本 25&lt;/li&gt;
&lt;li&gt; 秘诀10　过滤低优先级的邮件（Bacn） 27&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;组织数据 31&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt; 秘诀11　组织你的文件夹 32&lt;/li&gt;
&lt;li&gt; 秘诀12　快速访问电脑中保存的文件 35&lt;/li&gt;
&lt;li&gt; 秘诀13　全面检查你的文件柜 39&lt;/li&gt;
&lt;li&gt; 秘诀14　快速找回各种密码 41&lt;/li&gt;
&lt;li&gt; 秘诀15　安全地记录你的密码 43&lt;/li&gt;
&lt;li&gt; 秘诀16　为书签添加标签 47&lt;/li&gt;
&lt;li&gt; 秘诀17　组织你的数码照片 50&lt;/li&gt;
&lt;li&gt; 秘诀18　创建搜索结果文件夹 53&lt;/li&gt;
&lt;li&gt; 秘诀19　在PC上创建密码保护磁盘 56&lt;/li&gt;
&lt;li&gt; 秘诀20　在Mac上创建密码保护的磁盘 59&lt;/li&gt;
&lt;li&gt; 秘诀21　设计自己的计划书 60&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;第3章　高效地完成工作 63&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt; 秘诀22　让待办事项列表变得更加可行 64&lt;/li&gt;
&lt;li&gt; 秘诀23　早晨就来一次突破 68&lt;/li&gt;
&lt;li&gt; 秘诀24　为你的时间建一个构造图 69&lt;/li&gt;
&lt;li&gt; 秘诀25　快速记录你的工作日志 71&lt;/li&gt;
&lt;li&gt; 秘诀26　使用计时器快速完成工作 77&lt;/li&gt;
&lt;li&gt; 秘诀27　使用Jerry Seinfeld的链条构建新的习惯 79&lt;/li&gt;
&lt;li&gt; 秘诀28　控制你的工作日 80&lt;/li&gt;
&lt;li&gt; 秘诀29　将任务变成游戏竞赛 82&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;第4章　保持清醒的头脑 85&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt; 秘诀30　给未来的自己发送一个提醒 86&lt;/li&gt;
&lt;li&gt; 秘诀31　建立个人的Wikipedia 88&lt;/li&gt;
&lt;li&gt; 秘诀32　开发（数字）图像存储 92&lt;/li&gt;
&lt;li&gt; 秘诀33　用笔记记录重要的事情 96&lt;/li&gt;
&lt;li&gt; 秘诀34　用Remember the Milk来管理你的生活 98&lt;/li&gt;
&lt;li&gt; 秘诀35　在文本文件中整理生活信息 105&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;第5章　集中注意力 110&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt; 秘诀36　限制访问浪费时间的网站 111&lt;/li&gt;
&lt;li&gt; 秘诀37　永久性屏蔽浪费时间的网站 114&lt;/li&gt;
&lt;li&gt; 秘诀38　减少电子邮件的打扰 115&lt;/li&gt;
&lt;li&gt; 秘诀39　将工作分配到多个桌面上 117&lt;/li&gt;
&lt;li&gt; 秘诀40　建立禁飞区 121&lt;/li&gt;
&lt;li&gt; 秘诀41　清理你的桌面 123&lt;/li&gt;
&lt;li&gt; 秘诀42　让你的家更实用 125&lt;/li&gt;
&lt;li&gt; 秘诀43　把没用的东西放进“死囚区” 127&lt;/li&gt;
&lt;li&gt; 秘诀44　使用粉红噪声消除声音干扰 128&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;第6章　让日常工作更加顺畅 130&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt; 秘诀45　按三次键即可搜索网络 131&lt;/li&gt;
&lt;li&gt; 秘诀46　在键盘上给Windows发号施令 133&lt;/li&gt;
&lt;li&gt; 秘诀47　使用键盘控制你的Mac 136&lt;/li&gt;
&lt;li&gt; 秘诀48　在Windows中使用Texter减少重复输入 139&lt;/li&gt;
&lt;li&gt; 秘诀49　在Mac中使用TextExpander减少重复输入 142&lt;/li&gt;
&lt;li&gt; 秘诀50　高效的文本信息 145&lt;/li&gt;
&lt;li&gt; 秘诀51　批量更改图片大小 147&lt;/li&gt;
&lt;li&gt; 秘诀52　通过手机支付或者收款 148&lt;/li&gt;
&lt;li&gt; 秘诀53　使用BugMeNot自动注册免费网站 150&lt;/li&gt;
&lt;li&gt; 秘诀54　低速网络状况下提高网页浏览速度 152&lt;/li&gt;
&lt;li&gt; 秘诀55　安全保存网站密码 155&lt;/li&gt;
&lt;li&gt; 秘诀56　使用Google 日历成为计划高手 157&lt;/li&gt;
&lt;li&gt; 秘诀57　使用拍照手机将文本扫描为PDF文件 160&lt;/li&gt;
&lt;li&gt; 秘诀58　使用Doodle在小组中投票 163&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;第7章　自动完成重复性的劳动 166&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt; 秘诀59　自动将文件备份到外置硬盘上（PC） 167&lt;/li&gt;
&lt;li&gt; 秘诀60　自动将文件备份到外置硬盘上（Mac） 172&lt;/li&gt;
&lt;li&gt; 秘诀61　自动在线备份文件 174&lt;/li&gt;
&lt;li&gt; 秘诀62　自动清空数字垃圾文件 177&lt;/li&gt;
&lt;li&gt; 秘诀63　自动清理你的Mac电脑 181&lt;/li&gt;
&lt;li&gt; 秘诀64　自动重启电脑以及自动启动程序 183&lt;/li&gt;
&lt;li&gt; 秘诀65　自动接收Google快讯 185&lt;/li&gt;
&lt;li&gt; 秘诀66　自动下载音乐、电影和其他 186&lt;/li&gt;
&lt;li&gt; 秘诀67　自动使用电子邮件备份文件 189&lt;/li&gt;
&lt;li&gt; 秘诀68　自动升级数据表 192

&lt;h1&gt;第8章　让你的数据动起来 195&lt;/h1&gt;&lt;/li&gt;
&lt;li&gt; 秘诀69　使用基于Web的Office套件管理文档 196&lt;/li&gt;
&lt;li&gt; 秘诀70　用移动硬盘代替笔记本电脑 201&lt;/li&gt;
&lt;li&gt; 秘诀71　将你的生活携带在闪存盘中 205&lt;/li&gt;
&lt;li&gt; 秘诀72　访问网络程序以及通过文本信息搜索 209&lt;/li&gt;
&lt;li&gt; 秘诀73　使用Hamachi构建虚拟局域网 214&lt;/li&gt;
&lt;li&gt; 秘诀74　搭建家庭Web服务器 217&lt;/li&gt;
&lt;li&gt; 秘诀75　远程控制你的家庭电脑 222&lt;/li&gt;
&lt;li&gt; 秘诀76　分配给家庭电脑一个网络地址 226&lt;/li&gt;
&lt;li&gt; 秘诀77　优化你的笔记本电脑 228&lt;/li&gt;
&lt;li&gt; 秘诀78　使用iPod备份数据 231&lt;/li&gt;
&lt;li&gt; 秘诀79　把手机变成Modem 233&lt;/li&gt;
&lt;li&gt; 秘诀80　把Gmail作为网络硬盘 236&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;第9章　精通网络 239&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt; 秘诀81　专业地使用Google进行搜索 240&lt;/li&gt;
&lt;li&gt; 秘诀82　使用RSS订阅网站 243&lt;/li&gt;
&lt;li&gt; 秘诀83　为浏览器的搜索框添加搜索引擎 247&lt;/li&gt;
&lt;li&gt; 秘诀84　在地址栏进行快速搜索 249&lt;/li&gt;
&lt;li&gt; 秘诀85　扩展网络浏览器 252&lt;/li&gt;
&lt;li&gt; 秘诀86　使用DownThemAll!管理Firefox下载 254&lt;/li&gt;
&lt;li&gt; 秘诀87　收藏10个有用书签工具 257&lt;/li&gt;
&lt;li&gt; 秘诀88　发掘可重用的在线媒体 259&lt;/li&gt;
&lt;li&gt; 秘诀89　从地图上获取数据 261&lt;/li&gt;
&lt;li&gt; 秘诀90　将多个网站设置为主页 263&lt;/li&gt;
&lt;li&gt; 秘诀91　使用Google访问无法连接的网站 265&lt;/li&gt;
&lt;li&gt; 秘诀92　将浏览器的设置随身携带 266&lt;/li&gt;
&lt;li&gt; 秘诀93　查询网站信息 268&lt;/li&gt;
&lt;li&gt; 秘诀94　在Google留下自己的描述 270&lt;/li&gt;
&lt;li&gt; 秘诀95　使用Google Notebook采集网络简报 273&lt;/li&gt;
&lt;li&gt; 秘诀96　清理浏览器痕迹 274&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;第10章　磨练你的计算机求生技能 278&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt; 秘诀97　保护电脑不受恶意软件的破坏 279&lt;/li&gt;
&lt;li&gt; 秘诀98　清理启动程序 283&lt;/li&gt;
&lt;li&gt; 秘诀99　还原系统设置变更 286&lt;/li&gt;
&lt;li&gt; 秘诀100　从硬盘彻底删除文件 289&lt;/li&gt;
&lt;li&gt; 秘诀101　使用WinMerge比较和合并文件与文件夹 290&lt;/li&gt;
&lt;li&gt; 秘诀102　为PC机建立防火墙 293&lt;/li&gt;
&lt;li&gt; 秘诀103　为Mac机建立防火墙 296&lt;/li&gt;
&lt;li&gt; 秘诀104　使用闪存盘加速Windows Vista 298&lt;/li&gt;
&lt;li&gt; 秘诀105　释放硬盘空间 299&lt;/li&gt;
&lt;li&gt; 秘诀106　恢复删除的文件 301&lt;/li&gt;
&lt;li&gt; 秘诀107　创建镜像文件用于即时恢复 303&lt;/li&gt;
&lt;li&gt; 秘诀108　从无法启动的电脑上恢复文件 308&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;第11章　管理多台计算机 312&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt; 秘诀109　共享Windows文件 313&lt;/li&gt;
&lt;li&gt; 秘诀110　共享Mac文件 316&lt;/li&gt;
&lt;li&gt; 秘诀111　在计算机之间同步文件夹 319&lt;/li&gt;
&lt;li&gt; 秘诀112　在计算机之间同步浏览器书签 323&lt;/li&gt;
&lt;li&gt; 秘诀113　在计算机之间共享打印机 326&lt;/li&gt;
&lt;li&gt; 秘诀114　使用Boot Camp的同时使用Mac和Windows 329&lt;/li&gt;
&lt;li&gt; 秘诀115　优化你的双显示器系统 333&lt;/li&gt;
&lt;li&gt; 秘诀116　使用同一套鼠标键盘控制多个电脑 337&lt;/li&gt;
&lt;/ol&gt;

</content>
 </entry>
 
 <entry>
   <title>EE563GraphicsAndVisualisation</title>
   <link href="http://www.5wpc.info/it/study/dcu/2011/02/18/EE563GraphicsAndVisualisation"/>
   <updated>2011-02-18T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/study/dcu/2011/02/18/EE563GraphicsAndVisualisation</id>
   <content type="html">&lt;h1&gt;EE563GraphicsAndVisualisation&lt;/h1&gt;

&lt;h2&gt;Java2D&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Functions

&lt;ul&gt;
&lt;li&gt;Interpretation 解释(输入)

&lt;ul&gt;
&lt;li&gt;Image file format图像文件的数据结构

&lt;ul&gt;
&lt;li&gt;Header 头信息

&lt;ul&gt;
&lt;li&gt;大小(pixels)

&lt;ul&gt;
&lt;li&gt;Width长&lt;/li&gt;
&lt;li&gt;Height高&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Compression scheme 压缩方案&lt;/li&gt;
&lt;li&gt;Colour Palette调色板(图像颜色信息的编码索引)&lt;/li&gt;
&lt;li&gt;resolution 分辨率&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Data 图像数据信息&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Manipulation 操作(编辑)&lt;/li&gt;
&lt;li&gt;Display 显示(输出)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;JDK

&lt;ul&gt;
&lt;li&gt;SWT

&lt;ul&gt;
&lt;li&gt;Graphics

&lt;ul&gt;
&lt;li&gt;void setColor(Color c)&lt;/li&gt;
&lt;li&gt;void drawOval(int x, int y, int width, int height)&lt;/li&gt;
&lt;li&gt;void drawRect(int x, int y, int width, int height)&lt;/li&gt;
&lt;li&gt;void drawString(String str, int x, int y)&lt;/li&gt;
&lt;li&gt;boolean drawImage(Image img, int x, int y, ImageObserver obs)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Image

&lt;ul&gt;
&lt;li&gt;int getWidth(ImageObserver observer)&lt;/li&gt;
&lt;li&gt;int getHeight(ImageObserver observer)&lt;/li&gt;
&lt;li&gt;Graphics getGraphics()&lt;/li&gt;
&lt;li&gt;Toolkit.getDefaultToolkit().createImage(”image.jpg”);&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Processing

&lt;ul&gt;
&lt;li&gt;MemoryImageSource data = new MemoryImageSource(width, height, pixels,0,width);&lt;/li&gt;
&lt;li&gt;i = Toolkit.getDefaultToolkit (). createImage(data);&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Defining Colours

&lt;ul&gt;
&lt;li&gt;Color(float r, float g, float b, float a)&lt;/li&gt;
&lt;li&gt;Color(int r, int g, int b, int a)&lt;/li&gt;
&lt;li&gt;a:alpha 透明度,数值越大越不透明&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;2D

&lt;ul&gt;
&lt;li&gt;Graphics

&lt;ul&gt;
&lt;li&gt;Control

&lt;ul&gt;
&lt;li&gt;Geometry 各种几何图形&lt;/li&gt;
&lt;li&gt;Coordinate transformations 图形转换&lt;/li&gt;
&lt;li&gt;Colour management 颜色管理&lt;/li&gt;
&lt;li&gt;Text layout 文字层&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;anti-aliasing feature 像素模糊化

&lt;ul&gt;
&lt;li&gt;setRenderingHint(key,value)&lt;/li&gt;
&lt;li&gt;key

&lt;ul&gt;
&lt;li&gt;RenderingHints.KEY_ANTIALIASING&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;value

&lt;ul&gt;
&lt;li&gt;RenderingHints.VALUE_ANTIALIAS_ON&lt;/li&gt;
&lt;li&gt;RenderingHints.VALUE_ANTIALIAS_OFF&lt;/li&gt;
&lt;li&gt;RenderingHints.VALUE_ANTIALIAS_DEFAULT&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;BufferedImage

&lt;ul&gt;
&lt;li&gt;void setRenderingHint(RenderingHints.Key key, Object value)&lt;/li&gt;
&lt;li&gt;void scale(double sx, double sy)&lt;/li&gt;
&lt;li&gt;void rotate(double theta)&lt;/li&gt;
&lt;li&gt;void translate(double tx, double ty)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Image

&lt;ul&gt;
&lt;li&gt;BufferedImage(int width, int height, int imageType)

&lt;ul&gt;
&lt;li&gt;Type

&lt;ul&gt;
&lt;li&gt;TYPE BYTE BINARY&lt;/li&gt;
&lt;li&gt;TYPE INT ARGB&lt;/li&gt;
&lt;li&gt;TYPE INT RGB&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Process

&lt;ul&gt;
&lt;li&gt;int getRGB(int x, int y)&lt;/li&gt;
&lt;li&gt;void setRGB(int x, int y, int rgb)&lt;/li&gt;
&lt;li&gt;BufferedImage getSubImage(int x, int y, int w, int h)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;2D Transformations

&lt;ul&gt;
&lt;li&gt;Method

&lt;ul&gt;
&lt;li&gt;http://qjg-wiki.googlecode.com/files/EE563Java2DTransformationsMethod.jpg&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Scale 比例缩放

&lt;ul&gt;
&lt;li&gt;http://qjg-wiki.googlecode.com/files/EE563Java2DTransformationsScale.jpg&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Translate 移动

&lt;ul&gt;
&lt;li&gt;http://qjg-wiki.googlecode.com/files/EE563Java2DTransformationsTranslate.jpg&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Rotate 旋转

&lt;ul&gt;
&lt;li&gt;http://qjg-wiki.googlecode.com/files/EE563Java2DTransformationsRotate.jpg&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Advanced(JAI)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;VRML(Virtual Reality Markup Language )&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Coordinate System

&lt;ul&gt;
&lt;li&gt;Every point in a VRML world can be described by a set of x, y and z coordinates.&lt;/li&gt;
&lt;li&gt;http://qjg-wiki.googlecode.com/files/vrmlcoordinatesystem.gif&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Scene Graphs

&lt;ul&gt;
&lt;li&gt;node节点&lt;/li&gt;
&lt;li&gt;arc关系

&lt;ul&gt;
&lt;li&gt;DAG 树形无回路图&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Shape

&lt;ul&gt;
&lt;li&gt;Geometry&lt;/li&gt;
&lt;li&gt;Appearance&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Transformations&lt;/li&gt;
&lt;li&gt;Texture Mapping&lt;/li&gt;
&lt;li&gt;Creating Custom Geomtery

&lt;ul&gt;
&lt;li&gt;凸立方体(不能有凹面)&lt;/li&gt;
&lt;li&gt;同一个平面的点必须共面&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;Java3D&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;the scene graph programming model 场景图像编程模型

&lt;ul&gt;
&lt;li&gt;What to draw&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Data Type 数据类型

&lt;ul&gt;
&lt;li&gt;import javax.vecmath&lt;/li&gt;
&lt;li&gt;Type

&lt;ul&gt;
&lt;li&gt;Point

&lt;ul&gt;
&lt;li&gt;Point2d

&lt;ul&gt;
&lt;li&gt;A 2 element point that is represented by double precision floating point x,y coordinates&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Vector&lt;/li&gt;
&lt;li&gt;Colour

&lt;ul&gt;
&lt;li&gt;Color3b(byte r, byte g, byte b)

&lt;ul&gt;
&lt;li&gt;不透明

&lt;ul&gt;
&lt;li&gt;a=255&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Color3f

&lt;ul&gt;
&lt;li&gt;a=1.0不透明&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Color4f(float r, float g, float b, float a)

&lt;ul&gt;
&lt;li&gt;r,g,b,a in [0.0,1.0]&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;RGB model 加色法混色模型

&lt;ul&gt;
&lt;li&gt;0xRRGGBB&lt;/li&gt;
&lt;li&gt;8bits 表示 [0,255]&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Dimension 维度

&lt;ul&gt;
&lt;li&gt;2D

&lt;ul&gt;
&lt;li&gt;Text&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;3D

&lt;ul&gt;
&lt;li&gt;RGB&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;4D

&lt;ul&gt;
&lt;li&gt;3D vector + rotation 模型+旋转&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Precision 精度

&lt;ul&gt;
&lt;li&gt;byte&lt;/li&gt;
&lt;li&gt;integer&lt;/li&gt;
&lt;li&gt;float&lt;/li&gt;
&lt;li&gt;double&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Scene Graphs场景图像

&lt;ul&gt;
&lt;li&gt;DAG&lt;/li&gt;
&lt;li&gt;SceneGraphObject场景图像对象

&lt;ul&gt;
&lt;li&gt;Node

&lt;ul&gt;
&lt;li&gt;Group

&lt;ul&gt;
&lt;li&gt;BranchGroup根

&lt;ul&gt;
&lt;li&gt;Root&lt;/li&gt;
&lt;li&gt;void addBranchGraph(BranchGroup branchGroup)&lt;/li&gt;
&lt;li&gt;void removeBranchGraph(BranchGroup branchGroup)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;OrderedGroup有序集合

&lt;ul&gt;
&lt;li&gt;void addChild(Node child)&lt;/li&gt;
&lt;li&gt;void addChild(Node child, int[] childIndexOrder)&lt;/li&gt;
&lt;li&gt;int[] getChildIndexOrder()&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;TransformGroup可翻转等具有变化特性的集合

&lt;ul&gt;
&lt;li&gt;TransformGroup()&lt;/li&gt;
&lt;li&gt;TransformGroup(Transform3D transform)&lt;/li&gt;
&lt;li&gt;void setTransform(Transform3D transform)&lt;/li&gt;
&lt;li&gt;void getTransform(Transform3D transform)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Switch开关集合

&lt;ul&gt;
&lt;li&gt;Constructor

&lt;ul&gt;
&lt;li&gt;Switch()&lt;/li&gt;
&lt;li&gt;Switch(int whichChild)&lt;/li&gt;
&lt;li&gt;Switch(int whichChild, BitSet childMask)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Setter/Getter

&lt;ul&gt;
&lt;li&gt;int getWhichChild()&lt;/li&gt;
&lt;li&gt;void setWhichChild(int childSelectionValue)&lt;/li&gt;
&lt;li&gt;BitSet getChildMask()&lt;/li&gt;
&lt;li&gt;void setChildMask(BitSet childMask)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Capability

&lt;ul&gt;
&lt;li&gt;ALLOW_SWITCH_READ&lt;/li&gt;
&lt;li&gt;ALLOW_SWITCH_Write&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;SharedGroup共享集合

&lt;ul&gt;
&lt;li&gt;Subgroup

&lt;ul&gt;
&lt;li&gt;Light&lt;/li&gt;
&lt;li&gt;Link&lt;/li&gt;
&lt;li&gt;Morph&lt;/li&gt;
&lt;li&gt;Shape&lt;/li&gt;
&lt;li&gt;Sound&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ViewSpecificGroup&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Leaf

&lt;ul&gt;
&lt;li&gt;Shape3D

&lt;ul&gt;
&lt;li&gt;Constructor

&lt;ul&gt;
&lt;li&gt;Shape3D()&lt;/li&gt;
&lt;li&gt;Shape3D(Geometry geometry, Appearance appearance)&lt;/li&gt;
&lt;li&gt;It contains a list of one or more Geometry component objects and a single Appearance component object. The geometry objects define the shape node&#39;s geometric data. The appearance object specifies that object&#39;s appearance attributes, including color, material, texture, and so on.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Getter/Setter

&lt;ul&gt;
&lt;li&gt;void addGeometry(Geometry geometry)&lt;/li&gt;
&lt;li&gt;Geometry getGeometry(int index)&lt;/li&gt;
&lt;li&gt;void setAppearance(Appearance appearance)&lt;/li&gt;
&lt;li&gt;Appearance getAppearance()&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Primitives

&lt;ul&gt;
&lt;li&gt;Box&lt;/li&gt;
&lt;li&gt;Cone&lt;/li&gt;
&lt;li&gt;Cylinder&lt;/li&gt;
&lt;li&gt;Sphere&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ViewPlatform&lt;/li&gt;
&lt;li&gt;Environmental

&lt;ul&gt;
&lt;li&gt;Background

&lt;ul&gt;
&lt;li&gt;Background(Color3f backgroundColour)&lt;/li&gt;
&lt;li&gt;Background(ImageComponent2D backgroundImage)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Behaviour

&lt;ul&gt;
&lt;li&gt;void setSchedulingBounds(Bounds region)&lt;/li&gt;
&lt;li&gt;Mouse&lt;/li&gt;
&lt;li&gt;Picking&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Clip&lt;/li&gt;
&lt;li&gt;Fog

&lt;ul&gt;
&lt;li&gt;LinearFog

&lt;ul&gt;
&lt;li&gt;Colour&lt;/li&gt;
&lt;li&gt;Front distance&lt;/li&gt;
&lt;li&gt;Back distance&lt;/li&gt;
&lt;li&gt;LinearFog(Color3f colour, double frontDistance, double backDistance)&lt;/li&gt;
&lt;li&gt;物体距离与烟雾整体效果相除，查看影响因子，然后做颜色叠加&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ExponentialFog&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Lighting

&lt;ul&gt;
&lt;li&gt;DirectionalLight&lt;/li&gt;
&lt;li&gt;PointLight&lt;/li&gt;
&lt;li&gt;SpotLight

&lt;ul&gt;
&lt;li&gt;a point light source that shines in a specific direction&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;AmbientLight 漫反射光源&lt;/li&gt;
&lt;li&gt;环境光效果计算http://hi.baidu.com/fcl06/blog/item/ad858e163246fb59f2de3207.html/cmtid/ceaa4a826b25faac0df4d25b&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Sound&lt;/li&gt;
&lt;li&gt;BoundingSphere(效果范围球)

&lt;ul&gt;
&lt;li&gt;new BoundingSphere(new Point3d(), Double.MAX_VALUE)&lt;/li&gt;
&lt;li&gt;给出作用点和作用半径，这样就可以影响一定能范围的物体&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;BoundingBox(Point3d lower, Point3d upper)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;NodeComponent

&lt;ul&gt;
&lt;li&gt;Geometry

&lt;ul&gt;
&lt;li&gt;Raster (2D image)&lt;/li&gt;
&lt;li&gt;GeometryArray&lt;/li&gt;
&lt;li&gt;CompressedGeometry&lt;/li&gt;
&lt;li&gt;Defining polygons

&lt;ul&gt;
&lt;li&gt;The order of the vertices is important when defining the orientation of the polygon.&lt;/li&gt;
&lt;li&gt;Vertices of a quad must form a convex, planar polygon&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Text3D

&lt;ul&gt;
&lt;li&gt;font&lt;/li&gt;
&lt;li&gt;string&lt;/li&gt;
&lt;li&gt;path&lt;/li&gt;
&lt;li&gt;position&lt;/li&gt;
&lt;li&gt;alignment&lt;/li&gt;
&lt;li&gt;character spacing&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Appearance

&lt;ul&gt;
&lt;li&gt;Material

&lt;ul&gt;
&lt;li&gt;defines the appearance of an object under illumination, such as the ambient colour, diffuse colour, specular colour, emissive colour, and shininess.&lt;/li&gt;
&lt;li&gt;Ambient 反射环境光&lt;/li&gt;
&lt;li&gt;Diffuse 漫反射&lt;/li&gt;
&lt;li&gt;Specular 镜面反射&lt;/li&gt;
&lt;li&gt;Emissive 自身发出什么光&lt;/li&gt;
&lt;li&gt;Shininess 有光泽&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Texture

&lt;ul&gt;
&lt;li&gt;defines the texture image and filtering parameters used when tex- ture mapping is enabled.&lt;/li&gt;
&lt;li&gt;贴图纹理

&lt;ul&gt;
&lt;li&gt;texture coordinates

&lt;ul&gt;
&lt;li&gt;http://blog.csdn.net/doing5552/archive/2008/04/22/2315425.aspx&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Two modes

&lt;ul&gt;
&lt;li&gt;CLAMP 强制拉伸

&lt;ul&gt;
&lt;li&gt;force&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;WRAP 循环

&lt;ul&gt;
&lt;li&gt;repeat&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;TexCoordGeneration

&lt;ul&gt;
&lt;li&gt;defines the attributes that apply to tex- ture coordinate generation, such as whether coordinate generation is enabled, coordinate format (2D or 3D coordinates), coordinate generation mode (object linear, eye linear, or spherical reflection mapping), and the R, S and T coordi- nate plane equations.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;TextureUnitState

&lt;ul&gt;
&lt;li&gt;an array that defines the texture state for each of N separate texture units. This allows multiple textures to be applied to a geometry.&lt;/li&gt;
&lt;li&gt;Each TextureUnitState object contains a Texture object, a TextureAttributes object and a TexCoordGeneration object.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Attribute

&lt;ul&gt;
&lt;li&gt;LineAttributes

&lt;ul&gt;
&lt;li&gt;pattern&lt;/li&gt;
&lt;li&gt;width&lt;/li&gt;
&lt;li&gt;antialiasing抗锯齿&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;PointAttributes

&lt;ul&gt;
&lt;li&gt;point&lt;/li&gt;
&lt;li&gt;size&lt;/li&gt;
&lt;li&gt;antialiasing&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;PolygonAttributes

&lt;ul&gt;
&lt;li&gt;defines the attributes used to render polygons, in- cluding culling, rasterization mode (filled, lines, or points), constant offset, offset factor and whether back facing normals are flipped.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;RenderingAttributes

&lt;ul&gt;
&lt;li&gt;defines rendering operations, including the alpha test function and test value, the raster operation, whether vertex colours are ignored, whether invisible objects are rendered, and whether the depth buffer is enabled.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;TransparencyAttributes

&lt;ul&gt;
&lt;li&gt;defines the attributes that affect transparency mode (blended, screen-door), blending function (used in transparency and antialiasing operations), and a blend value that defines the amount of trans- parency to be applied.&lt;/li&gt;
&lt;li&gt;SCREEN_DOOR模式通过选择某些像素完全透明而其他完全不透明实现。完全透明的像素所占比例与指定的透明参数几近相等。BLENDED模式透明度则通过将所有像素以指定透明参数百分数透明化。（BLENDED transparency is achieved by having all pixels be paririally transparent int the percentage specified by the transparency parameter.）混合方程由srcBlendFunction和dstBlendFunction属性指定。

&lt;ul&gt;
&lt;li&gt;The SCREEN_DOOR mode creates gaps in the foreground colour to simulate different levels of transparency. The BLENDED mode blends the foreground and background colours to generate a more accurate and visually appealing result.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;http://hi.baidu.com/straybirdsnest/blog/item/a02225429c0068046a63e57f.html&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ColoringAttributes

&lt;ul&gt;
&lt;li&gt;Color selection&lt;/li&gt;
&lt;li&gt;Shading底纹&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;TextureAttributes

&lt;ul&gt;
&lt;li&gt;defines the attributes that apply to texture mapping, such as the texture mode, texture transform, blend colour, and perspective correction mode&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;VirtualUniverse, Locale and SimpleUniverse&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;PickTool

&lt;ul&gt;
&lt;li&gt;PickCanvas

&lt;ul&gt;
&lt;li&gt;A tolerance of 0.0 may speedup picking slightly, but also make it very difficult to pick points and lines.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Behaviour

&lt;ul&gt;
&lt;li&gt;DistanceLOD&lt;/li&gt;
&lt;li&gt;MouseZoom&lt;/li&gt;
&lt;li&gt;Billboard&lt;/li&gt;
&lt;li&gt;PositionInterpolator&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;System Architecture

&lt;ul&gt;
&lt;li&gt;Threads

&lt;ul&gt;
&lt;li&gt;System

&lt;ul&gt;
&lt;li&gt;Reference Handler&lt;/li&gt;
&lt;li&gt;Finalizer&lt;/li&gt;
&lt;li&gt;Signal Dispatcher&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Main

&lt;ul&gt;
&lt;li&gt;Main&lt;/li&gt;
&lt;li&gt;AWT-EventQueue0&lt;/li&gt;
&lt;li&gt;SunToolkit.PostEventQueue-0&lt;/li&gt;
&lt;li&gt;AWT-Windows&lt;/li&gt;
&lt;li&gt;Image Fetcher 1&lt;/li&gt;
&lt;li&gt;Image Fetcher 0&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Java3D

&lt;ul&gt;
&lt;li&gt;MasterControl

&lt;ul&gt;
&lt;li&gt;管理消息转发与线程调度&lt;/li&gt;
&lt;li&gt;J3dMessage&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;BehaviorScheduler&lt;/li&gt;
&lt;li&gt;InputDeviceScheduler&lt;/li&gt;
&lt;li&gt;Render

&lt;ul&gt;
&lt;li&gt;J3D-Renderer-INSTANCE&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;StructureUpdateThread

&lt;ul&gt;
&lt;li&gt;Geometry&lt;/li&gt;
&lt;li&gt;Render&lt;/li&gt;
&lt;li&gt;Behavior&lt;/li&gt;
&lt;li&gt;Sound&lt;/li&gt;
&lt;li&gt;RenderingAttributes&lt;/li&gt;
&lt;li&gt;RenderingEnvironment&lt;/li&gt;
&lt;li&gt;Transform&lt;/li&gt;
&lt;li&gt;SoundScheduler&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;TimerThread&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;实际应用&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;CT

&lt;ul&gt;
&lt;li&gt;MCA 利用切面构造三角形&lt;/li&gt;
&lt;li&gt;Volume Rendering 体构造&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;OpenGL&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Install

&lt;ul&gt;
&lt;li&gt;Ubuntu

&lt;ul&gt;
&lt;li&gt;http://stackoverflow.com/questions/859501/learning-opengl-in-ubuntu&lt;/li&gt;
&lt;li&gt;http://ubuntuforums.org/showthread.php?t=375425&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Libs

&lt;ul&gt;
&lt;li&gt;-lglut -lGLU&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;tags: 3D&lt;/h2&gt;
</content>
 </entry>
 
 <entry>
   <title>EE500PerformanceofDataNetworks</title>
   <link href="http://www.5wpc.info/it/study/dcu/2011/02/17/EE500PerformanceofDataNetworks"/>
   <updated>2011-02-17T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/study/dcu/2011/02/17/EE500PerformanceofDataNetworks</id>
   <content type="html">&lt;h1&gt;EE500PerformanceofDataNetworks&lt;/h1&gt;

&lt;h2&gt;background&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Hierarchy of Layer

&lt;ul&gt;
&lt;li&gt;Modularity模块化&lt;/li&gt;
&lt;li&gt;Protocol协议化&lt;/li&gt;
&lt;li&gt;Interfaces接口化&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Example

&lt;ul&gt;
&lt;li&gt;OSI&lt;/li&gt;
&lt;li&gt;TCP/IP&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Five Layer factors

&lt;ul&gt;
&lt;li&gt;Physical

&lt;ul&gt;
&lt;li&gt;signal

&lt;ul&gt;
&lt;li&gt;bandwidth

&lt;ul&gt;
&lt;li&gt;Signal&lt;/li&gt;
&lt;li&gt;Channel&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Problems

&lt;ul&gt;
&lt;li&gt;noise

&lt;ul&gt;
&lt;li&gt;crosstalk串线&lt;/li&gt;
&lt;li&gt;impulse noise叠加&lt;/li&gt;
&lt;li&gt;thermal or white noise物理设备热辐射&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;signal attenuation信号辐射&lt;/li&gt;
&lt;li&gt;signal distortion信号失真&lt;/li&gt;
&lt;li&gt;delay distortion延迟失真&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Capacity 有效载荷

&lt;ul&gt;
&lt;li&gt;香农定律&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Converting bits into signals

&lt;ul&gt;
&lt;li&gt;Way

&lt;ul&gt;
&lt;li&gt;DC/lowpass矩形波

&lt;ul&gt;
&lt;li&gt;Encoding Schemes

&lt;ul&gt;
&lt;li&gt;NRZ(Non-Return-Zero)&lt;/li&gt;
&lt;li&gt;Bipolar&lt;/li&gt;
&lt;li&gt;Manchester&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;http://qjg-wiki.googlecode.com/files/DCLowpass.jpg&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Bandpass/Modulated叠加正弦波(Ignore Low Frequence)

&lt;ul&gt;
&lt;li&gt;Modulation techniques

&lt;ul&gt;
&lt;li&gt;ASK&lt;/li&gt;
&lt;li&gt;FSK&lt;/li&gt;
&lt;li&gt;PSK&lt;/li&gt;
&lt;li&gt;DPSK&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Switching and multiplexing

&lt;ul&gt;
&lt;li&gt;Switch

&lt;ul&gt;
&lt;li&gt;Circuit&lt;/li&gt;
&lt;li&gt;Packet

&lt;ul&gt;
&lt;li&gt;Virtual Circuit&lt;/li&gt;
&lt;li&gt;Datagram&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Multiplexing

&lt;ul&gt;
&lt;li&gt;FDM&lt;/li&gt;
&lt;li&gt;TDM&lt;/li&gt;
&lt;li&gt;Statistical

&lt;ul&gt;
&lt;li&gt;Framing&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Data Link

&lt;ul&gt;
&lt;li&gt;Framing&lt;/li&gt;
&lt;li&gt;Detecting and correcting errors

&lt;ul&gt;
&lt;li&gt;FEC

&lt;ul&gt;
&lt;li&gt;CRC&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;BEC&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Controlling data flow

&lt;ul&gt;
&lt;li&gt;Stop and wait

&lt;ul&gt;
&lt;li&gt;ARQ&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Sliding window

&lt;ul&gt;
&lt;li&gt;ARQ&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Network

&lt;ul&gt;
&lt;li&gt;Routing&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Transport

&lt;ul&gt;
&lt;li&gt;TCP&lt;/li&gt;
&lt;li&gt;UDP&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Application&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;QoS&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;the collective effect of service performance which determine the degree of satisfaction of a user of the service&lt;/li&gt;
&lt;li&gt;SLA(Service Level Agreement)服务级别许可

&lt;ul&gt;
&lt;li&gt;Service Level Objectives (SLO)要求

&lt;ul&gt;
&lt;li&gt;Parameters

&lt;ul&gt;
&lt;li&gt;Availability可靠性

&lt;ul&gt;
&lt;li&gt;the percentage of the feasibility of service in every particular service request 成功服务率&lt;/li&gt;
&lt;li&gt;availability of service is the key parameter that customers are interested in&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Delivery 传输稳定性

&lt;ul&gt;
&lt;li&gt;the converse of packet loss, which means that a percentage of each service is delivered without packet loss 成功传输率&lt;/li&gt;
&lt;li&gt;packet delay 数据包延迟&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Latency 延迟

&lt;ul&gt;
&lt;li&gt;the time taken for a packet to travel from a service access point (SAP) to a distant target and back&lt;/li&gt;
&lt;li&gt;it usually includes the transport time and queuing delay.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Bandwidth 带宽

&lt;ul&gt;
&lt;li&gt;means the used capacity or available capacity – stated in the SLA&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;MTBF (Mean Time Between Failure)&lt;/li&gt;
&lt;li&gt;MTRS (Mean Time to Restore Service)

&lt;ul&gt;
&lt;li&gt;The average time that a device will take to recover from any failure&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Service Level Guarantees (SLG)保证

&lt;ul&gt;
&lt;li&gt;QoS Viewpoint

&lt;ul&gt;
&lt;li&gt;http://qjg-wiki.googlecode.com/files/FourViewpointOfQoS.jpg&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Service Level Management (SLM) 管理

&lt;ul&gt;
&lt;li&gt;http://qjg-wiki.googlecode.com/files/QoSSLMImg.jpg&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;传输层

&lt;ul&gt;
&lt;li&gt;TCP

&lt;ul&gt;
&lt;li&gt;可靠分组连接服务

&lt;ul&gt;
&lt;li&gt;分组大小

&lt;ul&gt;
&lt;li&gt;MSS(Maximum Segment Size)

&lt;ul&gt;
&lt;li&gt;Segment Header

&lt;ul&gt;
&lt;li&gt;TCP Header(20bytes)&lt;/li&gt;
&lt;li&gt;IP Header(20bytes)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;越大效率越高，主要问题是每一段都需要附带一个包头。段越多，包头越多。整体上效率越低。&lt;/li&gt;
&lt;li&gt;连接时确定&lt;/li&gt;
&lt;li&gt;由SYN Segment携带&lt;/li&gt;
&lt;li&gt;Default Value=534bytes&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;失效重发

&lt;ul&gt;
&lt;li&gt;重发的时间控制

&lt;ul&gt;
&lt;li&gt;RTO(Retransmission TimeOut)

&lt;ul&gt;
&lt;li&gt;由RTT(Round trip time)确定初值&lt;/li&gt;
&lt;li&gt;由SRTT(Smoothed estimator)估计

&lt;ul&gt;
&lt;li&gt;low-pass filter&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;2次指数增长

&lt;ul&gt;
&lt;li&gt;1,3,7,15,31,63&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Keepalive Timer

&lt;ul&gt;
&lt;li&gt;如果在一个时间段内全部为失败，则需要重置连接&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;http://wwuyingjie.blog.51cto.com/309671/109553&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;拥塞控制

&lt;ul&gt;
&lt;li&gt;慢启动

&lt;ul&gt;
&lt;li&gt;确定传输时候的参数(网络承载能力)

&lt;ul&gt;
&lt;li&gt;Congestion window (cwnd)&lt;/li&gt;
&lt;li&gt;Receiver window (rwnd)&lt;/li&gt;
&lt;li&gt;Slow start threshold (ssthresh)&lt;/li&gt;
&lt;li&gt;Sender Maximum Segment Size (SMSS)&lt;/li&gt;
&lt;li&gt;FlightSize&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;冲突处理

&lt;ul&gt;
&lt;li&gt;发生

&lt;ul&gt;
&lt;li&gt;发送端超时&lt;/li&gt;
&lt;li&gt;数据包冲突&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;快速重传&lt;/li&gt;
&lt;li&gt;快速恢复&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;具体实现

&lt;ul&gt;
&lt;li&gt;http://jasonccie.blog.51cto.com/2143955/422966&lt;/li&gt;
&lt;li&gt;Tahoe(原始)

&lt;ul&gt;
&lt;li&gt;无快速恢复&lt;/li&gt;
&lt;li&gt;无快速重传&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Reno

&lt;ul&gt;
&lt;li&gt;添加了快速恢复&lt;/li&gt;
&lt;li&gt;对丢包进行分类

&lt;ul&gt;
&lt;li&gt;超时&lt;/li&gt;
&lt;li&gt;ACK&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;New Reno

&lt;ul&gt;
&lt;li&gt;调整重传机制&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;SACK

&lt;ul&gt;
&lt;li&gt;调整块大小&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Vegas&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;SCTP

&lt;ul&gt;
&lt;li&gt;用途

&lt;ul&gt;
&lt;li&gt;无线&lt;/li&gt;
&lt;li&gt;手机&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Need

&lt;ul&gt;
&lt;li&gt;Multi-Streaming&lt;/li&gt;
&lt;li&gt;Multi-Homing&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Features

&lt;ul&gt;
&lt;li&gt;Reliable transport protocol

&lt;ul&gt;
&lt;li&gt;可靠&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Use association instread of connection

&lt;ul&gt;
&lt;li&gt;关联&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Design for message oriented application

&lt;ul&gt;
&lt;li&gt;面向消息应用的设计&lt;/li&gt;
&lt;li&gt;块绑定&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Acknowledge error free transfer of message&lt;/li&gt;
&lt;li&gt;Detection of data corruption, data loss and data duplication&lt;/li&gt;
&lt;li&gt;Selective retransmission to correct lost data and duplicated data

&lt;ul&gt;
&lt;li&gt;选择性ACK&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Active monitoring of session connectivity via heartbeat&lt;/li&gt;
&lt;li&gt;Resistance to denial of service attacks

&lt;ul&gt;
&lt;li&gt;抵抗DDOS&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Supports multi-streaming&lt;/li&gt;
&lt;li&gt;Supports multi-homing&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;http://blogold.chinaunix.net/u1/34831/showart_1871853.html&lt;/li&gt;
&lt;li&gt;Message Format

&lt;ul&gt;
&lt;li&gt;http://qjg-wiki.googlecode.com/files/SCTP-Header.jpg&lt;/li&gt;
&lt;li&gt;http://qjg-wiki.googlecode.com/files/SCTP-Chunks.jpg&lt;/li&gt;
&lt;li&gt;http://qjg-wiki.googlecode.com/files/SCTP-Chunk-Important.jpg&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Association Establishment Procedure

&lt;ul&gt;
&lt;li&gt;http://qjg-wiki.googlecode.com/files/SCTP-Connection-Steps.jpg&lt;/li&gt;
&lt;li&gt;:&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Steps:
1. Assume Endpoint A initiates association establishment with endpoint B
1. A sends an INIT chunk and enters the COOKIE WAIT state
1. A starts an INIT timer whose timeout determines resending of the INIT chunk
1. B receives the INIT chunk and reads chunk data
1. Based on the data, B generates a secure hash code using a secret key
1. The generated values are placed into a COOKIE chunk, along with the derived message authentication code (MAC)
1. The cookie is sent to A in an INIT-ACK chunk
1. B remains in CLOSED state
1. A receives the INIT-ACK chunk and stops the INIT timer
1. A places the cookie from the INIT-ACK chunk in a COOKIE ECHO chunk returned to B
1. A COOKIE ECHO timer is started whose timeout determines resending of COOKIE ECHO
1. A enters the COOKIE ECHOED STATE
1. B receives the echoed cookie and uses MAC to verify it If OK, B initialises the SCTP instance
1. B responds with a COOKIE-ACK chunk
1. Both A and B endpoints enter the ESTABLISHED state&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  * Mobile SCTP
    * Adds Dynamic Address Reconfiguration (ADDIP) 
      * Enables SCTP to add, delete, and change existing IP addresses attached to an association during an active connection
      * Enables support for seamless handover for mobile hosts that are moving between IP networks 
    * Uses ASCONF and ASCONF-ACK chunks 
      * Add new IP address to the association 
      * Change the primary IP address of the association 
      * Delete an old IP address from the association 
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;UDP

&lt;ul&gt;
&lt;li&gt;DCCP

&lt;ul&gt;
&lt;li&gt;Features

&lt;ul&gt;
&lt;li&gt;Supports unreliable transport of datagram flows&lt;/li&gt;
&lt;li&gt;Provides acknowledgements&lt;/li&gt;
&lt;li&gt;A reliable handshake for connection setup and teardown&lt;/li&gt;
&lt;li&gt;Reliable negotiation of features&lt;/li&gt;
&lt;li&gt;A choice of TCP-friendly congestion control mechanisms

&lt;ul&gt;
&lt;li&gt;TCP-like congestion control [RFC 2581] (CCID 2)

&lt;ul&gt;
&lt;li&gt;appropriate for flows wishing to quickly take advantage of available bandwidth&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;TCP-Friendly Rate Control [RFC 3448] (CCID 3)

&lt;ul&gt;
&lt;li&gt;appropriate for flows that require a steadier sent rate&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Options to tell reliably the sender which packets reached the receiver

&lt;ul&gt;
&lt;li&gt;and if lost packets were ECN marked, corrupted, or dropped in the receive buffer&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Congestion control including Explicit Congestion Notification (ECN) and ECN Nonce&lt;/li&gt;
&lt;li&gt;Mechanisms to avoid holding state for unacknowledged connection attempts or finished connections&lt;/li&gt;
&lt;li&gt;No graceful close, no other flow control apart from congestion control&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;Network Performance Metrics&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Availablity

&lt;ul&gt;
&lt;li&gt;Connectivity&lt;/li&gt;
&lt;li&gt;Functionality&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Loss

&lt;ul&gt;
&lt;li&gt;One Way Loss&lt;/li&gt;
&lt;li&gt;RT(Round Trip) Loss&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Delay

&lt;ul&gt;
&lt;li&gt;One Way Delay&lt;/li&gt;
&lt;li&gt;RT Delay&lt;/li&gt;
&lt;li&gt;Delay Variance&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Utilization

&lt;ul&gt;
&lt;li&gt;Capacity&lt;/li&gt;
&lt;li&gt;Bandwidth&lt;/li&gt;
&lt;li&gt;Throughput&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;http://qjg-wiki.googlecode.com/files/QoSParametertoNPMMapping.jpg&lt;/li&gt;
&lt;li&gt;Measurement method

&lt;ul&gt;
&lt;li&gt;Active

&lt;ul&gt;
&lt;li&gt;Mechanism

&lt;ul&gt;
&lt;li&gt;Generate test traffic periodicaly or on-demand&lt;/li&gt;
&lt;li&gt;Measure performance of test packet response&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Method

&lt;ul&gt;
&lt;li&gt;ICMP

&lt;ul&gt;
&lt;li&gt;Find problem&lt;/li&gt;
&lt;li&gt;RT Loss&lt;/li&gt;
&lt;li&gt;RT Delay&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;TCP

&lt;ul&gt;
&lt;li&gt;Bandwidth&lt;/li&gt;
&lt;li&gt;Rate&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;UDP

&lt;ul&gt;
&lt;li&gt;One way loss&lt;/li&gt;
&lt;li&gt;RT bandwidth&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Factors

&lt;ul&gt;
&lt;li&gt;Multi-point&lt;/li&gt;
&lt;li&gt;Small data size&lt;/li&gt;
&lt;li&gt;Additional traffic&lt;/li&gt;
&lt;li&gt;For Delay, packet loss,  availability&lt;/li&gt;
&lt;li&gt;Low to Moderate CPU&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Passive

&lt;ul&gt;
&lt;li&gt;Mechanism

&lt;ul&gt;
&lt;li&gt;Capture the traffic by mirroring or splitting&lt;/li&gt;
&lt;li&gt;Analyze the captured packets&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Method

&lt;ul&gt;
&lt;li&gt;SNMP&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Factors

&lt;ul&gt;
&lt;li&gt;Single or multi point&lt;/li&gt;
&lt;li&gt;Large data size&lt;/li&gt;
&lt;li&gt;Device overload/no overlod with splitter&lt;/li&gt;
&lt;li&gt;For Throughput, traffic pattern, trend and detection&lt;/li&gt;
&lt;li&gt;High CPU usage&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;测量方法的缺点

&lt;ul&gt;
&lt;li&gt;Active Measurements - problems 主动测量的问题

&lt;ul&gt;
&lt;li&gt;Path Asymmetry 路径不一致，发送与接收路径就有可能有不同

&lt;ul&gt;
&lt;li&gt;Nodes visited by traceroute are those in &#39;forward&#39; path, which are not necessary the same as &#39;reverse&#39; path&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Unstable Paths and False Edges 发送的路径不稳定，有些节点可能已经失效

&lt;ul&gt;
&lt;li&gt;Traceroute reports nodes visited by successive probe packets with increasing TTL. Discovered IP path is only valid if the path being measured does not change during measurement process.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Alias Resolution 同一个设备可能有多个标示

&lt;ul&gt;
&lt;li&gt;Traceroute discovers &#39;interfaces&#39; rather than &#39;routers&#39; 不仅仅是路由，还有很多是接口&lt;/li&gt;
&lt;li&gt;Nodes can have multiple network interfaces, each with different IP address 同一个节点可能含有多个网卡&lt;/li&gt;
&lt;li&gt;Source IP address in ICMP &#39;time exceeded&#39; response packets is the address of the interface that the router uses to send packets back.&lt;/li&gt;
&lt;li&gt;If both interfaces belong to the same router, responses will be sent by one interface =&gt; we can match ECHO responses from trace route to both IP address. If the response comes from the same source interface, we infer that both interfaces belong to the same router&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Measurement load 用于测量的负载

&lt;ul&gt;
&lt;li&gt;Sometimes RTT for TTL=n could be smaller than TTL=n‐1&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Passive Measurements - challenges 被动测量的挑战

&lt;ul&gt;
&lt;li&gt;Large volume of measurement data 大量需要测量的数据

&lt;ul&gt;
&lt;li&gt;Challenges in storing and processing data 存储与处理数据&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Privacy issues 隐私问题&lt;/li&gt;
&lt;li&gt;Collection of detailed traffic statistics from heterogeneous network links. 异构网络详细统计间有冲突&lt;/li&gt;
&lt;li&gt;Non‐interference with the measured network (nonintrusiveness). 存在很多不允许干扰的网络&lt;/li&gt;
&lt;li&gt;Obtaining a global view of the monitored network from a reasonable number of monitoring points. 如何由一部分来考察整体&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Performance

&lt;ul&gt;
&lt;li&gt;Packet loss rate&lt;/li&gt;
&lt;li&gt;Latency&lt;/li&gt;
&lt;li&gt;Jitter&lt;/li&gt;
&lt;li&gt;Throughput&lt;/li&gt;
&lt;li&gt;Available bandwidth; bottleneck bandwidth&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;Modeling and Simulations&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Modeling

&lt;ul&gt;
&lt;li&gt;Motivation

&lt;ul&gt;
&lt;li&gt;Understanding and predicting complex system behaviours

&lt;ul&gt;
&lt;li&gt;Ignore

&lt;ul&gt;
&lt;li&gt;environment&lt;/li&gt;
&lt;li&gt;Input&lt;/li&gt;
&lt;li&gt;Output&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Building real time system

&lt;ul&gt;
&lt;li&gt;Expensive&lt;/li&gt;
&lt;li&gt;Require personnel&lt;/li&gt;
&lt;li&gt;Difficult to modify&lt;/li&gt;
&lt;li&gt;Not sure how&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Benefit

&lt;ul&gt;
&lt;li&gt;Allows for investigation of the properties of the system&lt;/li&gt;
&lt;li&gt;Enables prediction of future system behavior and outputs&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;As a solution

&lt;ul&gt;
&lt;li&gt;Reduced complex&lt;/li&gt;
&lt;li&gt;Important characteristics only&lt;/li&gt;
&lt;li&gt;Cheaper&lt;/li&gt;
&lt;li&gt;Highly modifiable&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Limitation

&lt;ul&gt;
&lt;li&gt;Accuracy

&lt;ul&gt;
&lt;li&gt;Parameters&lt;/li&gt;
&lt;li&gt;Initial Conditions&lt;/li&gt;
&lt;li&gt;Environment influence&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Most models are inherently inexact (due to the simplifications and assumptions made)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Definition

&lt;ul&gt;
&lt;li&gt;Process of building a model&lt;/li&gt;
&lt;li&gt;Designing and analyzing a representation of a system to study the effect changes to system variables have

&lt;ul&gt;
&lt;li&gt;Simulation&lt;/li&gt;
&lt;li&gt;Analysis&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Type

&lt;ul&gt;
&lt;li&gt;Variables

&lt;ul&gt;
&lt;li&gt;Deterministic: all variables are deterministic&lt;/li&gt;
&lt;li&gt;Stochastic: some model variables or behavior are random&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Model

&lt;ul&gt;
&lt;li&gt;Static: the model does not change in time&lt;/li&gt;
&lt;li&gt;Dynamic: the model is modified in time&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Time

&lt;ul&gt;
&lt;li&gt;Continuous: the system state evolve continuously&lt;/li&gt;
&lt;li&gt;Discrete: the system state changes at discrete points in time&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Stages

&lt;ul&gt;
&lt;li&gt;A

&lt;ul&gt;
&lt;li&gt;Simplification and abstractisation

&lt;ul&gt;
&lt;li&gt;A model contains essential characteristics of real-life objects or events&lt;/li&gt;
&lt;li&gt;This stage identifies relevant features of the real system to be modeled&lt;/li&gt;
&lt;li&gt;Assumptions are made&lt;/li&gt;
&lt;li&gt;Input parameters are determined&lt;/li&gt;
&lt;li&gt;Output measures are listed&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Representation and Measurements

&lt;ul&gt;
&lt;li&gt;Objects, events, numbers and relationships in the real system are associated model components&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Manipulation

&lt;ul&gt;
&lt;li&gt;Implications of real world objects and relationships are determined&lt;/li&gt;
&lt;li&gt;New objects and relationships are represented&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Verification

&lt;ul&gt;
&lt;li&gt;Outcomes from the model are compared with real word outcome&lt;/li&gt;
&lt;li&gt;It is determined if the model is adequate for the desired purpose&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;B

&lt;ul&gt;
&lt;li&gt;Determine goals and objectives

&lt;ul&gt;
&lt;li&gt;Level of abstractisation&lt;/li&gt;
&lt;li&gt;Relevant features to be modelled&lt;/li&gt;
&lt;li&gt;Required input and expected output&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Build a conceptual model

&lt;ul&gt;
&lt;li&gt;Very high level&lt;/li&gt;
&lt;li&gt;Determines how comprehensive the model will be&lt;/li&gt;
&lt;li&gt;Determines state variables; if they are dynamic, how important they are, etc.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Create the specification model

&lt;ul&gt;
&lt;li&gt;Average detailed level&lt;/li&gt;
&lt;li&gt;May involve equations, pseudocode, etc.&lt;/li&gt;
&lt;li&gt;Indicates input and output&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Convert into a computational model

&lt;ul&gt;
&lt;li&gt;Low detail level&lt;/li&gt;
&lt;li&gt;Involves a general purpose or a simulation programming language&lt;/li&gt;
&lt;li&gt;It is the actual useful model&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Verification and validation

&lt;ul&gt;
&lt;li&gt;(Verification)Did we build the model right? (according to specifications) 确认&lt;/li&gt;
&lt;li&gt;(Validation )Did we build the right model? (relative to the real system) 证实&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;Android&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Architecture

&lt;ul&gt;
&lt;li&gt;http://qjg-wiki.googlecode.com/files/Android-system-architecture.jpg&lt;/li&gt;
&lt;li&gt;Android Runtime Layer

&lt;ul&gt;
&lt;li&gt;Core Libraries – provide the functionality of JAVA Programming Language&lt;/li&gt;
&lt;li&gt;Android Applications runs in its own process, with its own instance of the Dalvik Virtual machine&lt;/li&gt;
&lt;li&gt;Dalvik VM: Java based license free VM

&lt;ul&gt;
&lt;li&gt;Register based VM, optimization for low memory requirements&lt;/li&gt;
&lt;li&gt;Executes files in the Dalvik Executable (.dex) format&lt;/li&gt;
&lt;li&gt;DX tool converts classes to .dex format&lt;/li&gt;
&lt;li&gt;Relies on the Linux Kernel for underlying functionality: threading and low-level memory management&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;Performance at Higher Network Layers&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;QOE

&lt;ul&gt;
&lt;li&gt;Definition

&lt;ul&gt;
&lt;li&gt;Subjective measure of a user’s experience with a service&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Areas

&lt;ul&gt;
&lt;li&gt;Service&lt;/li&gt;
&lt;li&gt;User&lt;/li&gt;
&lt;li&gt;Device&lt;/li&gt;
&lt;li&gt;Network&lt;/li&gt;
&lt;li&gt;Cost&lt;/li&gt;
&lt;li&gt;Content and Context&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Improving

&lt;ul&gt;
&lt;li&gt;Transport Layer Solutions

&lt;ul&gt;
&lt;li&gt;RTP/RTCP

&lt;ul&gt;
&lt;li&gt;Provide

&lt;ul&gt;
&lt;li&gt;End-to-end delivery mechanism for real-time multimedia traffic&lt;/li&gt;
&lt;li&gt;Sequence numbering and time-stamping of packets in the stream&lt;/li&gt;
&lt;li&gt;Payload type identification&lt;/li&gt;
&lt;li&gt;Supports multicast distribution&lt;/li&gt;
&lt;li&gt;Monitoring of Quality of Service (QoS) of delivery&lt;/li&gt;
&lt;li&gt;Identification of different sources of traffic within an application session&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;http://zhangjunhd.blog.51cto.com/113473/25481&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Application Layer Solutions

&lt;ul&gt;
&lt;li&gt;RTSP&lt;/li&gt;
&lt;li&gt;QOAS&lt;/li&gt;
&lt;li&gt;RAP&lt;/li&gt;
&lt;li&gt;LQA&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;Performance at Lower Network Layers&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Internet

&lt;ul&gt;
&lt;li&gt;Router

&lt;ul&gt;
&lt;li&gt;Algorithm

&lt;ul&gt;
&lt;li&gt;Distance Vector&lt;/li&gt;
&lt;li&gt;Link State&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Protocol

&lt;ul&gt;
&lt;li&gt;IPv4&lt;/li&gt;
&lt;li&gt;IPv6&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Physical

&lt;ul&gt;
&lt;li&gt;Wireless

&lt;ul&gt;
&lt;li&gt;PANs

&lt;ul&gt;
&lt;li&gt;Bluetooth&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;LANs

&lt;ul&gt;
&lt;li&gt;WiFi&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;MANs

&lt;ul&gt;
&lt;li&gt;WiMAX&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;Mobility Issues&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Moblie IP

&lt;ul&gt;
&lt;li&gt;Features

&lt;ul&gt;
&lt;li&gt;Enables dynamical point of network attachment change with host location change&lt;/li&gt;
&lt;li&gt;Maintains all network connections&lt;/li&gt;
&lt;li&gt;Enables hosts to be tracked without changing their IP addresses&lt;/li&gt;
&lt;li&gt;Requires no software changes in any non-mobile hosts or routers&lt;/li&gt;
&lt;li&gt;Requires additional infrastructure&lt;/li&gt;
&lt;li&gt;Requires no modifications to IP addresses or IP address format&lt;/li&gt;
&lt;li&gt;Supports security&lt;/li&gt;
&lt;li&gt;Standardised by the Internet Engineering Task Force (IETF)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Nodes     移动节点（MN）、家乡代理（HA）、通信节点（CN）。其中MN为移动终端；HA位于家乡子网，负责记录MN的当前位置，并将发往MN的数据转发至MN的当前位置；CN为与MN通信的对端节点。

&lt;ul&gt;
&lt;li&gt;Mobile Node (MN)

&lt;ul&gt;
&lt;li&gt;A host that changes its point of attachment from one network or subnetwork to another&lt;/li&gt;
&lt;li&gt;Assigned a permanent IP address (called home address) which does not change&lt;/li&gt;
&lt;li&gt;All other hosts send packets to the home address regardless of mobile node’ s location&lt;/li&gt;
&lt;li&gt;It continues to communicate with other hosts via the network at current location&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Home Agent (HA)

&lt;ul&gt;
&lt;li&gt;A router with additional functionality&lt;/li&gt;
&lt;li&gt;Located on the home network of MN&lt;/li&gt;
&lt;li&gt;Maintains current location information of MN&lt;/li&gt;
&lt;li&gt;Performs mobility binding of MN’ s home address with temporary IP address dependent on current location&lt;/li&gt;
&lt;li&gt;Forwards packets (tunnels) to the appropriate network when MN is away&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Foreign Agent (FA)

&lt;ul&gt;
&lt;li&gt;A router on a MN&#39;s visited network with enhanced functionality&lt;/li&gt;
&lt;li&gt;Advertises itself periodically&lt;/li&gt;
&lt;li&gt;Accepts MN registration requests&lt;/li&gt;
&lt;li&gt;Sends a care-of-address (CoA) (usually FA’ s IP address) to HA when a MN registers&lt;/li&gt;
&lt;li&gt;Provides routing services to the MN while registered

&lt;ul&gt;
&lt;li&gt;The foreign agent detunnels and delivers datagrams tunneled by HA to the MN&lt;/li&gt;
&lt;li&gt;Routes all datagrams sent by MN&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Correspondent Node (CN)

&lt;ul&gt;
&lt;li&gt;End-host with which MN communicates (e.g. a web server, another host)&lt;/li&gt;
&lt;li&gt;Can be located anywhere&lt;/li&gt;
&lt;li&gt;Can be mobile or stationary&lt;/li&gt;
&lt;li&gt;Is not aware of the fact that MN is changing location&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Hierarchical Mobile IPv6 (HMIPv6)

&lt;ul&gt;
&lt;li&gt;Principles

&lt;ul&gt;
&lt;li&gt;Frequent handovers increase the BU overhead&lt;/li&gt;
&lt;li&gt;Increased delay if CN is located far away from the MN&lt;/li&gt;
&lt;li&gt;Hierarchical Mobile IPv6 organizes the network hierarchically&lt;/li&gt;
&lt;li&gt;Separate mobility management in local mobility and global mobility&lt;/li&gt;
&lt;li&gt;Mobility anchor point (MAP) manages local mobility&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Handover Procedure

&lt;ul&gt;
&lt;li&gt;MN (at home) communicates with CN&lt;/li&gt;
&lt;li&gt;MN moves to new network (Stage 1)&lt;/li&gt;
&lt;li&gt;MN registers its CoA with HA (Stage 2)&lt;/li&gt;
&lt;li&gt;MN registers its CoA with MAP (Stage 3)&lt;/li&gt;
&lt;li&gt;MN moves to new network in same domain(Stage 4)&lt;/li&gt;
&lt;li&gt;MN registers its CoA with MAP (Stage 5)&lt;/li&gt;
&lt;li&gt;MN moves to new network in a different domain (Stage 6)&lt;/li&gt;
&lt;li&gt;MN registers its CoA with HA (Stage 7)&lt;/li&gt;
&lt;li&gt;MN registers its CoA with MAP (Stage 8)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Intra-MSC

&lt;ul&gt;
&lt;li&gt;Handover

&lt;ul&gt;
&lt;li&gt;http://qjg-wiki.googlecode.com/files/Intra-MSC-Handover.jpg&lt;/li&gt;
&lt;li&gt;Aim

&lt;ul&gt;
&lt;li&gt;Perform communication with mobile device via BSS B instead of via BSS A&lt;/li&gt;
&lt;li&gt;Seamless continue the communication&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Initiation

&lt;ul&gt;
&lt;li&gt;handover initiated by BSS A&lt;/li&gt;
&lt;li&gt;stronger signal to/from BSS B than that to/from BSS A&lt;/li&gt;
&lt;li&gt;maintaining connectivity&lt;/li&gt;
&lt;li&gt;reducing battery power drain&lt;/li&gt;
&lt;li&gt;Balancing load (free resources e.g. channel in BSS A)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Process

&lt;ul&gt;
&lt;li&gt;BSS A informs MSC about pending handover and provides a list of potential BSSs&lt;/li&gt;
&lt;li&gt;MSC selects BSS B from list and sets up path to BSS B&lt;/li&gt;
&lt;li&gt;BSS B allocates radio channel to be used by MS&lt;/li&gt;
&lt;li&gt;BSS B informs BSS A via MSC it is ready for handover&lt;/li&gt;
&lt;li&gt;BSS A informs MS to perform handover to BSS B&lt;/li&gt;
&lt;li&gt;MS and BSS B exchange signals to activate new channel&lt;/li&gt;
&lt;li&gt;MS informs MSC via BSS B about handover completion. MSC reroutes call&lt;/li&gt;
&lt;li&gt;MSC and BSS A release resources&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;http://hi.baidu.com/yuanmx0307/blog/item/a10b79ec474da54779f05540.html&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;Energy Conservation in Wireless and Mobile Communications&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;OSI layer - power save protocols

&lt;ul&gt;
&lt;li&gt;Load Partitioning

&lt;ul&gt;
&lt;li&gt;all the power intensive computation is performed at the AP and not locally. The Mobile device sends a request to the AP which contains the computation that needs to be performed and waits for the result.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Application – based Adaptive Mechanisms

&lt;ul&gt;
&lt;li&gt;Proxies – used to inform the application about the changes in battery power. The applications can use this info in order to limit their functionalities&lt;/li&gt;
&lt;li&gt;For database systems – energy can be conserved by reducing the number of transmissions for different operations: data retrieval, indexing, querying operations.&lt;/li&gt;
&lt;li&gt;For video processing – adaptation mechanisms which slightly degrade the video quality by reducing the number of bits transmitted over the wireless system&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Transport Layer

&lt;ul&gt;
&lt;li&gt;TCP-Probing&lt;/li&gt;
&lt;li&gt;Wave and Wait Protocols&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Network Layer

&lt;ul&gt;
&lt;li&gt;Routing Protocols

&lt;ul&gt;
&lt;li&gt;Backbone based routing protocol

&lt;ul&gt;
&lt;li&gt;backbone node骨干节点

&lt;ul&gt;
&lt;li&gt;Active&lt;/li&gt;
&lt;li&gt;A path between all source and destination nodes in the network is established&lt;/li&gt;
&lt;li&gt;Any node will be within one hop of at least one backbone node&lt;/li&gt;
&lt;li&gt;The decision of which nodes to be the backbone nodes is also changing periodically&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Other nodes

&lt;ul&gt;
&lt;li&gt;Sleep periodically&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Topology based routing protocol

&lt;ul&gt;
&lt;li&gt;Goal: reduce the transmission power of all nodes in the network&lt;/li&gt;
&lt;li&gt;All the nodes operate with the lowest transmission power possible&lt;/li&gt;
&lt;li&gt;Homogeneous networks – the nodes are within the range of their nearest one-hop neighbour&lt;/li&gt;
&lt;li&gt;Heterogeneous networks – (different nodes with different power limitations) – transmission powers may be adjusted according to the network needs&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Data Link Layer

&lt;ul&gt;
&lt;li&gt;The techniques involve reducing the transmission overhead during ARQ (Automatic Repeat Request) and FEC (Forward Error Correction) - schemes used to reduce the number of packet errors at the receiver&lt;/li&gt;
&lt;li&gt;ARQ enabled – the router can automatically request the retransmission of a packet directly from its source without involving the receiver.&lt;/li&gt;
&lt;li&gt;It has been shown that transmitting at lower power and sending multiple ARQ is more energy efficient than to send at high transmission power and achieve better throughput.&lt;/li&gt;
&lt;li&gt;By integrating FEC – which reduces the number of retransmissions necessary at the lower transmission power – more energy savings can be achieved&lt;/li&gt;
&lt;li&gt;Packet Scheduling protocols - may reduce the number of retransmissions =&gt; the overall power consumption is reduced&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;MAC Layer

&lt;ul&gt;
&lt;li&gt;Sleep Scheduling Protocols

&lt;ul&gt;
&lt;li&gt;Basic Principle: a big amount of power is wasted listening on the radio channel even though there is nothing there to receive&lt;/li&gt;
&lt;li&gt;The radio will switch between its on and off power states in order to reduce the effects of the idle listening&lt;/li&gt;
&lt;li&gt;The radio interface will be wake up whenever it expects to transmit or receive packets and sleep otherwise&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Synchronous Sleep Scheduling Protocols&lt;/li&gt;
&lt;li&gt;Battery aware MAC protocols (BAMAC)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Physical Layer&lt;/li&gt;
&lt;li&gt;Topology Control Mechanisms&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Existing Standards

&lt;ul&gt;
&lt;li&gt;WPAN - 802.15.1 standard (Bluetooth)

&lt;ul&gt;
&lt;li&gt;There are 8 different operational states defined in Bluetooth, 3 of them are dedicated to low power operations

&lt;ul&gt;
&lt;li&gt;Sniff state - the active Bluetooth device lowers its duty cycle and listens to the piconet at reduced rate&lt;/li&gt;
&lt;li&gt;Hold state - the device shuts down all communication capabilities it has with the piconet, but keeps the slot (from the seven activeslots available in a piconet) as active&lt;/li&gt;
&lt;li&gt;Park state - disable all communication with the piconet, as in case of Hold state, except that this time give up also its access to one of the seven active slots available for the devices within the piconet&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;WiMAX

&lt;ul&gt;
&lt;li&gt;3 Power Save Classes (PSCs) based on different QoS characteristics

&lt;ul&gt;
&lt;li&gt;Each PSC consists of a sequence of interleaved listening and sleep intervals 都含有相间的监听和等待&lt;/li&gt;
&lt;li&gt;Can support one or multiple traffic flows in a mobile station with similar characteristics 支持一个或多个数据流&lt;/li&gt;
&lt;li&gt;A mobile station can turn off its radio interface when all its PSCs are in the sleep window, it wakes up when any PSC is in a listening window 在空闲时可以完全进入睡眠状态，如果有某个PSC进入监听状态，则唤醒其他。&lt;/li&gt;
&lt;li&gt;Each flow of a mobile station can be corresponded to a PSC 每个流都可以响应PSC&lt;/li&gt;
&lt;li&gt;class power saving

&lt;ul&gt;
&lt;li&gt;1st

&lt;ul&gt;
&lt;li&gt;designed for non-real-time traffic flows&lt;/li&gt;
&lt;li&gt;it has exponentially increasing sleep window if no packet comes&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;2nd

&lt;ul&gt;
&lt;li&gt;designed for real-time traffic flows&lt;/li&gt;
&lt;li&gt;It has a fixed size of sleep window&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;3rd

&lt;ul&gt;
&lt;li&gt;designed for multicast connections or management opeartions&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;http://qjg-wiki.googlecode.com/files/WiMAXClassesPowerSaving.jpg&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;LTE

&lt;ul&gt;
&lt;li&gt;RRC Active State

&lt;ul&gt;
&lt;li&gt;Data is exchanged between the network and the mobile device 数据交换发生在网络和移动设备中&lt;/li&gt;
&lt;li&gt;The mobile remains in active state even when there is no data transmitted for some time (e.g., after the content of a web page has been fully loaded) 一直处于工作状态不管是否有数据传输&lt;/li&gt;
&lt;li&gt;The mobile can deactivate its receiver in order to conserve energy 移动设备可以关闭接收端以降低能耗&lt;/li&gt;
&lt;li&gt;After some inactivity time the network can activate the Discontinuous Reception Mode (DRX) - meaning that the mobile has to listen to downlink bandwidth assignments and control commands periodically and switch off its receiver at all other times&lt;/li&gt;
&lt;li&gt;DRX interval can be flexible (from ms to s)&lt;/li&gt;
&lt;li&gt;Mobility is controlled by the network - the mobile device has to send signal measurements from the current or neighbour cell&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;RRC Idle State

&lt;ul&gt;
&lt;li&gt;If no packets were transmitted for a certain amount of time, the eNodeB can put the connection to a user in RRC Idle state 如果没有传输，则进入关闭状态&lt;/li&gt;
&lt;li&gt;The logical connection to the network and the assigned IP address is retained 地址被保留&lt;/li&gt;
&lt;li&gt;The radio connection is removed 信号连接关闭&lt;/li&gt;
&lt;li&gt;The MME is informed about the Idle State as the IP packets arriving from the Internet cannot be delivered to the radio network&lt;/li&gt;
&lt;li&gt;In this case the MME sends a paging message to the mobile device, re-establishing the radio bearer&lt;/li&gt;
&lt;li&gt;If the mobile device in Idle states wants to send an IP packet, it has to request the establishment of a new radio bearer before the packet transmission&lt;/li&gt;
&lt;li&gt;When in Idle state, the network cannot control the mobility of the device&lt;/li&gt;
&lt;li&gt;The device can decide on its own to move from one cell to another&lt;/li&gt;
&lt;li&gt;The device has to report a cell change to the network only if the tracking area is changed (a tracking area consists of several cells)&lt;/li&gt;
&lt;li&gt;MME will send a paging message via all the cells within the tracking are when a new IP packet for the device arrives from the Internet&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Energy Harvesting Techniques

&lt;ul&gt;
&lt;li&gt;Solar panels&lt;/li&gt;
&lt;li&gt;Piezoelectric materials&lt;/li&gt;
&lt;li&gt;Human Active Energy&lt;/li&gt;
&lt;li&gt;Human Passive Energy&lt;/li&gt;
&lt;li&gt;RF Energy/Ambient Energy&lt;/li&gt;
&lt;li&gt;Wind Generators&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;http://code.google.com/p/wpcdcuassignment2010-2011/downloads/detail?name=500ee.zip&amp;amp;can=2&amp;amp;q=&lt;/h2&gt;

&lt;h2&gt;tags: Network&lt;/h2&gt;
</content>
 </entry>
 
 <entry>
   <title>EE552-BroadbandNetworks</title>
   <link href="http://www.5wpc.info/it/study/dcu/2011/02/14/EE552BroadbandNetworks"/>
   <updated>2011-02-14T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/study/dcu/2011/02/14/EE552BroadbandNetworks</id>
   <content type="html">&lt;h1&gt;EE552-BroadbandNetworks&lt;/h1&gt;

&lt;h2&gt;history&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;network

&lt;ul&gt;
&lt;li&gt;Telephone

&lt;ul&gt;
&lt;li&gt;end-system端设备

&lt;ul&gt;
&lt;li&gt;POS&lt;/li&gt;
&lt;li&gt;Terminal&lt;/li&gt;
&lt;li&gt;PC&lt;/li&gt;
&lt;li&gt;Modem&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;local-loop本地数据交换回路&lt;/li&gt;
&lt;li&gt;Transmission facilities 传输设备

&lt;ul&gt;
&lt;li&gt;媒介

&lt;ul&gt;
&lt;li&gt;wired&lt;/li&gt;
&lt;li&gt;wireless&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;参数

&lt;ul&gt;
&lt;li&gt;带宽&lt;/li&gt;
&lt;li&gt;FDM&lt;/li&gt;
&lt;li&gt;TDM&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Multiplexing多波

&lt;ul&gt;
&lt;li&gt;PCM脉冲编码调制&lt;/li&gt;
&lt;li&gt;PDM脉冲宽度调制&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Switching数据交换&lt;/li&gt;
&lt;li&gt;Signalling信号

&lt;ul&gt;
&lt;li&gt;控制信号

&lt;ul&gt;
&lt;li&gt;连接&lt;/li&gt;
&lt;li&gt;挂断&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;识别信号&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Billing 计费系统&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Data Communication 数字信号通信

&lt;ul&gt;
&lt;li&gt;CSMA/CD 载波监听多路访问/冲突检测&lt;/li&gt;
&lt;li&gt;Frames&lt;/li&gt;
&lt;li&gt;优点

&lt;ul&gt;
&lt;li&gt;抗干扰&lt;/li&gt;
&lt;li&gt;抗衰减&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;数模转换&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ATM Asynchronous Transfer Mode&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;Asynchronous Transfer Mode&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Packet Switching数据包交换

&lt;ul&gt;
&lt;li&gt;Datagram routing

&lt;ul&gt;
&lt;li&gt;优缺点

&lt;ul&gt;
&lt;li&gt;无需连接与断开的准备阶段&lt;/li&gt;
&lt;li&gt;选路算法的可适应性强&lt;/li&gt;
&lt;li&gt;容易实施部署&lt;/li&gt;
&lt;li&gt;数据顺序无法保存&lt;/li&gt;
&lt;li&gt;需要构建较大的路由表&lt;/li&gt;
&lt;li&gt;报文头部信息需要包含完整的信息&lt;/li&gt;
&lt;li&gt;可能存在循环寻路死锁&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;routing table 路由表&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Virtual circuit routing&lt;/li&gt;
&lt;li&gt;Contention冲突控制&lt;/li&gt;
&lt;li&gt;Buffering缓存&lt;/li&gt;
&lt;li&gt;优缺点

&lt;ul&gt;
&lt;li&gt;数据统计&lt;/li&gt;
&lt;li&gt;传输数据可以调节&lt;/li&gt;
&lt;li&gt;额外数据&lt;/li&gt;
&lt;li&gt;无法提供QoS服务&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Features 特征

&lt;ul&gt;
&lt;li&gt;需求复用 Demand multiplexing&lt;/li&gt;
&lt;li&gt;固定长度的数据包 Fixed-length packets

&lt;ul&gt;
&lt;li&gt;Cell 信源交换&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;高比特率 High bit rate&lt;/li&gt;
&lt;li&gt;面向连接的操作 Connection-oriented operation&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;设计需求

&lt;ul&gt;
&lt;li&gt;High-speed operation 高速操作&lt;/li&gt;
&lt;li&gt;Rapid decision making 快速处理&lt;/li&gt;
&lt;li&gt;Contention resolution 冲突化解&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Switch交换方法

&lt;ul&gt;
&lt;li&gt;Shared-medium 共享介质&lt;/li&gt;
&lt;li&gt;Banyan-based 榕树式交换&lt;/li&gt;
&lt;li&gt;Crossbar and sort-banyan&lt;/li&gt;
&lt;li&gt;Switches based on address filtration&lt;/li&gt;
&lt;li&gt;Output-buffered&lt;/li&gt;
&lt;li&gt;Input-buffered&lt;/li&gt;
&lt;li&gt;Internally-buffered&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ATM Adaptation Layer

&lt;ul&gt;
&lt;li&gt;http://qjg-wiki.googlecode.com/files/BroadbandNetworkATMAAL.jpg&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Performance 性能

&lt;ul&gt;
&lt;li&gt;Analytical 分析法&lt;/li&gt;
&lt;li&gt;Numerical 统计法&lt;/li&gt;
&lt;li&gt;Simulation 模拟法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;tags: Network&lt;/h2&gt;
</content>
 </entry>
 
 <entry>
   <title>make</title>
   <link href="http://www.5wpc.info/it/technical/continuousintegration/2011/02/13/make"/>
   <updated>2011-02-13T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/technical/continuousintegration/2011/02/13/make</id>
   <content type="html">&lt;h1&gt;make&lt;/h1&gt;

&lt;h2&gt;变量&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;$(VAR)&lt;/li&gt;
&lt;li&gt;VAR=gcc&lt;/li&gt;
&lt;li&gt;如果你要使用真实的“$”字符，那么你需要用“$$”来表示&lt;/li&gt;
&lt;li&gt;$(var:a=b) 变量值的替换&lt;/li&gt;
&lt;li&gt;$(VAR)+=add_var&lt;/li&gt;
&lt;li&gt;多行变量&lt;/li&gt;
&lt;li&gt;全局变量&lt;/li&gt;
&lt;li&gt;命令行参数

&lt;ul&gt;
&lt;li&gt;override&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;局部(目标)变量

&lt;ul&gt;
&lt;li&gt;target: var-assignments&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;自动化变量

&lt;ul&gt;
&lt;li&gt;$@ 表示规则中的目标文件集。在模式规则中，如果有多个目标，那么，&quot;$@&quot;就是匹配于目标中模式定义的集合。&lt;/li&gt;
&lt;li&gt;$% 仅当目标是函数库文件中，表示规则中的目标成员名。例如，如果一个目标是&quot;foo.a(bar.o)&quot;，那么，&quot;$%&quot;就是&quot;bar.o&quot;，&quot;$@&quot;就是&quot;foo.a&quot;。如果目标不是函数库文件（Unix下是[.a]，Windows下是[.lib]），那么，其值为空。&lt;/li&gt;
&lt;li&gt;$&amp;lt; 依赖目标中的第一个目标名字。如果依赖目标是以模式（即&quot;%&quot;）定义的，那么&quot;$&amp;lt;&quot;将是符合模式的一系列的文件集。注意，其是一个一个取出来的。&lt;/li&gt;
&lt;li&gt;$?  所有比目标新的依赖目标的集合。以空格分隔。&lt;/li&gt;
&lt;li&gt;$^ 所有的依赖目标的集合。以空格分隔。如果在依赖目标中有多个重复的，那个这个变量会去除重复的依赖目标，只保留一份。&lt;/li&gt;
&lt;li&gt;$+ 这个变量很像&quot;$^&quot;，也是所有依赖目标的集合。只是它不去除重复的依赖目标。&lt;/li&gt;
&lt;li&gt;$&lt;code&gt;*&lt;/code&gt; 这个变量表示目标模式中&quot;%&quot;及其之前的部分&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;命令&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;@echo&lt;/li&gt;
&lt;li&gt;pre;suf 前后有效应的命令(环境pwd)&lt;/li&gt;
&lt;li&gt;打印信息

&lt;ul&gt;
&lt;li&gt;$(info xxxxxxxx)&lt;/li&gt;
&lt;li&gt;$(warning xxx)&lt;/li&gt;
&lt;li&gt;$(error xxxxx)&lt;/li&gt;
&lt;li&gt;$(error $(abx) xxxx)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;忽略出错命令

&lt;ul&gt;
&lt;li&gt;-command&lt;/li&gt;
&lt;li&gt;.IGNORE target

&lt;ul&gt;
&lt;li&gt;这个规则中的所有命令将会忽略错误&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;make

&lt;ul&gt;
&lt;li&gt;-i

&lt;ul&gt;
&lt;li&gt;所有命令都会忽略错误&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;-k

&lt;ul&gt;
&lt;li&gt;如果某规则中的命令出错了，那么就终止该规则的执行，但继续执行其它规则&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;嵌套执行&lt;/li&gt;
&lt;li&gt;定义命令包

&lt;ul&gt;
&lt;li&gt;define name&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;TAB&amp;gt;&lt;/code&gt; command&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;TAB&amp;gt;&lt;/code&gt; command&lt;/li&gt;
&lt;li&gt;endef&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;更新文件修改信息

&lt;ul&gt;
&lt;li&gt;&lt;code language=&quot;makefile&quot;&gt; update_modify_time=touch -d &quot;&lt;code&gt;stat -c %y $^ | sort -n | tail -1&lt;/code&gt;&quot; $@ &lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;文件指示&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Name

&lt;ul&gt;
&lt;li&gt;Makefile&lt;/li&gt;
&lt;li&gt;makefile&lt;/li&gt;
&lt;li&gt;make -f/--file arg&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;引入其他makefile: include&lt;/li&gt;
&lt;li&gt;文件搜索

&lt;ul&gt;
&lt;li&gt;默认是当前目录&lt;/li&gt;
&lt;li&gt;VPATH 环境变量(Makefile)&lt;/li&gt;
&lt;li&gt;vpath

&lt;ul&gt;
&lt;li&gt;vpath pattern directory: 为符合模式pattern的文件指定搜索目录directories&lt;/li&gt;
&lt;li&gt;vpath pattern: 清除符合模式pattern的文件的搜索目录&lt;/li&gt;
&lt;li&gt;vpath: 清除所有已被设置好了的文件搜索目录&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;注释&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;行注释&lt;/li&gt;
&lt;li&gt;&lt;h1&gt;...&lt;/h1&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;表达式&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;conditional-directive

&lt;ul&gt;
&lt;li&gt;conditional-directive

&lt;ul&gt;
&lt;li&gt;ifeq(arg1,arg2)&lt;/li&gt;
&lt;li&gt;ifneq(arg1,arg2)&lt;/li&gt;
&lt;li&gt;ifdef var&lt;/li&gt;
&lt;li&gt;ifndef var&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;text-if-true&lt;/li&gt;
&lt;li&gt;else&lt;/li&gt;
&lt;li&gt;test-if-false&lt;/li&gt;
&lt;li&gt;endif&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;function

&lt;ul&gt;
&lt;li&gt;$(FUNCTION ARGUMENTS)

&lt;ul&gt;
&lt;li&gt;字符串处理

&lt;ul&gt;
&lt;li&gt;$(subst from,to,text) 字符串替换&lt;/li&gt;
&lt;li&gt;$(patsubst pattern,replacement,text) 模式字符串替换&lt;/li&gt;
&lt;li&gt;$(strip string) 去掉头尾空格&lt;/li&gt;
&lt;li&gt;$(findstring find,in)查找字符串&lt;/li&gt;
&lt;li&gt;$(filter pattern1 patter2...,text)过滤函数，符合模式的留下&lt;/li&gt;
&lt;li&gt;$(filter-out pattern1 patter2...,text)反过滤&lt;/li&gt;
&lt;li&gt;$(sort list) 排序&lt;/li&gt;
&lt;li&gt;$(word n,text)取单词&lt;/li&gt;
&lt;li&gt;$(wordlist start,end,text) 取单词串&lt;/li&gt;
&lt;li&gt;$(words text)单词个数统计&lt;/li&gt;
&lt;li&gt;$(firstword text) 首个单词&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;文件名

&lt;ul&gt;
&lt;li&gt;$(dir names...)&lt;/li&gt;
&lt;li&gt;$(notdir names...)&lt;/li&gt;
&lt;li&gt;$(suffix names...) 取后缀&lt;/li&gt;
&lt;li&gt;$(basename names...)取前缀&lt;/li&gt;
&lt;li&gt;$(addsuffix suffix,names...)&lt;/li&gt;
&lt;li&gt;$(addprefix prefix,names...)&lt;/li&gt;
&lt;li&gt;$(join list1,list2)

&lt;ul&gt;
&lt;li&gt;把list2 中的单词对应地加到list1的单词后面。如果list1的单词个数要比list2的多，那么list1中的多出来的单词将保持原样。如果list2的单词个数要比list1多，那么，list2多出来的单词将被复制到list2中。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;foreach

&lt;ul&gt;
&lt;li&gt;names := a b c d&lt;/li&gt;
&lt;li&gt;files := $(foreach n,$(names),$(n).o)&lt;/li&gt;
&lt;li&gt;$(files)的值是“a.o b.o c.o d.o”&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;$(if condition, then-part)&lt;/li&gt;
&lt;li&gt;$(if condition,then-part,else-part)&lt;/li&gt;
&lt;li&gt;call&lt;/li&gt;
&lt;li&gt;$(origin variable)

&lt;ul&gt;
&lt;li&gt;undefined&lt;/li&gt;
&lt;li&gt;default&lt;/li&gt;
&lt;li&gt;environment&lt;/li&gt;
&lt;li&gt;file&lt;/li&gt;
&lt;li&gt;command line&lt;/li&gt;
&lt;li&gt;automatic&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;$(shell command...)&lt;/li&gt;
&lt;li&gt;$(error message)&lt;/li&gt;
&lt;li&gt;$(warning message)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;规则&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;显式

&lt;ul&gt;
&lt;li&gt;Simple

&lt;ul&gt;
&lt;li&gt;target: prerequisties&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;TAB&amp;gt;&lt;/code&gt;command&lt;/li&gt;
&lt;li&gt;反斜杠 \ 作为换行符&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;通配符

&lt;ul&gt;
&lt;li&gt;&quot;&lt;code&gt;*&lt;/code&gt;&quot;: 任何字符&lt;/li&gt;
&lt;li&gt;&quot;?&quot;: 单个字符&lt;/li&gt;
&lt;li&gt;[...]: 集合中的一个字符&lt;/li&gt;
&lt;li&gt;反斜杠\转义为普通字符&lt;/li&gt;
&lt;li&gt;$(wildcard &lt;code&gt;*&lt;/code&gt;) 展开通配符结果&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;目标

&lt;ul&gt;
&lt;li&gt;伪目标 .PHONY&lt;/li&gt;
&lt;li&gt;多目标 $@

&lt;ul&gt;
&lt;li&gt;静态模式 Target=target-pattern:require-pattern

&lt;ul&gt;
&lt;li&gt;objects = foo.o bar.o&lt;/li&gt;
&lt;li&gt;all: $(objects)&lt;/li&gt;
&lt;li&gt;$(objects): %.o: %.c&lt;/li&gt;
&lt;li&gt;$(CC) -c $(CFLAGS) $&amp;lt; -o $@&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;隐晦

&lt;ul&gt;
&lt;li&gt;自动生成依赖性

&lt;ul&gt;
&lt;li&gt;gcc -MM&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;tags: Tool&lt;/h2&gt;
</content>
 </entry>
 
 <entry>
   <title>TODO List</title>
   <link href="http://www.5wpc.info/src/2011/02/13/Todo"/>
   <updated>2011-02-13T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/src/2011/02/13/Todo</id>
   <content type="html">&lt;h1&gt;我还需要完善的东西&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;添加Wiki的各种重要Tags&lt;/li&gt;
&lt;li&gt; 各种Tags&lt;/li&gt;
&lt;li&gt; 按生成器分：wiki，思维导图&lt;/li&gt;
&lt;li&gt; 按内容分：习惯，技术&lt;/li&gt;
&lt;li&gt;迁移Vimwiki到自己的文件结构中来&lt;/li&gt;
&lt;li&gt;添加功能

&lt;ol&gt;
&lt;li&gt;&lt;del&gt;评论&lt;/del&gt;
 添加完成, 使用了&quot;多说&quot;与&quot;disqus&quot;两个系统. 目前主要针对国内用户, 所以基本是使用多说.  https://github.com/qianjigui/www/commit/24bb3bba7d86985199d13466a7eaa168d25e10fe&lt;/li&gt;
&lt;li&gt;&lt;del&gt;内容搜索&lt;/del&gt;&lt;/li&gt;
&lt;li&gt;mm 2 image&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;

</content>
 </entry>
 
 <entry>
   <title>Manage It!: Your Guide to Modern, Pragmatic Project Management 项目管理修炼之道</title>
   <link href="http://www.5wpc.info/it/career/manage/2011/02/12/ReadMPragmaticProjectManagement"/>
   <updated>2011-02-12T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/career/manage/2011/02/12/ReadMPragmaticProjectManagement</id>
   <content type="html">&lt;h1&gt;项目管理修炼之道&lt;/h1&gt;

&lt;h2&gt;图书目录&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt; 启动项目

&lt;ol&gt;
&lt;li&gt;定义项目和项目经理 1&lt;/li&gt;
&lt;li&gt;管理项目的关键驱动因素、约束和浮动因素 2&lt;/li&gt;
&lt;li&gt;与客户或出资人讨论项目约束 5&lt;/li&gt;
&lt;li&gt;决定项目的关键驱动因素 6&lt;/li&gt;
&lt;li&gt;应对喜欢过多干预项目的出资人 7&lt;/li&gt;
&lt;li&gt; 预测未来 8&lt;/li&gt;
&lt;li&gt; 使用与上下文无关的问题识别项目真正的驱动因素 8&lt;/li&gt;
&lt;li&gt;编写项目章程，共享现有决策 9&lt;/li&gt;
&lt;li&gt; 远景 10&lt;/li&gt;
&lt;li&gt; 需求 10&lt;/li&gt;
&lt;li&gt; 目标 10&lt;/li&gt;
&lt;li&gt; 成功标准 11&lt;/li&gt;
&lt;li&gt; ROI 11&lt;/li&gt;
&lt;li&gt;理解质量对于项目的意义 12&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt; 规划项目 14

&lt;ol&gt;
&lt;li&gt;踏上征程 14&lt;/li&gt;
&lt;li&gt;使项目足以启动的规划 14&lt;/li&gt;
&lt;li&gt;开发项目规划模板 16&lt;/li&gt;
&lt;li&gt; 产品意图 16&lt;/li&gt;
&lt;li&gt; 历史记录 17&lt;/li&gt;
&lt;li&gt; 发布条件 17&lt;/li&gt;
&lt;li&gt; 目标 18&lt;/li&gt;
&lt;li&gt; 项目组织 18&lt;/li&gt;
&lt;li&gt; 日程总览 19&lt;/li&gt;
&lt;li&gt; 人员配备 20&lt;/li&gt;
&lt;li&gt; 建议日程 20&lt;/li&gt;
&lt;li&gt; 制订项目风险列表 21&lt;/li&gt;
&lt;li&gt;制订发布条件 21&lt;/li&gt;
&lt;li&gt; 确定当前项目最重要的因素 22&lt;/li&gt;
&lt;li&gt; 草拟发布条件 23&lt;/li&gt;
&lt;li&gt; 让发布条件符合SMART原则 24&lt;/li&gt;
&lt;li&gt; 在发布条件上达成多方共识 25&lt;/li&gt;
&lt;li&gt;使用发布条件 25&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt; 使用生命周期组织项目 27

&lt;ol&gt;
&lt;li&gt;理解项目生命周期 27&lt;/li&gt;
&lt;li&gt;生命周期概览 28&lt;/li&gt;
&lt;li&gt;在项目中寻求反馈 31&lt;/li&gt;
&lt;li&gt;大规模项目需要组合使用多种生命周期 33&lt;/li&gt;
&lt;li&gt;管理架构风险 35&lt;/li&gt;
&lt;li&gt;从瀑布中摆脱出来 36&lt;/li&gt;
&lt;li&gt;我最钟爱的生命周期 36&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt; 安排项目日程 38

&lt;ol&gt;
&lt;li&gt;注重实效的项目日程安排 38&lt;/li&gt;
&lt;li&gt;可供选择的项目日程安排技术 39&lt;/li&gt;
&lt;li&gt; 自顶向下式日程安排 40&lt;/li&gt;
&lt;li&gt; 自底向上式日程安排 40&lt;/li&gt;
&lt;li&gt; 由内及外式日程安排 40&lt;/li&gt;
&lt;li&gt; 哈德逊湾式启动 41&lt;/li&gt;
&lt;li&gt; 短期迭代 41&lt;/li&gt;
&lt;li&gt;用低技术含量的工具安排项目日程 42&lt;/li&gt;
&lt;li&gt; 使用即时贴安排项目日程的基本技术 43&lt;/li&gt;
&lt;li&gt; 使用即时贴和箭头安排项目日程 45&lt;/li&gt;
&lt;li&gt; 为每一个职能组使用即时贴安排项目日程 45&lt;/li&gt;
&lt;li&gt; 按功能使用即时贴安排项目日程 46&lt;/li&gt;
&lt;li&gt; 使用即时贴安排项目日程的好处 46&lt;/li&gt;
&lt;li&gt; 基于可交付物的规划 47&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt; 估算工作 48

&lt;ol&gt;
&lt;li&gt;实用的项目估算方式 48&lt;/li&gt;
&lt;li&gt; 通过对比历史数据进行估算 48&lt;/li&gt;
&lt;li&gt; 通过Delphi和宽带Delphi方式进行估算 48&lt;/li&gt;
&lt;li&gt; 何时不应相信团队的估算 49&lt;/li&gt;
&lt;li&gt; 小心顺序式生命周期的估算陷阱 50&lt;/li&gt;
&lt;li&gt; 使用自信心范围进行估算 51&lt;/li&gt;
&lt;li&gt; 使用日期范围进行估算 53&lt;/li&gt;
&lt;li&gt; 使用三个日期：最佳状况、最有可能、“墨菲”日期 53&lt;/li&gt;
&lt;li&gt; 在估算时分开考虑任务的大小与持续时间 54&lt;/li&gt;
&lt;li&gt; 规划扑克 55&lt;/li&gt;
&lt;li&gt; 在估算前用试探性开发收集数据 56&lt;/li&gt;
&lt;li&gt; 让估算更容易的提示 56&lt;/li&gt;
&lt;li&gt;用里程碑切分项目 57&lt;/li&gt;
&lt;li&gt;你们能够不做哪些事情 59&lt;/li&gt;
&lt;li&gt;身背多个项目时的估算 59&lt;/li&gt;
&lt;li&gt;主动安排人们进行多任务 60&lt;/li&gt;
&lt;li&gt;使用波浪式规划 60&lt;/li&gt;
&lt;li&gt;决定迭代的持续时间 62&lt;/li&gt;
&lt;li&gt;尽可能使用“小石子”进行估算 63&lt;/li&gt;
&lt;li&gt; 当任务不清楚时创建并使用“小石子” 63&lt;/li&gt;
&lt;li&gt; 如何得到“小石子” 63&lt;/li&gt;
&lt;li&gt; 为什么使用“小石子” 64&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt; 识别和避免日程安排游戏 65

&lt;ol&gt;
&lt;li&gt;给我一块石头 65&lt;/li&gt;
&lt;li&gt;“希望”是我们最重要的策略 67&lt;/li&gt;
&lt;li&gt;拒绝女王 69&lt;/li&gt;
&lt;li&gt;把灰扫到地毯下面 71&lt;/li&gt;
&lt;li&gt;幸福日期 72&lt;/li&gt;
&lt;li&gt;屁股着火 74&lt;/li&gt;
&lt;li&gt;分散注意力 76&lt;/li&gt;
&lt;li&gt;日程等于承诺 77&lt;/li&gt;
&lt;li&gt;到了之后，我们会知道身处何方 78&lt;/li&gt;
&lt;li&gt;日程安排工具总是对的，又称为梦幻时间日程 80&lt;/li&gt;
&lt;li&gt;我们必须拥有这个功能，否则就完蛋了 82&lt;/li&gt;
&lt;li&gt;我们不能说“不” 83&lt;/li&gt;
&lt;li&gt;日程小鸡 85&lt;/li&gt;
&lt;li&gt;90%完成状态 86&lt;/li&gt;
&lt;li&gt;我们马上会变得更快 87&lt;/li&gt;
&lt;li&gt;令人恍惚的日程 88&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt; 创建出色的项目团队 90

&lt;ol&gt;
&lt;li&gt;招募需要的人 90&lt;/li&gt;
&lt;li&gt;形成团队凝聚力 91&lt;/li&gt;
&lt;li&gt; 好工具让团队有好的发挥 92&lt;/li&gt;
&lt;li&gt; 软件配置管理系统应满足的最低要求 93&lt;/li&gt;
&lt;li&gt; 缺陷跟踪系统应满足的最低要求 93&lt;/li&gt;
&lt;li&gt; 团队发展的5个阶段 93&lt;/li&gt;
&lt;li&gt;让组织配合你的工作 94&lt;/li&gt;
&lt;li&gt; 以项目经理的方式管理职能团队 95&lt;/li&gt;
&lt;li&gt; 管理矩阵式项目团队 95&lt;/li&gt;
&lt;li&gt; 管理跨职能项目团队 96&lt;/li&gt;
&lt;li&gt;对必需的团队规模了如指掌 96&lt;/li&gt;
&lt;li&gt;知道何时应该加人 97&lt;/li&gt;
&lt;li&gt;成为出色的项目经理 98&lt;/li&gt;
&lt;li&gt; 提升人际交往技能 98&lt;/li&gt;
&lt;li&gt; 提升功能性技能 99&lt;/li&gt;
&lt;li&gt; 提升领域专业知识技能 99&lt;/li&gt;
&lt;li&gt; 提升工具和技术的专业技能 100&lt;/li&gt;
&lt;li&gt;知道何时该全身而退 101&lt;/li&gt;
&lt;li&gt; 什么样的组织不适合你 101&lt;/li&gt;
&lt;li&gt; 什么样的团队不适合你 104&lt;/li&gt;
&lt;li&gt; 什么样的产品不适合你 105&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt; 掌控项目 106

&lt;ol&gt;
&lt;li&gt;掌控项目的节奏 106&lt;/li&gt;
&lt;li&gt;举行中途回顾 107&lt;/li&gt;
&lt;li&gt;为需求排序 108&lt;/li&gt;
&lt;li&gt;用时间盒限定需求相关的工作 111&lt;/li&gt;
&lt;li&gt;将迭代限制在4周或是更少的时间内 112&lt;/li&gt;
&lt;li&gt;使用波浪式的规划和日程安排 113&lt;/li&gt;
&lt;li&gt;创建跨职能团队 116&lt;/li&gt;
&lt;li&gt;根据项目的风险选择生命周期模型 116&lt;/li&gt;
&lt;li&gt;保持合理的工作时间 117&lt;/li&gt;
&lt;li&gt;使用“小石子” 118&lt;/li&gt;
&lt;li&gt;管理干扰 119&lt;/li&gt;
&lt;li&gt; 应对其他项目干扰 119&lt;/li&gt;
&lt;li&gt; 应对其他人的干扰 120&lt;/li&gt;
&lt;li&gt;管理缺陷，从项目初就开始 120&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt; 保持项目节奏 124

&lt;ol&gt;
&lt;li&gt;在项目中使用持续集成 124&lt;/li&gt;
&lt;li&gt;为构建创建自动化冒烟测试 125&lt;/li&gt;
&lt;li&gt;按功能实现，而不是按架构 126&lt;/li&gt;
&lt;li&gt; 首先实现具有最高价值的功能 128&lt;/li&gt;
&lt;li&gt; 按功能调试 129&lt;/li&gt;
&lt;li&gt; 按功能测试 129&lt;/li&gt;
&lt;li&gt;多几只眼睛盯着产品 130&lt;/li&gt;
&lt;li&gt;准备重构 131&lt;/li&gt;
&lt;li&gt;通过用例、用户故事、角色和场景来定义需求 132&lt;/li&gt;
&lt;li&gt;分离需求与GUI设计 133&lt;/li&gt;
&lt;li&gt;尽可能使用低保真度的原型 134&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt; 管理会议 136

&lt;ol&gt;
&lt;li&gt;取消这些会议 136&lt;/li&gt;
&lt;li&gt; 避免不需要你解决问题的会议 137&lt;/li&gt;
&lt;li&gt; 绝对不要举行多人参加的顺序式进度报告会议 137&lt;/li&gt;
&lt;li&gt; 避免这些会议 138&lt;/li&gt;
&lt;li&gt;举行下列会议 139&lt;/li&gt;
&lt;li&gt;项目启动会议 139&lt;/li&gt;
&lt;li&gt;发布版本规划会议 139&lt;/li&gt;
&lt;li&gt;进度报告会议 140&lt;/li&gt;
&lt;li&gt; 每日站立会议 140&lt;/li&gt;
&lt;li&gt; 一对一会议 141&lt;/li&gt;
&lt;li&gt; 通过可见的方式了解进度 142&lt;/li&gt;
&lt;li&gt; 通过电子邮件，从团队成员那里获取每周进度报告 143&lt;/li&gt;
&lt;li&gt; 每周向团队报告进度 144&lt;/li&gt;
&lt;li&gt;向管理层报告进度 144&lt;/li&gt;
&lt;li&gt;项目团队会议 144&lt;/li&gt;
&lt;li&gt;迭代审查会议 145&lt;/li&gt;
&lt;li&gt;会议疑难问题解答 146&lt;/li&gt;
&lt;li&gt;管理与远程团队的电话会议.. 147&lt;/li&gt;
&lt;li&gt; 通用引导指南 148&lt;/li&gt;
&lt;li&gt; 准备工作 148&lt;/li&gt;
&lt;li&gt; 进行事先规划 149&lt;/li&gt;
&lt;li&gt; 引导会议 149&lt;/li&gt;
&lt;li&gt; 电话会议后的工作 150&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt; 创建并使用项目仪表板 151

&lt;ol&gt;
&lt;li&gt;测量有风险 151&lt;/li&gt;
&lt;li&gt;根据项目完成度来衡量进度 153&lt;/li&gt;
&lt;li&gt; 使用速度图表跟踪日程安排进度 153&lt;/li&gt;
&lt;li&gt; 使用迭代内容图跟踪总体进度 155&lt;/li&gt;
&lt;li&gt; 计算软件项目的挣值并无实际意义 155&lt;/li&gt;
&lt;li&gt; 用EQF跟踪最初的估算 157&lt;/li&gt;
&lt;li&gt; 更多的度量能提供更多信息 159&lt;/li&gt;
&lt;li&gt; 如果只能度量项目日程，那就这么做 160&lt;/li&gt;
&lt;li&gt; 与项目团队人员分配情况相关的图表 161&lt;/li&gt;
&lt;li&gt; 判断项目的变化率 163&lt;/li&gt;
&lt;li&gt; 查看开发人员是在取得进展还是在白费时间 164&lt;/li&gt;
&lt;li&gt; 测量查找和修复问题的成本 165&lt;/li&gt;
&lt;li&gt; 了解开发人员和测试人员是否在解决缺陷方面取得进展 166&lt;/li&gt;
&lt;li&gt; 展示测试过程 167&lt;/li&gt;
&lt;li&gt; 展示定性数据 168&lt;/li&gt;
&lt;li&gt; 用图表展示团队同意采用的实践 169&lt;/li&gt;
&lt;li&gt; 度量敏捷项目 171&lt;/li&gt;
&lt;li&gt;为出资人创建项目仪表板 171&lt;/li&gt;
&lt;li&gt; 展示风险列表 171&lt;/li&gt;
&lt;li&gt; 展示在满足发布条件方面取得的进展 171&lt;/li&gt;
&lt;li&gt;使用项目气象报告 173&lt;/li&gt;
&lt;li&gt; 要小心定义气象报告的图示 174&lt;/li&gt;
&lt;li&gt; 建立可信的气象报告 176&lt;/li&gt;
&lt;li&gt; 每周发布气象报告 176&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt; 管理多地点项目 177

&lt;ol&gt;
&lt;li&gt;一个问题的成本是多少 177&lt;/li&gt;
&lt;li&gt;识别项目的文化差异 178&lt;/li&gt;
&lt;li&gt;在团队间培养信任 179&lt;/li&gt;
&lt;li&gt; 确保每个地点都有完整的项目可交付物 179&lt;/li&gt;
&lt;li&gt; 确保各个团队可以互相协作 181&lt;/li&gt;
&lt;li&gt; 让人们建立个人接触 181&lt;/li&gt;
&lt;li&gt;在团队间使用互补实践 182&lt;/li&gt;
&lt;li&gt; 使用互补生命周期 182&lt;/li&gt;
&lt;li&gt; 详细说明每个团队的里程碑和交接物 183&lt;/li&gt;
&lt;li&gt;寻找潜在的多地点项目和不同文化导致的问题 187&lt;/li&gt;
&lt;li&gt;在外包时要避免下列错误 188&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt; 在项目中集成测试 191

&lt;ol&gt;
&lt;li&gt;从一开始，就让人们将“减少技术债务”牢记心间 191&lt;/li&gt;
&lt;li&gt;使用小规模测试降低风险 192&lt;/li&gt;
&lt;li&gt;TDD是在项目中集成测试最简便的方式 193&lt;/li&gt;
&lt;li&gt;使用多种测试技巧 195&lt;/li&gt;
&lt;li&gt;确定每个团队成员在测试工作中的角色 197&lt;/li&gt;
&lt;li&gt;正确的开发人员与测试人员之比应该是多少 201&lt;/li&gt;
&lt;li&gt; 产品风险对比率的影响 201&lt;/li&gt;
&lt;li&gt; 项目和流程风险对比率的影响 202&lt;/li&gt;
&lt;li&gt; 人员及其能力对比率的影响 203&lt;/li&gt;
&lt;li&gt;让测试与开发同步进行 205&lt;/li&gt;
&lt;li&gt;为项目制定测试策略 205&lt;/li&gt;
&lt;li&gt;系统测试策略模板 205&lt;/li&gt;
&lt;li&gt;QA与测试有差别 207&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt; 管理工程 209

&lt;ol&gt;
&lt;li&gt;如果项目是工程 209&lt;/li&gt;
&lt;li&gt;将多个相关项目组织到一个发布版本中 210&lt;/li&gt;
&lt;li&gt;随时间推移组织多个相关项目 212&lt;/li&gt;
&lt;li&gt; 将产品的多个版本组织到发布列车中 212&lt;/li&gt;
&lt;li&gt; 让发布列车为你服务 213&lt;/li&gt;
&lt;li&gt; 在不使用发布列车的情况下，将多个版本组织到一个产品中 214&lt;/li&gt;
&lt;li&gt;管理项目经理 214&lt;/li&gt;
&lt;li&gt;创建工程仪表板 215&lt;/li&gt;
&lt;li&gt; 度量互相依赖的项目 216&lt;/li&gt;
&lt;li&gt; 度量一系列项目 216&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt; 结束项目 218

&lt;ol&gt;
&lt;li&gt;管理发布早期版本的请求 218&lt;/li&gt;
&lt;li&gt;管理beta版本 219&lt;/li&gt;
&lt;li&gt;项目经理何时知道无法按时发布项目 220&lt;/li&gt;
&lt;li&gt; “避免小的偏差” 220&lt;/li&gt;
&lt;li&gt; 承诺一个新日期 220&lt;/li&gt;
&lt;li&gt; 估算系统测试时间 222&lt;/li&gt;
&lt;li&gt; 在时间不够的情况下管理系统测试 224&lt;/li&gt;
&lt;li&gt;指导项目走向完成 225&lt;/li&gt;
&lt;li&gt; 管理“结束游戏” 225&lt;/li&gt;
&lt;li&gt; 避免“缺陷提升和降级的游戏” 226&lt;/li&gt;
&lt;li&gt; 规划回顾 227&lt;/li&gt;
&lt;li&gt; 规划庆祝 228&lt;/li&gt;
&lt;li&gt;取消项目 229&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt; 管理项目组合 231

&lt;ol&gt;
&lt;li&gt;构建所有项目的组合 231&lt;/li&gt;
&lt;li&gt;评估项目 232&lt;/li&gt;
&lt;li&gt; 定性评估项目 232&lt;/li&gt;
&lt;li&gt; 定量评估项目 233&lt;/li&gt;
&lt;li&gt;决定现在为哪个项目提供资金 233&lt;/li&gt;
&lt;li&gt;对组合中的项目进行排序 233&lt;/li&gt;
&lt;li&gt;尽快启动项目 234&lt;/li&gt;
&lt;li&gt;使用产品待办事项列表管理新功能需求 235&lt;/li&gt;
&lt;li&gt; 构建产品待办事项列表 235&lt;/li&gt;
&lt;li&gt; 管理待办事项列表 237&lt;/li&gt;
&lt;li&gt;组合管理答疑 237&lt;/li&gt;
&lt;li&gt; 管理从事多个项目多个任务的情况 238&lt;/li&gt;
&lt;li&gt; 说服管理层“切换上下文”是个坏主意 238&lt;/li&gt;
&lt;li&gt; 如何对多任务说“不” 240&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h2&gt;铭记在心45点&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt; 项目规划是在不断进行的，这只是开始。&lt;/li&gt;
&lt;li&gt; 为项目团队、出资人、项目经理自己制订发布条件，以明确定义“完成”的含义。&lt;/li&gt;
&lt;li&gt; 项目规划不必完美无瑕，但是它必须存在。&lt;/li&gt;
&lt;li&gt; 在组织项目时，使用任何生命周期或是多种生命周期的组合，都可以让项目踏上成功之路。&lt;/li&gt;
&lt;li&gt; 不要怯于创建反映你自己项目实际情况的生命周期。“完美的”生命周期只是模型而已，你是生活在现实世界的。&lt;/li&gt;
&lt;li&gt; 阶段-关卡流程或瀑布式生命周期，只有在确定使用它可以获得成功时才使用，而不是不经思考，拿来就用。&lt;/li&gt;
&lt;li&gt; 用低技术含量的工具开始安排项目日程。如果真地需要相关软件工具，过后再转换数据。&lt;/li&gt;
&lt;li&gt; 按可交付物安排日程，而不是按功能。---我个人在这点上犯了极大错误。&lt;/li&gt;
&lt;li&gt; 要有以迭代的方式安排日程的准备。一次完成的项目时间表，其作用根本无法对得起花在上面的时间。&lt;/li&gt;
&lt;li&gt; 绝对不要提供确定的项目结束日期。&lt;/li&gt;
&lt;li&gt; 任务越小，估算起来就越容易。&lt;/li&gt;
&lt;li&gt; 寻求估算的准确性，而不是精确性。&lt;/li&gt;
&lt;li&gt; 日程安排游戏总是会发生的。项目经理的工作就是要识别它们，然后管理项目，让项目仍然可以取得成功。&lt;/li&gt;
&lt;li&gt; 绝大多数情况下，人们玩这些游戏都不是出于恶意。&lt;/li&gt;
&lt;li&gt; 即使没有恶意，日程安排游戏还是会拖项目后腿，使其停滞不前。&lt;/li&gt;
&lt;li&gt; 项目风险越大，团队的多样华程度就应该越高。&lt;/li&gt;
&lt;li&gt; 提升多方面的技能：人际交往技能、功能性技能、领域技能，还有非技术技能。 --我想这个我们都很欠缺&lt;/li&gt;
&lt;li&gt; 知道何时应该离开。&lt;/li&gt;
&lt;li&gt; 作为项目经理，你要带头考虑使用或调整哪些管理实践。&lt;/li&gt;
&lt;li&gt; 评估项目的问题，然后根据这些问题来判断使用或调整哪些实践。&lt;/li&gt;
&lt;li&gt; 要寻找可发建立或维持项目节奏的实践。&lt;/li&gt;
&lt;li&gt; 项目经理可以邀请团队成员考虑这些实践，不过你不能强迫他们采纳这些实践。&lt;/li&gt;
&lt;li&gt; 如果项目经理即使尽全力也只能选择一个实践，推荐选择持续集成。&lt;/li&gt;
&lt;li&gt; 项目经理采纳和调整的实践要有助于保持项目的节奏，允许项目提高启动和结束的速度。&lt;/li&gt;
&lt;li&gt; 你可以判断一次会议对你是否有价值，是否值得花费你或都任何团队成员的时间。&lt;/li&gt;
&lt;li&gt; 要像逃避瘟疫一样，逃避顺序式进度报告会议。&lt;/li&gt;
&lt;li&gt; 观察会议进程，看看是不是能够满足每名参会者的需要。&lt;/li&gt;
&lt;li&gt; 使用速度图的迭代内容图作为首选。&lt;/li&gt;
&lt;li&gt; 数据是工具，不是目的。要记住，图表应该为你服务。&lt;/li&gt;
&lt;li&gt; 如果无法获取需要的数据，项目经理就遇到了比数据更严重的问题。先解决这个问题。&lt;/li&gt;
&lt;li&gt; 如果团队没有分布在同一楼层的十米之内，这就是一个多地点团队。&lt;/li&gt;
&lt;li&gt; 相对于管理坐在一起的团队，管理多地点团队要花费更多时间，还需要更多的项目推进技能。&lt;/li&gt;
&lt;li&gt; 如果项目无法构建起与远程团队的信任关系，这个项目就不可能成功。&lt;/li&gt;
&lt;li&gt; 如果项目经理有在项目中集成测试的规划，你就可以做到。&lt;/li&gt;
&lt;li&gt; 使用TDD，可以提升产品的设计和代码的质量。&lt;/li&gt;
&lt;li&gt; 可以考虑在项目中使用测试连续体系。&lt;/li&gt;
&lt;li&gt; 工程管理需要从战略的角度看待产品，不能仅从战术角度去看。&lt;/li&gt;
&lt;li&gt; 工程管理要确保自己能够看么所有项目的进度。&lt;/li&gt;
&lt;li&gt; 要想清楚哪些度量方法适用于你工程。&lt;/li&gt;
&lt;li&gt; 将精力放在中期里程碑上，很容易引发“穿越沙漠综合症”，一定要避免这种情况。&lt;/li&gt;
&lt;li&gt; 在项目结事时，一定要做回顾，即使已经在项目中进行过中期回顾也要如此。--这点很重要&lt;/li&gt;
&lt;li&gt; 如果项目经理必须取消一个月，那就取消吧。要取消得彻底，不能半途而废。&lt;/li&gt;
&lt;li&gt; 使用产品待办事项列表，不管你采用什么样的生命周期模型。&lt;/li&gt;
&lt;li&gt; 制定项目组合，以从视觉上了解所有项目的情况，不管这些项目是在进行中，还是刚做计划。&lt;/li&gt;
&lt;li&gt; 学着如何说“不”&lt;/li&gt;
&lt;/ol&gt;

</content>
 </entry>
 
 <entry>
   <title>恩威并重的领导艺术</title>
   <link href="http://www.5wpc.info/it/career/manage/2011/02/12/ReadHowtoBeLeaders"/>
   <updated>2011-02-12T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/career/manage/2011/02/12/ReadHowtoBeLeaders</id>
   <content type="html">&lt;h1&gt;恩威并重的领导艺术&lt;/h1&gt;

&lt;h2&gt;2R&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;协作型&lt;/li&gt;
&lt;li&gt;管理型&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;基本管理类型&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;让位

&lt;ul&gt;
&lt;li&gt;低度协作、低度命令&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;朋友

&lt;ul&gt;
&lt;li&gt;恰到好处的协作、低度命令&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;取悦

&lt;ul&gt;
&lt;li&gt;高度协作、低度命令&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;监督

&lt;ul&gt;
&lt;li&gt;低度协作、恰到好处的命令&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;2R

&lt;ul&gt;
&lt;li&gt;恰到好处的协作与命令&lt;/li&gt;
&lt;li&gt;Howto

&lt;ul&gt;
&lt;li&gt;根据受管理者的特点选择策略&lt;/li&gt;
&lt;li&gt;克服自己的缺陷

&lt;ul&gt;
&lt;li&gt;果断的下命令&lt;/li&gt;
&lt;li&gt;认真听取下属的意见&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Tips

&lt;ul&gt;
&lt;li&gt;不要自我感觉良好，领导者不是高明而是比下属更有经验&lt;/li&gt;
&lt;li&gt;相信下属&lt;/li&gt;
&lt;li&gt;学会沟通、交流和讨论&lt;/li&gt;
&lt;li&gt;不要自以为是，要谦虚谨慎&lt;/li&gt;
&lt;li&gt;学会赏识&lt;/li&gt;
&lt;li&gt;学会尊重与沟通&lt;/li&gt;
&lt;li&gt;对下属给予正确有效的反馈意见，以帮助下属发展&lt;/li&gt;
&lt;li&gt;明确不良表现的害处&lt;/li&gt;
&lt;li&gt;矛盾不可避免，但得以理服人&lt;/li&gt;
&lt;li&gt;帮助下属成长&lt;/li&gt;
&lt;li&gt;“要求我想要的”&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;侵犯

&lt;ul&gt;
&lt;li&gt;高度协作、恰到好处的命令&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;要求

&lt;ul&gt;
&lt;li&gt;低度协作、高度命令&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;兴奋

&lt;ul&gt;
&lt;li&gt;恰到好处的协作、低度命令&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;专治

&lt;ul&gt;
&lt;li&gt;高度协作、高度命令&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;tags: Manage 2R Leader&lt;/h2&gt;
</content>
 </entry>
 
 <entry>
   <title>Linux/Ubuntu 使用知识</title>
   <link href="http://www.5wpc.info/it/technical/pcmanage/2011/02/11/linux"/>
   <updated>2011-02-11T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/technical/pcmanage/2011/02/11/linux</id>
   <content type="html">&lt;h1&gt;Ubuntu&lt;/h1&gt;

&lt;h2&gt;常识&lt;/h2&gt;

&lt;h3&gt;用户态与内核态&lt;/h3&gt;

&lt;p&gt;这个网上讨论很多，从编程角度看：调用内核函数的为内核态，其他可以看作用户态。
time指令中的标准输出就是由：墙上时间、用户态调用、内核态调用三部分时间组成。&lt;/p&gt;

&lt;p&gt;一个已经安装的系统的支持的所有的系统调用可以在&lt;em&gt;/usr/include/bits/syscall.h&lt;/em&gt;文件里面看到。&lt;/p&gt;

&lt;h2&gt;基本操作&lt;/h2&gt;

&lt;h2&gt;Mercurial SCM&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;/it/technical/ContinuousIntegration/2011/08/24/mercurial/&quot;&gt;MercurialSCM使用知识&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;Firefox打印问题&lt;/h2&gt;

&lt;p&gt;很多时候，页面被不正常的分页或者打印内容不全等一系列问题的时候，可以考虑检查css代码。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;overflow 需要关闭&lt;/li&gt;
&lt;li&gt;padding/margin 需要调节&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;网络设置&lt;/h2&gt;

&lt;h3&gt;VPN&lt;/h3&gt;

&lt;p&gt;Ubuntu &lt;a href=&quot;http://ubuntuforums.org/showthread.php?p=7002673&quot;&gt;需要设置个把属性&lt;/a&gt;:
需要让PPTP拒绝EAP验证，而这个设置在VPN设置栏中没有。
需要通过手工进行处理:
1. 打开gconf-editor
2. 进入到 /system/networking/connections
3. 查看并找到VPN文件夹
4. 添加新的键值
5. Name: refuse-eap
6. Type: string
7. Value: yes
8. 保存、退出并重新连接&lt;/p&gt;

&lt;p&gt;日志信息，从错误到成功:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;pppd[5094]: pppd 2.4.5 started by root, uid 0
pppd[5094]: Using interface ppp0
pppd[5094]: Connect: ppp0 &amp;lt;--&amp;gt; /dev/pts/2
pppd[5094]: LCP terminated by peer (WM--^Al^@&amp;lt;M-Mt^@^@^CM-&quot;)
pppd[5094]: Connection terminated.
pppd[5094]: Modem hangup
pppd[5094]: Exit.
pppd[5238]: Plugin /usr/lib/pppd/2.4.5//nm-pptp-pppd-plugin.so loaded.
pppd[5238]: pppd 2.4.5 started by root, uid 0
pppd[5238]: Using interface ppp0
pppd[5238]: Connect: ppp0 &amp;lt;--&amp;gt; /dev/pts/2
pppd[5238]: LCP: timeout sending Config-Requests
pppd[5238]: Connection terminated.
pppd[5238]: Modem hangup
pppd[5238]: Exit.
pppd[5427]: Plugin /usr/lib/pppd/2.4.5//nm-pptp-pppd-plugin.so loaded.
pppd[5427]: pppd 2.4.5 started by root, uid 0
pppd[5427]: Using interface ppp0
pppd[5427]: Connect: ppp0 &amp;lt;--&amp;gt; /dev/pts/2
pppd[5427]: CHAP authentication succeeded
kernel: [20287.732748] PPP BSD Compression module registered
kernel: [20287.768881] PPP Deflate Compression module registered
pppd[5427]: local  IP address 172.0.0.18
pppd[5427]: remote IP address 172.0.0.1
pppd[5427]: primary   DNS address 20x.1x5.xxx.xxx
pppd[5427]: secondary DNS address 20x.1x5.xxx.xxx
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另外就是如果前端有个不怎么给力的路由器，请设置DMZ主机为后端VPN使用的PC机。&lt;/p&gt;

&lt;h2&gt;屏幕问题&lt;/h2&gt;

&lt;h3&gt;开机黑屏/中途使用突然黑屏&lt;/h3&gt;

&lt;p&gt;网上也有很多材料谈到，目前确实不知道这类问题产生的真正原因。&lt;/p&gt;

&lt;p&gt;查错的困难:
由于笔记本突然黑屏，我技术水平还不是很过硬，不能够在完全黑屏的情况下导出系统日志，也就不能够通过日志的方法进行排查。另一方面这种错误是随机出现的，发现后做应急处理的程序不完备。&lt;/p&gt;

&lt;p&gt;由于上面的错误，我在做系统差错时，多是采用外部的观察:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;指示灯: 在启动时黑屏，系统和平常进入登陆界面一样，硬盘灯先是不断闪烁，然后就停止闪烁了。估计是已经加载完毕登陆界面等待输入用户信息。中途黑屏时，多为一直闪烁。&lt;/li&gt;
&lt;li&gt;CPU风扇声音: 启动时和平常声音相同，系统中间进入黑屏时多是高速运转。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;那么导致上述现象的原因可能是什么呢？&lt;/p&gt;

&lt;p&gt;综合了网上多是配置启动系统内核的显卡模块参数，我觉得:
系统的电源管理系统出现了一些问题，不正常的向系统发送信号(进入休眠状态)，系统关闭屏幕，并将数据拷入swap分区。但是由于我的及其的休眠状态有问题，导致一直无法进入。&lt;/p&gt;

&lt;p&gt;由于以上问题，我把问题定位到了ACPI(高级电源管理接口)上面。可能是由于它的错误控制导致了系统在开机时将视频信号输出到其他端口，而在运行过程中又将错误信号发给了系统导致了挂起。&lt;/p&gt;

&lt;p&gt;配置ACPI http://www.brighthub.com/computing/linux/articles/39504.aspx :
主要是通过在grub加载时向内核发送参数来控制ACPI模块的加载:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;bashacpi=off&lt;/code&gt;: 关闭ACPI的支持&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bash acpi=ht&lt;/code&gt;: 关闭除超线程之外的ACPI支持&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bash pci=noacpi&lt;/code&gt;: 关闭ACPI的硬中断并且PCI不再扫描ACPI&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bash acpi=noirq&lt;/code&gt;: 关闭ACPI的IRQ(硬中断)&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;而我是直接采用 &lt;code&gt;pci=noacpi&lt;/code&gt;。
休眠、挂起、待机的区别:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;挂起是一种省电模式，系统将机器的硬盘、显示器等外部设备停止工作，而CPU、内存仍然工作，等待用户随时唤醒。&lt;/li&gt;
&lt;li&gt;体眠是一种更加省电的模式，它将内存中的数据保存于硬盘中，使CPU也停止工作，当再次使用时需按开关机键，机器将会恢复到您的执行休眠时的状态，而不用再次执行启动这个复杂的过程。&lt;/li&gt;
&lt;li&gt;待机是将当前处于运行状态的数据保存在内存中，机器只对内存供电，而硬盘、屏幕和CPU等部件则停止供电。由于数据存储在速度快的内存中，因此进入等待状态和唤醒的速度比较快。不过这些数据是保存在内存中 ，如果断电则会使数据丢失。&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;ubuntu 10.04常用命令&lt;/h1&gt;

&lt;h2&gt;升级 firefox&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;sudo add-apt-repository ppa:ubuntu-mozilla-security/ppa
sudo apt-get update
sudo apt-get install firefox
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>生活中的小技巧</title>
   <link href="http://www.5wpc.info/it/living/life/2011/02/11/index.livinglife"/>
   <updated>2011-02-11T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/living/life/2011/02/11/index.livinglife</id>
   <content type="html">&lt;h1&gt;生活中的各种技巧&lt;/h1&gt;

&lt;p&gt;作为一个技术人，有很多事情是繁琐的，有很多事情是快乐的。可以在这些日常生活中，更有激情的或者。&lt;/p&gt;

&lt;h2&gt;&lt;a href=&quot;/it/living/life/2011/02/11/howtoread/&quot;&gt;如何读书&lt;/a&gt;&lt;/h2&gt;

&lt;h2&gt;&lt;a href=&quot;/it/living/life/2011/08/10/EqLearn/&quot;&gt;情商训练&lt;/a&gt;&lt;/h2&gt;

&lt;h2&gt;&lt;a href=&quot;/it/living/life/2011/08/10/FitnessHelp/&quot;&gt;健康与保健&lt;/a&gt;&lt;/h2&gt;

&lt;h2&gt;着装&lt;/h2&gt;

&lt;h3&gt;扎领带&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://qjg-wiki.googlecode.com/files/HowtoTieBar.jpg&quot; alt=&quot;http://qjg-wiki.googlecode.com/files/HowtoTieBar.jpg&quot; /&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>看前辈们如何推动团队运作</title>
   <link href="http://www.5wpc.info/it/career/manage/2011/02/11/index"/>
   <updated>2011-02-11T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/career/manage/2011/02/11/index</id>
   <content type="html">&lt;h1&gt;团队管理&lt;/h1&gt;

&lt;h2&gt;着重点&lt;/h2&gt;

&lt;h3&gt;执行/想法 为 78/22&lt;/h3&gt;

&lt;p&gt;http://www.alibuybuy.com/posts/27525.html&lt;/p&gt;

&lt;h3&gt;是谁在驱动公司&lt;/h3&gt;

&lt;p&gt;http://www.alibuybuy.com/posts/54764.html&lt;/p&gt;

&lt;h4&gt;四种驱动模式&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;运营驱动:
购物类网站&lt;/li&gt;
&lt;li&gt;产品驱动:
QQ&lt;/li&gt;
&lt;li&gt;产品市场双向驱动:
Baidu&lt;/li&gt;
&lt;li&gt;工程师驱动:
问题:

&lt;ul&gt;
&lt;li&gt;缺乏感性&lt;/li&gt;
&lt;li&gt;知识太片面&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>如何读书</title>
   <link href="http://www.5wpc.info/it/living/life/2011/02/11/howtoread"/>
   <updated>2011-02-11T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/living/life/2011/02/11/howtoread</id>
   <content type="html">&lt;h1&gt;如何读书&lt;/h1&gt;

&lt;h2&gt;王者速读法&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;http://qjg-wiki.googlecode.com/files/HowtoReadMoreQuickly.jpg&quot; alt=&quot;http://qjg-wiki.googlecode.com/files/HowtoReadMoreQuickly.jpg&quot; /&gt;&lt;/p&gt;

&lt;h2&gt;用思维导图去读书&lt;/h2&gt;

&lt;p&gt;简单归纳起来，对一本书做思维导图的技巧主要分为两类:准备及应用。在以下各篇中，共有8个阶段。为方便查找起见，
各阶段总结如下，都附有推荐的限制时间。&lt;/p&gt;

&lt;p&gt;准备:
  1. 浏览——制作一个中央图象(10分钟)
  1. 设定时间和总量目标(5分钟)
  1. 把对该话题现存的知识用思维导图画下来(10分钟)
  1. 给目标下个定义并用思维导图画出来(5分钟)
应用:
  1. 总述——加上主要的思维导图主干
  1. 预览——第一级及第二级
  1. 内视——把思维导图的细节加上去
  1. 复习——完成思维导图&lt;/p&gt;

&lt;p&gt;准备:
  1. 浏览(10分钟):
    详细阅读一本书之前，首先要大致浏览一下全书。最好的办法是先看看封面和背页，再看看目录，然后翻动全书几次,把握住对全书的“感觉”。
    然后取一张大纸，或者用一张思维导图专用纸，画一个中央图，把书的主题或者书名总结上去。如果书的封面和内页里有特别引人注目的彩色图象，不妨使用这 个图象。如果你对会从中央图象发散出去的主干有非常合理的把握，不妨同时画上主干。它们经常是与全书的主要篇章或者章节相符合的，也符合你阅读该书的目 的。
    在开始制作思维导图的早期阶段，你是在给自己的大脑一个中心的焦点和基本的结构，在这个框架里面，它可以把所有从研究这本书得来的全部信息综合起来。
  1. 设定时间和总量目标(5分钟):
    根据你的学习目标，根据该书的内容和困难水平，和你已经具有的知识总量，决定你将花在本书全部任务上的全部时间，以及每个学习期间所包含的内容。
  1. 把对该话题现存的知识用思维导图画下来(10分钟):
    现在，扔下书本和你刚画的息维导图，拿过几张纸来，以尽量快的速度画一张速射思维导图，把你对于即将去研究的课题已有的知识画出来。这包括你在前面翻阅本书时得到的任何信息，加上总体的知识，或者在你的一生中得到的所有与该课题有关的任何信息。
    大部分人都很高兴而且很惊讶地发现，他们对一些课题已经具备的知识比他们预想的多得多。这个练习还能把合适的联想或者“铁锚架”带到大脑的表层来，并 让它按照你正在研究的话题的方向运动下去，因而显示出很大的用途。它还可以让你看出自己知识领域里的强项和弱项，让你知道哪些方面的知识是需要进一步弥补 的。
  1. 给目标下个定义并用思维导图画出来(5分钟):
    在这个阶段，你可以用不同的颜色在刚刚完成的知识思维导图上增加一些内容，或者重新拿一张新纸，再做一次快速思维导图速射，说明你学习本书的目标。这 些目标可以是一些具体的问题，你希望得到对这些问题的回答，可能是你希望知道的更多的有关知识，或者是你希望获取的某些技巧。
    按照这种方式把目标用思维导图画出来，会极大地增大眼睛/大脑系统把它碰到的一些与目标相关的信息登记下来的可能性。实际上，目标思维导图起一种“胃 口”的作用，它会自然而然地刺激你的研究。跟一个几天没有吃饭的人会整天想着吃东西一样，好的预备性思维导图会增大你对知识的“渴望”。&lt;/p&gt;

&lt;p&gt;应用(根据研究的材料决定时间长度):
  5—8 总述、预览、内视和复习:
    准备完毕后，你就可以开始在四个水平上进行的阅读了——总述、预览、内视和复习—这样水平上的阅读会把你带入该书更深的层次。这些阶段的细节情况见第21章集体思维导图家庭学习。
    这时，你可以:一边读书一边做思维导图;一边读一边在书上做一些标记，并在事后完成思维导图。这些办法都同样有效——你所选择的无非是根据个人偏好而要的方法，或者也许根据这本书是否归你个人所有而决定。
    一边读一边做思维导图就好像与书的作者进行持续的“对话”，在书往前进展的时候会反映出知识的展开模式。不断扩大的思维导图也会让你注意到理解水平，并据此调整自己的注意力。
    事后画思维导图有一个长处，即你只在掌握理解了全书内容，和部分内容与彼此的关系后才开始做。你的思维导图因此就会更为全面，更有一个核心，也不太可能需要修改。&lt;/p&gt;

&lt;p&gt;不管选择哪一种方法，都必须记住，&lt;em&gt;对一本书做思维导图是一个双向的过程。目标不是简单地以思维导图的形式复制作者的思想。它是要根据你自己的知识、理解力、解释和具体目标来组织和综合他或她的思想。你的思维导图应该能够理想地包括你自己的评论、想法以及从刚刚读到的东西里得到的创造性的理解。用不同的 颜色或者代码会让你自己对该图的贡献与作者的思想区分开来。&lt;/em&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>程序工程师经验谈</title>
   <link href="http://www.5wpc.info/it/career/coder/2011/02/11/coder"/>
   <updated>2011-02-11T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/career/coder/2011/02/11/coder</id>
   <content type="html">&lt;h1&gt;程序工程师经验谈&lt;/h1&gt;

&lt;h2&gt;心态&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;不能浮躁

&lt;ul&gt;
&lt;li&gt;先思后问&lt;/li&gt;
&lt;li&gt;先自己动手&lt;/li&gt;
&lt;li&gt;少形式(概念)多行动&lt;/li&gt;
&lt;li&gt;关注细节&lt;/li&gt;
&lt;li&gt;学且持&lt;/li&gt;
&lt;li&gt;专注：做基础技术的专家

&lt;ul&gt;
&lt;li&gt;我们坚持选拔一流的人才，坚持做一流人才的乐土，坚持我们的技术理念，专注地去做集团最需要我们去做的事情，持续钻研，不断提升我们的技术能力。希望将来，核心系统的每一个人走出去，都能够成为各个领域的资深专家。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;服务：做业务问题的解决者

&lt;ul&gt;
&lt;li&gt;不能够应用于业务的技术不是好技术。为此，我们必须更加强调我们的服务意识，去贴近和了解业务，学会从业务使用者的角度来考虑技术问题，真正深入到业务之中去，解决好业务问题和需求，会让我们的服务和产品更有竞争力和生命力。这对我们来说非常重要。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;创新：做技术创新的领跑者

&lt;ul&gt;
&lt;li&gt;技术创新可以创造更大的价值。创新从哪里来？需要从我们做业务问题解决者的敏感嗅觉中来，从我们的专注精神、过硬的技术能力中来。我们要不断挑战自己，做别人做不了的事情，我们一定会是最有技术活力的团队！&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;急不来

&lt;ul&gt;
&lt;li&gt;需要学与能够学的东西很多&lt;/li&gt;
&lt;li&gt;时间有限&lt;/li&gt;
&lt;li&gt;Eg: Android的整个系统，需要对整个领域有认识，不是１～２年可以的。

&lt;ul&gt;
&lt;li&gt;Linux Kernel&lt;/li&gt;
&lt;li&gt;JVM&lt;/li&gt;
&lt;li&gt;Android Framework&lt;/li&gt;
&lt;li&gt;IPC&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;多多交流

&lt;ul&gt;
&lt;li&gt;与人

&lt;ul&gt;
&lt;li&gt;对人生的看法，娱乐类的事情&lt;/li&gt;
&lt;li&gt;生活话题&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;同行业

&lt;ul&gt;
&lt;li&gt;行业现状&lt;/li&gt;
&lt;li&gt;发展趋势&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;同工作

&lt;ul&gt;
&lt;li&gt;解决方案&lt;/li&gt;
&lt;li&gt;经验

&lt;ul&gt;
&lt;li&gt;业务&lt;/li&gt;
&lt;li&gt;工作&lt;/li&gt;
&lt;li&gt;生活&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;同事

&lt;ul&gt;
&lt;li&gt;如何完成工作&lt;/li&gt;
&lt;li&gt;如何应对困难&lt;/li&gt;
&lt;li&gt;工作方法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;幽默&lt;/li&gt;
&lt;li&gt;乐观

&lt;ul&gt;
&lt;li&gt;庆祝自己的每一次成功&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;谦虚

&lt;ul&gt;
&lt;li&gt;任何事情没有那么简单&lt;/li&gt;
&lt;li&gt;承认自己并不是最顶尖的程序员-知不足。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;三思

&lt;ul&gt;
&lt;li&gt;估算解决问题所需要的时间。为自己定一个时间限制。&lt;/li&gt;
&lt;li&gt;避免形式主义

&lt;ul&gt;
&lt;li&gt;不要过于注重程序的“设计模式”。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;警戒

&lt;ul&gt;
&lt;li&gt;消极、软弱无主见、虚伪、对前途渺茫、混乱无序、怨由心生、虚伪做作、学习时间少、无规划性、代码质量低、手忙脚乱、技术永远停留在“打铁”水平、术业无专攻、低调、迷茫、心态不稳、思想徘徊、生活困难、开发难度大、维护难度大、压力大、难沟通、不满、被动、拿不起放不下、进退两难。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;如何增加收入

&lt;ul&gt;
&lt;li&gt;先要替公司赚到钱，承担责任，一个员工才能拿到钱。&lt;/li&gt;
&lt;li&gt;一个方向，是转向关注业务。具体说来，包括成为产品经理，或称为对产品需求负有责任的技术兼业务高手。&lt;/li&gt;
&lt;li&gt;第二个方向，是作为技术领导，将自己的技术与管理结合起来，提升整个团队的战斗力。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ToBeACreator

&lt;ul&gt;
&lt;li&gt;理想：Create a thing to change the world&lt;/li&gt;
&lt;li&gt;平时: Thinking, discussing, Create, study&lt;/li&gt;
&lt;li&gt;关注: 算法与结构、新产品、新工具&lt;/li&gt;
&lt;li&gt;Care: 架构、优化、成本、格局&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;本事&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;设计

&lt;ul&gt;
&lt;li&gt;经验&lt;/li&gt;
&lt;li&gt;方法&lt;/li&gt;
&lt;li&gt;专注于细节&lt;/li&gt;
&lt;li&gt;表达

&lt;ul&gt;
&lt;li&gt;沟通

&lt;ul&gt;
&lt;li&gt;多说“是”，少说”不是“

&lt;ul&gt;
&lt;li&gt;明确架构师的职责，给出如何构建的方案&lt;/li&gt;
&lt;li&gt;所考虑的替代方案&lt;/li&gt;
&lt;li&gt;项目风险(以及可能的规避策略)&lt;/li&gt;
&lt;li&gt;基于的假设条件&lt;/li&gt;
&lt;li&gt;需要指出的突出问题&lt;/li&gt;
&lt;li&gt;清楚解释你说“不”的原因&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;特殊场合才说“不”

&lt;ul&gt;
&lt;li&gt;特定环境，和公司策略不符合&lt;/li&gt;
&lt;li&gt;无法完成，或者优先级不够高&lt;/li&gt;
&lt;li&gt;给出原因&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;抑制想自卫的冲动

&lt;ul&gt;
&lt;li&gt;等待，接受别人所说的话&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;倾听建议来改善合作&lt;/li&gt;
&lt;li&gt;理解别人与自己沟通的目的&lt;/li&gt;
&lt;li&gt;才思敏捷的回答别人的问题

&lt;ul&gt;
&lt;li&gt;关注是谁在问问题&lt;/li&gt;
&lt;li&gt;想出三点解释，如果可能的话，包含一条支持这些解释的商业根本原因&lt;/li&gt;
&lt;li&gt;如果对方要求你做出某个决定，暂停并思考你所说的话对单位的影响&lt;/li&gt;
&lt;li&gt;如果你的答案有消极影响，要展示别的答案也是“有问题”的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;前瞻性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;管理

&lt;ul&gt;
&lt;li&gt;进度控制&lt;/li&gt;
&lt;li&gt;项目预测&lt;/li&gt;
&lt;li&gt;并行处理&lt;/li&gt;
&lt;li&gt;风险管理&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;扩展

&lt;ul&gt;
&lt;li&gt;发展趋势&lt;/li&gt;
&lt;li&gt;研发&lt;/li&gt;
&lt;li&gt;革新&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;编程

&lt;ul&gt;
&lt;li&gt;编程语言是一种语言，随着时光推移，只要你理解了一种语言的原理，你会发现各种语言之间的相似之处 。最重要的，让语言去适应项目，反之亦然。&lt;/li&gt;
&lt;li&gt;经常备份代码。&lt;/li&gt;
&lt;li&gt;不断学习

&lt;ul&gt;
&lt;li&gt;技术&lt;/li&gt;
&lt;li&gt;思维&lt;/li&gt;
&lt;li&gt;习惯&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;提携新人

&lt;ul&gt;
&lt;li&gt;分享&lt;/li&gt;
&lt;li&gt;传授&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;重构

&lt;ul&gt;
&lt;li&gt;检查

&lt;ul&gt;
&lt;li&gt;Rule of three 称为&quot;三次原则&quot;，指的是当某个功能第三次出现时，才进行&quot;抽象化&quot;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;回顾&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;编写文档&lt;/li&gt;
&lt;li&gt;测试&lt;/li&gt;
&lt;li&gt;编码

&lt;ul&gt;
&lt;li&gt;可用&lt;/li&gt;
&lt;li&gt;可读&lt;/li&gt;
&lt;li&gt;可改&lt;/li&gt;
&lt;li&gt;无错&lt;/li&gt;
&lt;li&gt;优雅&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;别让任何人绑架你的工作节奏

&lt;ul&gt;
&lt;li&gt;http://www.iteye.com/news/26663&lt;/li&gt;
&lt;li&gt;Tips

&lt;ul&gt;
&lt;li&gt;预估工作周期&lt;/li&gt;
&lt;li&gt;理解你没写过的软件的功能&lt;/li&gt;
&lt;li&gt;把复杂的问题简单化&lt;/li&gt;
&lt;li&gt;把复杂的问题分解成若干个小问题&lt;/li&gt;
&lt;li&gt;调整代码，为迭代预留空间&lt;/li&gt;
&lt;li&gt;发现并修复漏洞&lt;/li&gt;
&lt;li&gt;上述问题与其他成员协作完成&lt;/li&gt;
&lt;li&gt;如果你直接和你的用户交互，还有更多的建议

&lt;ul&gt;
&lt;li&gt;把用户需求翻译成改进计划&lt;/li&gt;
&lt;li&gt;深入浅出，把复杂的意思用简单的方式向用户传达&lt;/li&gt;
&lt;li&gt;明晰每一个尚待解决的问题&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Important

&lt;ul&gt;
&lt;li&gt;但是在这些职责之上，最重要的是在了解目标用户的基础上设定目标&lt;/li&gt;
&lt;li&gt;不能让别人的期望凌驾于你的创作自由之上。你必须自主把控这个创造的流程。&lt;/li&gt;
&lt;li&gt;在软件开发的过程中，你才是那个决定什么时候达到什么目标的人。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;架构师

&lt;ul&gt;
&lt;li&gt;软件架构师应具备的十大特点

&lt;ul&gt;
&lt;li&gt;http://www.iteye.com/news/29681

&lt;ul&gt;
&lt;li&gt;看了这些信息,个人感觉与架构师还差距很大,另外在移动互联网时代的开发,需要的架构就更加平面.

&lt;ul&gt;
&lt;li&gt;目前没有对行业的把握&lt;/li&gt;
&lt;li&gt;没有机会做具体的业务&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;如何解决

&lt;ul&gt;
&lt;li&gt;将目前做的事情系统化,实例与产品化

&lt;ul&gt;
&lt;li&gt;Android ROM&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;借助语言与完整开发一个项目中涉及的各步骤,进行体系化学习

&lt;ul&gt;
&lt;li&gt;API&lt;/li&gt;
&lt;li&gt;完整构建&lt;/li&gt;
&lt;li&gt;多平台&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;了解相关领域的技术知识

&lt;ul&gt;
&lt;li&gt;在你想要成为架构师的相关技术领域，必须具备扎实的专业知识和过人的本领。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;超强的分析、设计能力&lt;/li&gt;
&lt;li&gt;编码与验证性测试（POC）

&lt;ul&gt;
&lt;li&gt;熟悉该组织整个技术栈，并能使用各层的技术熟练地编码。 能快速实现验证性测试。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;架构设计的实力

&lt;ul&gt;
&lt;li&gt;能为原始需求提供架构方案。&lt;/li&gt;
&lt;li&gt;考虑周全：工具和框架的采用、安全性、性能和扩展性、依赖关系、集成、效益。&lt;/li&gt;
&lt;li&gt;熟悉软件开发生命周期（SDLC）：需求、分析、设计、测试、打包、部署。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;建模语言或工具

&lt;ul&gt;
&lt;li&gt;能使用不同的建模语言或工具，向其他架构师、开发者、项目经理等人，阐述架构。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;架构框架

&lt;ul&gt;
&lt;li&gt;能证明架构的可行性，包括其业务、应用、数据、基础设置方面。 了解TOGAF和ZACHMAN框架就更好了。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;沟通能力

&lt;ul&gt;
&lt;li&gt;能与开发人员、测试人员、商业分析师、上级经理沟通无阻，无论在口头上和书面上。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;布道

&lt;ul&gt;
&lt;li&gt;能讲解该行业的市场、技术知识。 能为全队提供培训课程。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;销售、甚至售前

&lt;ul&gt;
&lt;li&gt;能参与售前工作（尤其对于软件服务业）：制定技术方案、使用各种预算工具估计方案的规模和成本、与销售对象互动。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;演讲技巧

&lt;ul&gt;
&lt;li&gt;优秀的演讲技巧，有助于以下活动：华丽的计划书和技术文档、PPT演讲、布道。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;职场人的习惯&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;个人目标

&lt;ul&gt;
&lt;li&gt;别指望谁能推着你走

&lt;ul&gt;
&lt;li&gt;从依赖变为独立&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;忠诚于自己的人生计划

&lt;ul&gt;
&lt;li&gt;个人修炼&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;选择放弃什么更难&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;企业目标

&lt;ul&gt;
&lt;li&gt;绩效

&lt;ul&gt;
&lt;li&gt;正确处理，积极应对&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;价值观

&lt;ul&gt;
&lt;li&gt;理解积极的一面&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;社会目标

&lt;ul&gt;
&lt;li&gt;远离角斗场的时代

&lt;ul&gt;
&lt;li&gt;共赢&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;换位思考的沟通

&lt;ul&gt;
&lt;li&gt;为他人着想&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;1+1&gt;2

&lt;ul&gt;
&lt;li&gt;集思广益&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;tags: Review&lt;/h2&gt;

&lt;h2&gt;成长&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;时间

&lt;ul&gt;
&lt;li&gt;目前的工作&lt;/li&gt;
&lt;li&gt;深入业务细节&lt;/li&gt;
&lt;li&gt;对整体的影响&lt;/li&gt;
&lt;li&gt;对整体的把握&lt;/li&gt;
&lt;li&gt;利用其他资源&lt;/li&gt;
&lt;li&gt;整合资源&lt;/li&gt;
&lt;li&gt;节省资源&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;形式

&lt;ul&gt;
&lt;li&gt;从小到大&lt;/li&gt;
&lt;li&gt;从局部到整体&lt;/li&gt;
&lt;li&gt;从开发人员到产品设计/架构师&lt;/li&gt;
&lt;li&gt;不要泛泛、要想想&lt;/li&gt;
&lt;li&gt;定位个人成长，争取方向早成&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;一名程序员十年技术之路的思考与感悟&lt;/li&gt;
&lt;li&gt;http://www.iteye.com/news/29541&lt;/li&gt;
&lt;li&gt;学习成长、合作共赢、总结呈现、思考前行&lt;/li&gt;
&lt;li&gt;技术成长

&lt;ul&gt;
&lt;li&gt;1．借助导师、同事资源。这样可以让自己快速解决遇到的问题，少走很多弯路。&lt;/li&gt;
&lt;li&gt;2．系统化的学习工作所需要的是基础知识，而不是到百度或谷歌查资料解决。&lt;/li&gt;
&lt;li&gt;3．除了工作中需要的新知识外，建议在工作一段时间后再回头系统性学习相关专业基础知识。&lt;/li&gt;
&lt;li&gt;4．借助平台学习成长。

&lt;ul&gt;
&lt;li&gt;与项目共成长&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;5．如果可以对自己进行细分定位会更好。

&lt;ul&gt;
&lt;li&gt;结合自身情况以及工作需要，对自己有一个更加细分的定位，这样做精力才能聚焦， 更有可能快速在你所做的领域不断深入，进而成为专家。而如果你想要成为一个综合性的人才，也可以考虑通过阶段性专注于某一细分领域，重点学习积累，具有一 定深度后再切换重点关注领域。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;随着经验的增长，从精兵变成骨干，我们所从事的工作会逐渐由简单直接变得复杂综合且无法独立完成，这时候就需要团队协作甚至跨团队、跨部门推进。这个时候就需要我们很好地协调平衡各方资源，推进项目达成目标，并将团队的业绩最大化展现，获得肯定。在这个过程中，要注意以下几点。

&lt;ul&gt;
&lt;li&gt;（1）保持开放的心态。&lt;/li&gt;
&lt;li&gt;（2）找到一些对大家都有帮助，大家又都感兴趣或可以学到新东西的事情。&lt;/li&gt;
&lt;li&gt;（3）注重成果总结和展现。&lt;/li&gt;
&lt;li&gt;（4）注重平时的资料积累。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>C语言</title>
   <link href="http://www.5wpc.info/it/technical/language/c/2011/02/11/c"/>
   <updated>2011-02-11T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/technical/language/c/2011/02/11/c</id>
   <content type="html">&lt;h1&gt;C Programming language&lt;/h1&gt;

&lt;h2&gt;Makefile&lt;/h2&gt;

&lt;p&gt;Makefile 详细指南 &lt;a href=&quot;http://blog.csdn.net/liang13664759/archive/2007/09/04/1771246.aspx&quot;&gt;http://blog.csdn.net/liang13664759/archive/2007/09/04/1771246.aspx&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;利用make工具，将构建自动化。进而又先后出现了Ant、Maven以及Rake，这些工具不但是将构建自动化，并且进一步将任务管理自动化。&lt;/p&gt;

&lt;p&gt;总结的思维导图: ItTechnicalMake&lt;/p&gt;

&lt;h2&gt;Mod 取余&lt;/h2&gt;

&lt;p&gt;余数的定义:
  当被除数不够整除时余下的数。当都是正整数时:&lt;/p&gt;

&lt;p&gt;除法实际可转化为减数，不够减时剩下的就是余数。&lt;/p&gt;

&lt;p&gt;例如:
  12%5
  12-5-5
  2&lt;/p&gt;

&lt;p&gt;当存在负数时: x%y&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;   i. 当异号时：
                 if |x|&amp;gt;|y|
                    result: x+y
                 else
                    result: x
             例：
                -6% 5等于－1
                 6%-5等于 1
                 5%-6等于 5
                -5% 6等于 -5
   ii. 当同号时：
                if |x|&amp;gt;|y|
                    result: x-y
                 else
                    result: x
             例：
               -1%-5等于-1
                -6%-5等于-1
                -4%-5等于-4
                -5%-6等于-5
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;struct&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://stackoverflow.com/questions/612328/difference-between-struct-and-typedef-struct-in-c&quot;&gt;http://stackoverflow.com/questions/612328/difference-between-struct-and-typedef-struct-in-c&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;Macro&lt;/h2&gt;

&lt;p&gt;宏的概念在C中运用最为普遍，普通的替换和联接就不再多说。
关键是字符中的替换：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;
//字符串连接
#define DEFINE_EQ(_name)\
    equal##_name##To

...
DEFINE_EQ(Integer)   // =&amp;gt; equalIntegerTo
...

//字符串化
#define PRINT_FUN(_name)\
    printf(&quot;%s: %d\n&quot;, #_name, _name)

...
PRINT_FUN(var) //printf(&quot;%s: %d\n&quot;, &quot;var&quot;, var)
...
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;C++ Programming language&lt;/h1&gt;

&lt;h2&gt;命名空间&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;  // one.h
  namespace one
  {
    char func(char);
    class String { ... };
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一个不错的总结网站 &lt;a href=&quot;http://hi.baidu.com/%C5%E1%F6%CE0227/blog/item/26578b1295cf55876438db64.html&quot;&gt;http://hi.baidu.com/%C5%E1%F6%CE0227/blog/item/26578b1295cf55876438db64.html&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;运算符重载与模板类&lt;/h2&gt;

&lt;p&gt;需要合理考虑:
  * inline
  * 参数&amp;amp;化
  * 抽象代码与实现
  * const
  * Complex实例 &lt;a href=&quot;http://www.aoc.nrao.edu/php/tjuerges/ALMA/STL/html-3.4.6/complex-source.html&quot;&gt;http://www.aoc.nrao.edu/php/tjuerges/ALMA/STL/html-3.4.6/complex-source.html&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;函数参数和返回值&lt;/h2&gt;

&lt;h3&gt;传递方式&lt;/h3&gt;

&lt;p&gt;值传递(指针传递也是一种值传递)&lt;/p&gt;

&lt;p&gt;引用传递: 值传递的外表、指针传递的作用。&lt;/p&gt;

&lt;p&gt;指针与引用:
  * 都是地址的概念: 指针指向一块内存，它的内容是所指内存的地址；而引用则是某块内存的别名。
  * 指针是一个实体，而引用仅是个别名；
  * 引用只能在定义时被初始化一次，之后不可变；指针可变；引用“从一而终”，指针可以“见异思迁”；
  * 引用没有const，指针有const，const 的指针不可变；（具体指没有int&amp;amp; const a这种形式，而const int&amp;amp; a是有的，前者指引用本身即别名不可以改变，这是当然的，所以不需要这种形式，后者指引用所指的值不可以改变 ）
  * 引用不能为空，指针可以为空；
  * &quot;sizeof 引用&quot; 得到的是所指向的变量( 对象) 的大小，而&quot;sizeof 指针&quot;得到的是指针本身的大小；
  * 指针和引用的自增(++) 运算意义不一样；
  * 引用是类型安全的，而指针不是(引用比指针多了类型检查)&lt;/p&gt;

&lt;h4&gt;引用作为返回值&lt;/h4&gt;

&lt;p&gt;必须遵守以下规则:
  1. 不能返回局部变量的引用。主要原因是局部变量会在函数返回后被销毁，因此被返回的引用就成为了&quot;无所指&quot;的引用，程序会进入未知状态。
  1. 不能返回函数内部new分配的内存的引用。虽然不存在局部变量的被动销毁问题，可对于这种情况（返回函数内部new分配内存的引用），又面临其它尴尬局面。例如，被函数返回的引用只是作为一个临时变量出现，而没有被赋予一个实际的变量，那么这个引用所指向的空间（由new分配）就无法释放，造成memory leak。
  1. 可以返回类成员的引用，但最好是const。主要原因是当对象的属性是与某种业务规则（business rule）相关联的时候，其赋值常常与某些其它属性或者对象的状态有关，因此有必要将赋值操作封装在一个业务规则当中。如果其它对象可以获得该属性的非常量引用（或指针），那么对该属性的单纯赋值就会破坏业务规则的完整性。&lt;/p&gt;

&lt;h3&gt;不定长参数&lt;/h3&gt;

&lt;p&gt;关键思路: 利用堆指针来实现引用和调整。
&lt;a href=&quot;http://www.dutor.net/index.php/2011/08/variadic/&quot;&gt;关于变参&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;命名规则&lt;/h2&gt;

&lt;p&gt;C++ 命名规则 &lt;a href=&quot;http://blog.csdn.net/huliang82/article/details/3870153&quot;&gt;http://blog.csdn.net/huliang82/article/details/3870153&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;编译器&lt;/h2&gt;

&lt;h3&gt;GCC&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;templates may not be ‘virtual’, &lt;em&gt;typename&lt;/em&gt; change to &lt;em&gt;class&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;模板的定义与实现需要写在同一个头文件中&lt;/li&gt;
&lt;li&gt;模板中使用迭代:&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;typename std::list&amp;lt;_Tp&amp;gt;::iterator terrain_it;//define a iterator
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;临时变量无法被转换成引用&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;void fun(string &amp;amp; x){...}
...
fun(string(&quot;132&quot;));//Error
...
string s(&quot;132&quot;);
fun(s);//Right
...
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;非常严厉，连const匹配都要检查&lt;/li&gt;
&lt;li&gt;expected constructor, destructor, or type conversion before 需要在返回类型前加&lt;em&gt;typename&lt;/em&gt; &lt;a href=&quot;http://www.cnblogs.com/edwardlost/archive/2011/04/25/2027656.html&quot;&gt;http://www.cnblogs.com/edwardlost/archive/2011/04/25/2027656.html&lt;/a&gt;:
只要是符合类型，特别是利用typedef声明时，如果提示类型错误，就需要添加typename显示指明为类中声明的类型。&lt;/li&gt;
&lt;li&gt;模板类的派生类中必须显式调用基类成员 &lt;a href=&quot;http://blog.sina.com.cn/s/blog_4f183d960100j7er.html&quot;&gt;http://blog.sina.com.cn/s/blog_4f183d960100j7er.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;C与C++的整体感觉&lt;/h1&gt;

&lt;p&gt;语言的原生态或者说原始性很强，给程序员提供了一个强大的基础实现平台，特别适合高级程序员更为专业的控制与实现。
指针、模板、复杂的参数规范其实是想让编译器给我们提供更好地更为实用的帮助与辅导。&lt;/p&gt;

&lt;p&gt;与Ruby这种解释型语言不通，编译型语言通过强大的后期处理提高了效能，但是这也给程序员一个更为抽象地理解编程与接口制造了障碍。
我感觉Ruby的一个特性就是一致性，连+-*/这种原子化操作都是抽象在方法接口这一层。&lt;/p&gt;

&lt;h2&gt;Class&lt;/h2&gt;

&lt;p&gt;感觉一个类就是一个提供了小范围&lt;em&gt;全局变量&lt;/em&gt;的模块控制单元。&lt;/p&gt;

&lt;h2&gt;内存管理与指针&lt;/h2&gt;

&lt;p&gt;什么时候需要使用引用、指针，何时创建一个内存区域，如何保持一致性？
从现在的编程感觉来说，我认为需要&lt;em&gt;同一层次(函数体、循环体)&lt;/em&gt;创建或者销毁数据。
如果下层调用需要，通过指针传递进去。&lt;/p&gt;

&lt;h2&gt;编程注意事项&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;数据越界，看看template complex abs() 实现&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Tips&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Link-list&lt;/li&gt;
&lt;li&gt;if/else likely unlikely&lt;/li&gt;
&lt;li&gt;汇编实现的原子操作 &lt;strong&gt;asm&lt;/strong&gt;  &lt;strong&gt;volatile&lt;/strong&gt; ( xxxxxx)&lt;/li&gt;
&lt;li&gt;Size=0 array: int a[0];&lt;/li&gt;
&lt;li&gt;a=x?:y;  // is same to a=x?x:y;&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>商业</title>
   <link href="http://www.5wpc.info/it/career/business/2011/02/11/business"/>
   <updated>2011-02-11T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/career/business/2011/02/11/business</id>
   <content type="html">&lt;h1&gt;商业&lt;/h1&gt;

&lt;h2&gt;商业模式&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;要素

&lt;ul&gt;
&lt;li&gt;接触用户

&lt;ul&gt;
&lt;li&gt;发现用户&lt;/li&gt;
&lt;li&gt;接触用户

&lt;ul&gt;
&lt;li&gt;传统宣传&lt;/li&gt;
&lt;li&gt;网络&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;差异化产品

&lt;ul&gt;
&lt;li&gt;自己产品的独到之处&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;定价&lt;/li&gt;
&lt;li&gt;销售&lt;/li&gt;
&lt;li&gt;配送/渠道&lt;/li&gt;
&lt;li&gt;客户服务&lt;/li&gt;
&lt;li&gt;获得用户称赞&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;变化

&lt;ul&gt;
&lt;li&gt;经验&lt;/li&gt;
&lt;li&gt;市场&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;学习资料

&lt;ul&gt;
&lt;li&gt;究竟什么是商业模式

&lt;ul&gt;
&lt;li&gt;http://www.alibuybuy.com/posts/54624.html&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;向相关领域/竞争对手学习&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;创业&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;要素

&lt;ul&gt;
&lt;li&gt;团队

&lt;ul&gt;
&lt;li&gt;创始人

&lt;ul&gt;
&lt;li&gt;共识&lt;/li&gt;
&lt;li&gt;分工&lt;/li&gt;
&lt;li&gt;个人问题

&lt;ul&gt;
&lt;li&gt;步道&lt;/li&gt;
&lt;li&gt;了解自己

&lt;ul&gt;
&lt;li&gt;爱创业还是事业&lt;/li&gt;
&lt;li&gt;平常心&lt;/li&gt;
&lt;li&gt;关注家庭&lt;/li&gt;
&lt;li&gt;坚持兴趣&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;员工&lt;/li&gt;
&lt;li&gt;组成

&lt;ul&gt;
&lt;li&gt;Product Visionary

&lt;ul&gt;
&lt;li&gt;能洞悉市场需求的人&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Designer

&lt;ul&gt;
&lt;li&gt;设计出好的用户体验的人&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Hacker

&lt;ul&gt;
&lt;li&gt;快速解决程式问题的人&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Hustler

&lt;ul&gt;
&lt;li&gt;能快速解决一切其它问题的人&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;经验

&lt;ul&gt;
&lt;li&gt;风险识别&lt;/li&gt;
&lt;li&gt;推广能力&lt;/li&gt;
&lt;li&gt;运营能力&lt;/li&gt;
&lt;li&gt;商业能力&lt;/li&gt;
&lt;li&gt;管理能力&lt;/li&gt;
&lt;li&gt;节奏把握能力&lt;/li&gt;
&lt;li&gt;融资能力&lt;/li&gt;
&lt;li&gt;学习能力&lt;/li&gt;
&lt;li&gt;反省能力&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;执行能力

&lt;ul&gt;
&lt;li&gt;坚持方向、学会反省&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;点子

&lt;ul&gt;
&lt;li&gt;产品能力&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;过热后到赢家

&lt;ul&gt;
&lt;li&gt;http://www.alibuybuy.com/posts/64000.html&lt;/li&gt;
&lt;li&gt;总结

&lt;ul&gt;
&lt;li&gt;首选测试完备，赢得意见领袖好口碑&lt;/li&gt;
&lt;li&gt;率先上线独家产品线，赢得炫商业高点，为意见领袖所赞赏&lt;/li&gt;
&lt;li&gt;赢得风投后率先投放新类型广告，迫使其他公司和投资人被迫烧钱，拖垮现金流、提高竞争门槛&lt;/li&gt;
&lt;li&gt;反思内部诚信，不单单以KPI考核，防止出现重大诚信问题&lt;/li&gt;
&lt;li&gt;注意行业整合趋势，率先推出全行业的导航、搜索等产品&lt;/li&gt;
&lt;li&gt;落井下石，对手每个小错误都可以雇佣第三方放大&lt;/li&gt;
&lt;li&gt;及早上市、最早融资，收购自己互补企业，完善产业链条&lt;/li&gt;
&lt;li&gt;提炼行业价值观，向媒体传播领袖思想&lt;/li&gt;
&lt;li&gt;组织公关团队，防范大小进攻，以网民喜欢的文字提供公关稿件&lt;/li&gt;
&lt;li&gt;在市场份额下降时开放平台，做大行业&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;资料

&lt;ul&gt;
&lt;li&gt;第一次创业的人通常都有那些能力缺陷？

&lt;ul&gt;
&lt;li&gt;http://www.alibuybuy.com/posts/54790.html&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Saar Gur：衡量创业智商的九个因素

&lt;ul&gt;
&lt;li&gt;http://www.alibuybuy.com/posts/77901.html&lt;/li&gt;
&lt;li&gt;独特的对产品的思考。大多数创业者都是在抄袭。我们想寻找那1%的有着他们独特的创业想法的创始人。举例说，乔布斯为智能手机设定了触屏新标准。&lt;/li&gt;
&lt;li&gt;心理因素。什么驱动一个人前进？他们做好面对创业所带来的逆境和不确定性了吗？他们需要证明什么吗？他们有想成功的意愿强烈吗？他们准备为创业做出什么样的牺牲？这些因素都跟他们的童年有关。&lt;/li&gt;
&lt;li&gt;可靠性。这个公司是否跟创始人的信仰和价值观相同？他们是否足够关心他们现在正面临的问题？他们富有激情吗？&lt;/li&gt;
&lt;li&gt;对市场独特的视角。他们对所面对的问题是否有独特的认识？对市场时机，公司前景有独特的认识？&lt;/li&gt;
&lt;li&gt;智商。IQ，EQ，自我意识，信念坚定。创业跟下棋一样，创始人需要考虑到几步之后的走法，对于产品方向，商业决策和人员决策时是一样的。&lt;/li&gt;
&lt;li&gt;价值。他们是否诚实？如果他们做的是一个人员密集型的企业，他们是否足够重视员工或者仅仅是以自我为中心。&lt;/li&gt;
&lt;li&gt;判断力。对产品的判断，对雇佣员工的判断等等。他们是否做过什么判断？&lt;/li&gt;
&lt;li&gt;经历。他们有强大的执行能力吗？有相关工作的10000个小时工作经历吗？&lt;/li&gt;
&lt;li&gt;招募新员工的能力。包括推销你的愿景，并被人接受，打造一个互补的团队，建立一个人际关系网络，等等。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;平台化思考：4种方式，让互联网为你的公司所用

&lt;ul&gt;
&lt;li&gt;http://www.36kr.com/p/200613.html&lt;/li&gt;
&lt;li&gt;重新思考网络时代的商业模式&lt;/li&gt;
&lt;li&gt;重新思考网络时代的“工作”

&lt;ul&gt;
&lt;li&gt;利用第三方平台&lt;/li&gt;
&lt;li&gt;建立一个生产者的生态系统&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;重新思考互联网时代的市场营销

&lt;ul&gt;
&lt;li&gt;创建可以同第三方平台共享的内容&lt;/li&gt;
&lt;li&gt;为用户提供一个能创造可分享内容的平台&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;重新思考互联网时代的人力资源管理

&lt;ul&gt;
&lt;li&gt;激励办法&lt;/li&gt;
&lt;li&gt;工具&lt;/li&gt;
&lt;li&gt;公平&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Steps

&lt;ul&gt;
&lt;li&gt;做一个生意之前，请自问自己6个问题

&lt;ul&gt;
&lt;li&gt;http://www.alibuybuy.com/posts/80123.html&lt;/li&gt;
&lt;li&gt;问题1：你做的事情对别人有什么意义？&lt;/li&gt;
&lt;li&gt;问题2：你做的事情是否是别人必须的？&lt;/li&gt;
&lt;li&gt;问题3：你做的事情跟竞争者相比优势在哪里？&lt;/li&gt;
&lt;li&gt;问题4：你做的事情能否养活自己和团队？&lt;/li&gt;
&lt;li&gt;问题5：你做的事情有多大的未来？&lt;/li&gt;
&lt;li&gt;问题6：你做的事情有多长的生命周期？&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;tags: Company&lt;/h2&gt;
</content>
 </entry>
 
 <entry>
   <title>Ruby 编程技巧</title>
   <link href="http://www.5wpc.info/it/technical/language/ruby/2011/02/10/index.ruby"/>
   <updated>2011-02-10T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/technical/language/ruby/2011/02/10/index.ruby</id>
   <content type="html">&lt;h1&gt;文件定位&lt;/h1&gt;

&lt;h2&gt;文件名&lt;/h2&gt;

&lt;h3&gt;自己在哪里&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;ruby&quot;&gt;  File.expand_path(__FILE__) #所在文件的完整路径，不过如果被link后是不准确的
  File.dirname(filename)     #目录
  File.basename(filename)    #去掉目录的文件名
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;ls&lt;/h3&gt;

&lt;p&gt;函数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ruby&quot;&gt;  Dir[path_pattern] =&amp;gt; 返回符合路径模式的所有文件以及文件夹
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;模式&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ruby&quot;&gt;  src+&#39;/**/**&#39;+suffix #src目录下递归所有带有suffix后缀的文件以及文件夹
  src+&#39;/**/&#39;+dir+&#39;/**&#39; #src目录下递归所有处在名为dir文件夹下(如果最后一级是dir，前面没有dir，那么是不被匹配的)的文件以及文件夹
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;ERB&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;ruby&quot;&gt; require &#39;erb&#39;
 template = File.read(tmp_path)
 template = ERB.new(template)
 File.open(file_path,&#39;w&#39;)do |nf|
   nf.puts template.result(binding)
 end
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;其它参考&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/it/technical/language/ruby/2011/02/19/ruby265methods/&quot;&gt;Ruby常用265技巧&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.chinaunix.net/topic/ruby/&quot;&gt;Ruby技术讨论&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/it/technical/language/ruby/2014/01/15/Regular/&quot;&gt;Ruby 正则表达式&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>我的个人Wiki项目</title>
   <link href="http://www.5wpc.info/it/project/mywiki/2011/02/10/index"/>
   <updated>2011-02-10T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/project/mywiki/2011/02/10/index</id>
   <content type="html">&lt;h1&gt;来历&lt;/h1&gt;

&lt;p&gt;信息膨胀，个人时间被处理信息所占据。为了能够更好地整合各种信息，并建立一套自己的知识仓库，遂决定开始启用Wiki。&lt;/p&gt;

&lt;p&gt;在看了网上很多解决方案后，我决定采用Vimwiki的整体模式，然后配合自己的使用风格，最后决定自己构建了一套Wiki管理整合与发布脚本集合。&lt;/p&gt;

&lt;p&gt;其实这上面的数据，我觉得没有Wiki那么专业和学术，主要算是blog。&lt;/p&gt;

&lt;p&gt;一位前辈的知识管理框架
&lt;img src=&quot;http://qjg-wiki.googlecode.com/files/HowtoManageYourKnowledge.png&quot; alt=&quot;http://qjg-wiki.googlecode.com/files/HowtoManageYourKnowledge.png&quot; /&gt;&lt;/p&gt;

&lt;h1&gt;介绍&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;功能介绍 ItProjectMywikiFunctions&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;我的草稿箱&lt;/h1&gt;

&lt;h2&gt;技术类&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Android Init 程序

&lt;ul&gt;
&lt;li&gt;整体功能&lt;/li&gt;
&lt;li&gt;主要模块&lt;/li&gt;
&lt;li&gt;与外界通信: Unix Domain Socket&lt;/li&gt;
&lt;li&gt;init.rc的记法与语法分析实现&lt;/li&gt;
&lt;li&gt;属性服务的各层次关系与权限控制&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;高安方案

&lt;ul&gt;
&lt;li&gt;目标: 系统可控可管&lt;/li&gt;
&lt;li&gt;立体防御功能&lt;/li&gt;
&lt;li&gt;防更改launcher&lt;/li&gt;
&lt;li&gt;防root&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>PragmaticThinkingAndLearning</title>
   <link href="http://www.5wpc.info/it/living/selfmanagement/2011/02/10/PragmaticThinkingAndLearning"/>
   <updated>2011-02-10T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/living/selfmanagement/2011/02/10/PragmaticThinkingAndLearning</id>
   <content type="html">&lt;h1&gt;PragmaticThinkingAndLearning&lt;/h1&gt;

&lt;h2&gt;程序员的思维修炼&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;从新手到专家的历程

&lt;ul&gt;
&lt;li&gt;专家

&lt;ul&gt;
&lt;li&gt;直觉是专家的基本特征, 但直觉难以驾驭&lt;/li&gt;
&lt;li&gt;专家的行为通常很难用语言解释清楚, 他们的很多行为已经熟练到无意识, 他们大量的经验都是通过大脑的非语言区和无意识区, 这让旁人难以观察, 专家本人难以描述&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;各种规则只能让你启程, 不能让你走的更远.

&lt;ul&gt;
&lt;li&gt;初学者:对某一领域的理解仍不够好，无法有其自己的想法，甚至是在特定情况下去质疑某一规则是否适用。&lt;/li&gt;
&lt;li&gt;高级新手: 通常能够摆脱各种规则, 并能独立尝试任务, 但是难以解决问题. 比较缺乏全局观念.

&lt;ul&gt;
&lt;li&gt;但他们常高估自己，因为不知道自己不知道什么&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;胜任者:能独立解决遇到的问题, 并开始尝试解决新的问题, 开始主动寻求专家的帮助和建议, 并加以运用.&lt;/li&gt;
&lt;li&gt;精通者:有全局观念, 能反思并纠正以往的工作表现, 能自我改进, 在下一次能做的更好, 并能从他人的失败案例中吸取经验教训.&lt;/li&gt;
&lt;li&gt;专家:总是选择更佳的方式做事, 他们有丰富的经验, 并根据具体的场景选择和运用这些经验.

&lt;ul&gt;
&lt;li&gt;专家的数量大概是1~5%&lt;/li&gt;
&lt;li&gt;专家根据直觉工作, 不需要理由.&lt;/li&gt;
&lt;li&gt;专家能区分哪些是无关紧要的细节, 哪些是非常重要的细节, 而且做出这些选择通常是无意识的, 并能根据具体场景下的细节跟自己以往的经验进行匹配.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;Bug&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Bugs

&lt;ul&gt;
&lt;li&gt;Cognitive biases(偏见)

&lt;ul&gt;
&lt;li&gt;Anchoring(基准)

&lt;ul&gt;
&lt;li&gt;过分依赖客观情况&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Fundamental Attribution Error(主观)

&lt;ul&gt;
&lt;li&gt;忘却客观环境，自以为是&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Self-serving bias(趋利避害)

&lt;ul&gt;
&lt;li&gt;没有团队意识&lt;/li&gt;
&lt;li&gt;邀功避嫌&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Need for closure(只求结果)&lt;/li&gt;
&lt;li&gt;Confirmation(等人裁决)&lt;/li&gt;
&lt;li&gt;Rarely==Never(对未知进行否定)

&lt;ul&gt;
&lt;li&gt;没出现!=不存在&lt;/li&gt;
&lt;li&gt;不要说“放弃”&lt;/li&gt;
&lt;li&gt;不要对未知产生恐惧&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Generational affinity(习惯)&lt;/li&gt;
&lt;li&gt;Personality Tendencies(大众观点)&lt;/li&gt;
&lt;li&gt;Hardware bugs(自身条件)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Debug

&lt;ul&gt;
&lt;li&gt;反思&lt;/li&gt;
&lt;li&gt;Context&lt;/li&gt;
&lt;li&gt;直觉

&lt;ul&gt;
&lt;li&gt;相信&lt;/li&gt;
&lt;li&gt;验证&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;学习&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;目标

&lt;ul&gt;
&lt;li&gt;SMART

&lt;ul&gt;
&lt;li&gt;Specific具体&lt;/li&gt;
&lt;li&gt;Measurable衡量&lt;/li&gt;
&lt;li&gt;Attainable可达到&lt;/li&gt;
&lt;li&gt;Relevant与其他目标相关&lt;/li&gt;
&lt;li&gt;Time-boxed截止期限&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Context

&lt;ul&gt;
&lt;li&gt;家庭&lt;/li&gt;
&lt;li&gt;事业&lt;/li&gt;
&lt;li&gt;经济状况&lt;/li&gt;
&lt;li&gt;社区&lt;/li&gt;
&lt;li&gt;客观环境&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;知识公文包

&lt;ul&gt;
&lt;li&gt;整理&lt;/li&gt;
&lt;li&gt;扩充

&lt;ul&gt;
&lt;li&gt;拥有一个具体的计划&lt;/li&gt;
&lt;li&gt;多样&lt;/li&gt;
&lt;li&gt;着眼于未来&lt;/li&gt;
&lt;li&gt;把握住当前&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;模式

&lt;ul&gt;
&lt;li&gt;听&lt;/li&gt;
&lt;li&gt;看&lt;/li&gt;
&lt;li&gt;想&lt;/li&gt;
&lt;li&gt;实践&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;方法

&lt;ul&gt;
&lt;li&gt;学习小组

&lt;ul&gt;
&lt;li&gt;提议&lt;/li&gt;
&lt;li&gt;选择领队&lt;/li&gt;
&lt;li&gt;购买图书&lt;/li&gt;
&lt;li&gt;安排讨论&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;技巧

&lt;ul&gt;
&lt;li&gt;选择性研究&lt;/li&gt;
&lt;li&gt;总结&lt;/li&gt;
&lt;li&gt;利用思维导图进行整合&lt;/li&gt;
&lt;li&gt;通过传授他人知识进行提升&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;具体案例

&lt;ul&gt;
&lt;li&gt;读书

&lt;ul&gt;
&lt;li&gt;SQ3R

&lt;ul&gt;
&lt;li&gt;调查&lt;/li&gt;
&lt;li&gt;提问&lt;/li&gt;
&lt;li&gt;阅读&lt;/li&gt;
&lt;li&gt;笔记

&lt;ul&gt;
&lt;li&gt;在于过程&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;复习&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;积累经验&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;经验不是简单的任务清单, 必须更具体的场景关联.

&lt;ul&gt;
&lt;li&gt;Context&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;经历/尝试&lt;/li&gt;
&lt;li&gt;乐趣&lt;/li&gt;
&lt;li&gt;类比&lt;/li&gt;
&lt;li&gt;挫折&lt;/li&gt;
&lt;li&gt;发现&lt;/li&gt;
&lt;li&gt;想和做相结合&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;管理自己的关注点&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;提升注意力

&lt;ul&gt;
&lt;li&gt;How

&lt;ul&gt;
&lt;li&gt;放松&lt;/li&gt;
&lt;li&gt;沉思&lt;/li&gt;
&lt;li&gt;有意培养&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;不去关注

&lt;ul&gt;
&lt;li&gt;先思后做&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;管理知识

&lt;ul&gt;
&lt;li&gt;wiki&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;环境

&lt;ul&gt;
&lt;li&gt;消除干扰&lt;/li&gt;
&lt;li&gt;量化时间消耗&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;站在自己的土地上&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;改掉恶习

&lt;ul&gt;
&lt;li&gt;指定计划&lt;/li&gt;
&lt;li&gt;坚持执行&lt;/li&gt;
&lt;li&gt;新习惯需要时间&lt;/li&gt;
&lt;li&gt;信心&lt;/li&gt;
&lt;li&gt;积跬步&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;用心&lt;/li&gt;
&lt;li&gt;对明天要有激情&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;tags: Method Review&lt;/h2&gt;
</content>
 </entry>
 
 <entry>
   <title>精神力量</title>
   <link href="http://www.5wpc.info/it/living/selfmanagement/2011/02/10/HowToGetMetalPower"/>
   <updated>2011-02-10T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/living/selfmanagement/2011/02/10/HowToGetMetalPower</id>
   <content type="html">&lt;h1&gt;精神力量&lt;/h1&gt;

&lt;h2&gt;全景&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;宏观&lt;/li&gt;
&lt;li&gt;自然&lt;/li&gt;
&lt;li&gt;经历

&lt;ul&gt;
&lt;li&gt;死亡&lt;/li&gt;
&lt;li&gt;影响&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;训练

&lt;ul&gt;
&lt;li&gt;神奇

&lt;ul&gt;
&lt;li&gt;自信&lt;/li&gt;
&lt;li&gt;尊重&lt;/li&gt;
&lt;li&gt;欣赏

&lt;ul&gt;
&lt;li&gt;他人&lt;/li&gt;
&lt;li&gt;自然&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;帮助&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;生活

&lt;ul&gt;
&lt;li&gt;学习&lt;/li&gt;
&lt;li&gt;星辰&lt;/li&gt;
&lt;li&gt;自问

&lt;ul&gt;
&lt;li&gt;对自然的思考&lt;/li&gt;
&lt;li&gt;想象&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;气候&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;独一无二&lt;/li&gt;
&lt;li&gt;暂停&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;精神激励

&lt;ul&gt;
&lt;li&gt;我是一个设计精良的神奇的艺术作品，我持续不断地挖掘和开发我的潜能。&lt;/li&gt;
&lt;li&gt;我每天都会对其他生命表现出更多的关心。&lt;/li&gt;
&lt;li&gt;和其他人比较，我既独特无比，也完全相同。我会寻求这样的个体意识和社群意识。我所说的和所创造的一切，都会产生难以衡量的持久影响。我竭尽全力使这样的影响于己于人都有利。&lt;/li&gt;
&lt;li&gt;我生活的地球是一个天堂。我对它给我提供的生存机会心存感激；我为它给我提供的丰富的礼物深表感激；我承诺要更加珍视它，并细心呵护它。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;价值观&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;真理

&lt;ul&gt;
&lt;li&gt;真诚&lt;/li&gt;
&lt;li&gt;善良&lt;/li&gt;
&lt;li&gt;勇敢&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;训练

&lt;ul&gt;
&lt;li&gt;行为准则

&lt;ul&gt;
&lt;li&gt;边界&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;精神

&lt;ul&gt;
&lt;li&gt;真理&lt;/li&gt;
&lt;li&gt;责任&lt;/li&gt;
&lt;li&gt;爱&lt;/li&gt;
&lt;li&gt;简朴&lt;/li&gt;
&lt;li&gt;自由&lt;/li&gt;
&lt;li&gt;耐心&lt;/li&gt;
&lt;li&gt;感激&lt;/li&gt;
&lt;li&gt;持之以恒&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;依据&lt;/li&gt;
&lt;li&gt;讨论&lt;/li&gt;
&lt;li&gt;相信自己&lt;/li&gt;
&lt;li&gt;行为重要&lt;/li&gt;
&lt;li&gt;清除&lt;/li&gt;
&lt;li&gt;榜样&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;精神激励

&lt;ul&gt;
&lt;li&gt;我把真理与诚实作为生活的灯塔。我对自己和他人越来越诚实。我从中品尝到了快乐与幸福。&lt;/li&gt;
&lt;li&gt;我是一个讲求伦理道德的人。我利用我自己的原则提高自己和周围人的生活质量。&lt;/li&gt;
&lt;li&gt;我是一个值得信赖和依靠的人。我一定不会食言。&lt;/li&gt;
&lt;li&gt;我是一个公正的人。我越来越公平地处理所有与我有关的事情。&lt;/li&gt;
&lt;li&gt;我是一个有品位的人，正引导我的行为与生活朝着自认为善的方向前行。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;生活愿景与目标&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;创建目标

&lt;ul&gt;
&lt;li&gt;由自己引导&lt;/li&gt;
&lt;li&gt;承偌行动&lt;/li&gt;
&lt;li&gt;积极&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;训练

&lt;ul&gt;
&lt;li&gt;确定生活目标&lt;/li&gt;
&lt;li&gt;拥有自己的愿景&lt;/li&gt;
&lt;li&gt;帮助他人&lt;/li&gt;
&lt;li&gt;责任感

&lt;ul&gt;
&lt;li&gt;对自己&lt;/li&gt;
&lt;li&gt;对他人&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;向伟人学习&lt;/li&gt;
&lt;li&gt;自省&lt;/li&gt;
&lt;li&gt;自我激励

&lt;ul&gt;
&lt;li&gt;寻找支持&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;自爱&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;精神激励

&lt;ul&gt;
&lt;li&gt;当我的生命终结时，我已经把积极而良好的作风作为精神遗产留给世人。&lt;/li&gt;
&lt;li&gt;在每一天，在任何方面，我的精神智能都在变得越来越强大。&lt;/li&gt;
&lt;li&gt;我是一个积极的人，我把我的积极性传播给他人。&lt;/li&gt;
&lt;li&gt;我要为自己与他人的幸福与安宁负责，并热心而积极地承担起这种责任。&lt;/li&gt;
&lt;li&gt;我的生命就是一件及其神奇的礼物，我正在用这件礼物给生我养我的地球做贡献。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;同情&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;训练

&lt;ul&gt;
&lt;li&gt;表达同情&lt;/li&gt;
&lt;li&gt;富有同情心&lt;/li&gt;
&lt;li&gt;为行动而行动，不求回报&lt;/li&gt;
&lt;li&gt;与他人合作&lt;/li&gt;
&lt;li&gt;尊重你的同伴&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;激励

&lt;ul&gt;
&lt;li&gt;每一天我都在不断增强同情心与理解力。&lt;/li&gt;
&lt;li&gt;我同情自己，关注我的精神智能的发展。&lt;/li&gt;
&lt;li&gt;因为我越来越能够理解他人，所以我变得越来越宽容与大度。&lt;/li&gt;
&lt;li&gt;我深深地理解他人的神奇与复杂性，这让我的思想越来越开放和灵活。&lt;/li&gt;
&lt;li&gt;我总是尽量不勉强他人，正如我也不愿意他人勉强我一样。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;给予与接收！慈善与感激&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;激励

&lt;ul&gt;
&lt;li&gt;我是一个慈善的人，我喜欢奉献。&lt;/li&gt;
&lt;li&gt;我天生慷慨，并正在发扬这方面的品行。&lt;/li&gt;
&lt;li&gt;我有教养，有爱心，总是愿意伸出援助之手。&lt;/li&gt;
&lt;li&gt;我乐于接受他人的帮助与关心，愿意接受他人的礼物。我对此好不隐瞒，并且热情洋溢。我的接受给他们“提供”了奉献的机会。同时，他们的奉献也给他们提供了“接受”的机会。&lt;/li&gt;
&lt;li&gt;我心地善良，态度温和，总是考虑他人的需要。&lt;/li&gt;
&lt;li&gt;我的信条是友善。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;笑的力量&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;微笑

&lt;ul&gt;
&lt;li&gt;朋友&lt;/li&gt;
&lt;li&gt;去电影院或剧场&lt;/li&gt;
&lt;li&gt;自我&lt;/li&gt;
&lt;li&gt;帮助&lt;/li&gt;
&lt;li&gt;笑话书&lt;/li&gt;
&lt;li&gt;生活更轻松&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;激励

&lt;ul&gt;
&lt;li&gt;我越来越快乐。只要有机会，我都会微笑。&lt;/li&gt;
&lt;li&gt;我越来越多地看到事物有趣的一面。我把这种“好消息”传递给我的家人与朋友们。&lt;/li&gt;
&lt;li&gt;我常常欢呼雀跃，并把这种快乐的感觉融入到自己和他人的生活中。&lt;/li&gt;
&lt;li&gt;我期待着自己和世界的美好未来。&lt;/li&gt;
&lt;li&gt;令人惊异的事情和不寻常的结果都会让我心神愉悦，它们总会使我的脸上露出笑容，并且发自内心地笑。&lt;/li&gt;
&lt;li&gt;我喜欢与善良、愉快的同伴在一起，喜欢与我的朋友们分享快乐。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;童趣&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;游乐园

&lt;ul&gt;
&lt;li&gt;多样化&lt;/li&gt;
&lt;li&gt;将厌倦的态度游戏化&lt;/li&gt;
&lt;li&gt;保持快乐&lt;/li&gt;
&lt;li&gt;保持开放的思想&lt;/li&gt;
&lt;li&gt;轻装上阵&lt;/li&gt;
&lt;li&gt;慷慨&lt;/li&gt;
&lt;li&gt;舞蹈&lt;/li&gt;
&lt;li&gt;过好每一天&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;激励

&lt;ul&gt;
&lt;li&gt;我赞美我孩子般的品性，并继续强化它们。&lt;/li&gt;
&lt;li&gt;我顽皮而富于冒险精神。&lt;/li&gt;
&lt;li&gt;我是一个越来越快乐与热情的人，并不断把我的快乐与热情传递给他人。&lt;/li&gt;
&lt;li&gt;我是一名舞蹈家，随着快乐与热情旋转。&lt;/li&gt;
&lt;li&gt;我钟爱自己的感觉，并经常运用它们转以新的视角来“观察”熟悉的事情。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;仪式的力量&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;仪式

&lt;ul&gt;
&lt;li&gt;感恩&lt;/li&gt;
&lt;li&gt;起床&lt;/li&gt;
&lt;li&gt;问候&lt;/li&gt;
&lt;li&gt;告别&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;激励

&lt;ul&gt;
&lt;li&gt;我会找时间庆祝生活中的重要时刻。&lt;/li&gt;
&lt;li&gt;我喜爱个人的日常仪式，他们有助于强化自我。&lt;/li&gt;
&lt;li&gt;我不断地使用仪式，让现实更接近我的梦想。&lt;/li&gt;
&lt;li&gt;我承诺要努力实现我的愿景。我每天通过仪式增强实现这种愿景的决心。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;平和的力量&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;平和

&lt;ul&gt;
&lt;li&gt;在静默和冥想中发现力量&lt;/li&gt;
&lt;li&gt;传播&lt;/li&gt;
&lt;li&gt;抛开一切&lt;/li&gt;
&lt;li&gt;将家庭变为避难所&lt;/li&gt;
&lt;li&gt;学习&lt;/li&gt;
&lt;li&gt;大自然&lt;/li&gt;
&lt;li&gt;冥想&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;激励

&lt;ul&gt;
&lt;li&gt;我为自己，为所有的生命选择平和。&lt;/li&gt;
&lt;li&gt;我越来越平静，越来越以自我为中心，越来越安宁。&lt;/li&gt;
&lt;li&gt;我正更多地把冥想仪式融入我的日常生活。&lt;/li&gt;
&lt;li&gt;我越来越平静和富有耐心。我开始慢慢成熟。&lt;/li&gt;
&lt;li&gt;在内心平和的培育下，我治愈自己，回复安宁与平衡。&lt;/li&gt;
&lt;li&gt;在杂乱的环境中，我保持平和，在心情沮丧时，我要保持自信。&lt;/li&gt;
&lt;li&gt;今天，我对我的身体、大脑与精神的认知达到了一个更高的层次。&lt;/li&gt;
&lt;li&gt;我非常平静地观察着我的思绪的流动，愉悦地享受着内心的平静。&lt;/li&gt;
&lt;li&gt;我越来越深刻地感到自己与宇宙的联系，以及自己与宇宙的庄严、神奇和美丽的联系。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;爱&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;我是一个富有爱心的人。&lt;/li&gt;
&lt;li&gt;爱就是我的“指路星”。&lt;/li&gt;
&lt;li&gt;我利用我自己的痛苦，使自己变得明智起来，能够同情和宽恕他人。&lt;/li&gt;
&lt;li&gt;我平静而勇敢地面对不幸。&lt;/li&gt;
&lt;li&gt;我经常告诉那些与我关系最密切的人，我是那么欣赏他们，多么爱他们。&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>Introduction Functions</title>
   <link href="http://www.5wpc.info/it/project/mywiki/2011/02/10/Functions"/>
   <updated>2011-02-10T00:00:00+08:00</updated>
   <id>http://www.5wpc.info/it/project/mywiki/2011/02/10/Functions</id>
   <content type="html">&lt;h1&gt;Introduction Functions&lt;/h1&gt;

&lt;h2&gt;整合&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;内容

&lt;ul&gt;
&lt;li&gt;需要加密的数据文件&lt;/li&gt;
&lt;li&gt;技术摘要&lt;/li&gt;
&lt;li&gt;读书笔记&lt;/li&gt;
&lt;li&gt;学习资料&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;格式

&lt;ul&gt;
&lt;li&gt;思维导图

&lt;ul&gt;
&lt;li&gt;基本的转换&lt;/li&gt;
&lt;li&gt;加上标注&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;文本&lt;/li&gt;
&lt;li&gt;图片&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;服务&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;编辑

&lt;ul&gt;
&lt;li&gt;Vim&lt;/li&gt;
&lt;li&gt;Freemind&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;同步

&lt;ul&gt;
&lt;li&gt;Mercurial&lt;/li&gt;
&lt;li&gt;Google Code&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;访问&amp;amp;检索

&lt;ul&gt;
&lt;li&gt;PC&lt;/li&gt;
&lt;li&gt;Android&lt;/li&gt;
&lt;li&gt;Windows&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;流程&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;导出加密文件&lt;/li&gt;
&lt;li&gt;导出思维导图的Wiki格式文件&lt;/li&gt;
&lt;li&gt;合成Wiki文件&lt;/li&gt;
&lt;li&gt;Wiki文件注入新同步地址&lt;/li&gt;
&lt;li&gt;同步&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 
</feed>
